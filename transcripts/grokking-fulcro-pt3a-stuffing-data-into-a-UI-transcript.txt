Welcome back. In this video, I'm going to talk about stuffing data into your UI, hopefully without choking. So I realized that in this video series, I hope everyone's hanging with me here. I'm not covering a lot of folco specific stuff in. And a lot of the time I'm spending here and the point really is here to show you, I hope everybody's already getting this, but it's to show you what problems you run up against when you build a library like fold grow, or you know, reframe, or reagent, etc. And how I've gone about solving them in fulcrum. So these early videos are more conceptual in nature and more like algorithmic in nature, and don't leverage very much of what Volcker offers. But each of these steps, I'm trying to explain like one little things on the first video, we talked about, kind of low level react, and how the, you know, the rendering, in general works, that sort of thing. In the second video, we talked about how inputs work and how that's kind of a fun and weird thing. And in this video, we're going to, we're going to start feeding data to our UI. And when we start doing that, we went into the reason that 4 million different libraries exist for wrapping react. Just in the closure script, world, you've got reagent reframe on top of reagent, you've got full CRO, you've got ROM, you've got, you know, just this whole big list of, of libraries that are trying to make this story. Good, as good as it can be from different people's perspectives. So you're going to get mine Of course, since you're watching a full video. So I've put together a quick little UI layout here using semantic UI. And I'm just using folkers, Dom generators with class name helpers. And this UI currently looks like that. And so you know, see, I'm trying to put a little top menu bar in here and kind of a master detail. Left, right for, say, the people screen, maybe I'll do a similar thing for the addresses screen, maybe they'll have a home screen, this is sort of a UI routing issue. So I'm just trying to kind of piece it together and see what it'll look like. Now for this, this demonstration, I've gone ahead and set up shadow. So that it automatically calls start for me, you can set a net function in the in the build. So when I load the browser, this is just kind of a convenience. Again, this isn't the way folgore renders exactly, but it makes it so that I can just load the page rendering starts right up. And then I can just start tinkering with the UI and see how it looks. So if I pop over here and say, oh, get rid of that column, then it'll just disappear on the Hot code reload. So I can very quickly just throw things together. Alright, so now, let's talk about the shape of this thing. I've got some UI root, and I'm going to get some data I pass in here right now on pass, I'm still passing, oh, sorry, I had made a change here. tinkering around. When I was setting up the files here, I'm just passing into this plain function. This is not a react component, or even a hooks component. This is just a plain function. I'm calling that with App state. It's returning me some elements. I'm passing that to react, render, and it's making the DOM for me. Very, very, very simple. Not the way you'd really want to do it. But I also wanted to show you real quick, first of all, that I am rendering 60 times a second. So I could just go up here and say, I don't know, I can put a string around that. And then I can pull. Or they call it render frame.

And then I'll have to reload that because my render loop is right, see, see that numbers going up. And even without refreshing the DOM, if I go to performance here, and record for a moment and stop, and then look, these individual frames, even even rendering 60 a second and changing the DOM, are only taking about two milliseconds out of the 16 of the render frames. So I'm only using like, what 1/8, maybe 15% of of a CPU to do that. If I cut out the actual changes to the DOM, so I'm still changing the state atom, but I'm no longer changing the DOM. And I rerecord that. You can see that these individual frames are now down don't like one millisecond out of 16. So less, you know, somewhere on 5% it's really not that expensive to render this way you can see it, you know, rendering the system second, but it's, it's wasteful. And then once you're done gets big, it does actually cost a lot. So this isn't the, this is the right way to do a rendering of react. But let me leave that open. But for demonstration purposes, this works great for this. Okay, so how do we deal with this, it's, it's obvious once you start looking at this, that this pointing menu, well, that goes to the top. And then it contains, well, we've got this master detail thing here in this two column grid, with people in one column and the form in the other column. But this really thing right here, this, this, I'm not sure if it's the segment, or if it's the content of the segment, it's maybe the content of the segment. So let's group those together, was already grouped together in the in the grid, this grid is probably just this people page. And we're going to have another one, let's say, for the address page, that sort of thing. And so the part that's the menu, and this segment container, is probably really useful to think of as maybe your, your UI router. And we're just going to say, that's going to get some props, and let's just move this thing up here.

Okay, so the route is going to render the router, and then the router? Well, it's going to make some choices here about which page it's on. Right, something like maybe, you know, some sort of case, active page or active page is going to be defined as something

then we just want to say, you know, the UI people page, something like that. And that's what this thing is down here. And we're gonna pass that some some props. All right.

Add to that piece, people pages, this master detail thing. Okay, so I'm sort of generating a call tree here. And then I'm just gonna make a default of divino unknown route, just so my case doesn't crap out on me active pages and set and then you know, this would become

like that, we put one of those on each of these.

And then still looks like I'm rendering. Okay, don't have any errors. If I make this home, it should route me over to the homescreen with an unknown route, because I didn't put anything there. But you noticed the pointer changed. addresses is a great way just to kind of throw together a UI without having to worry about the state. Okay. So I've got that thrown together. Put that on this people page, stretch this window back out most people page I've gotten, I've got two things going on here. Right, I probably want to make some sort of component, just making a function right now. This is like the person list that has some props and that person list is I don't necessarily want that one to be defined as a column. Because I the layout of whether or not I use that list and a column or something. We could even do this as a fragment.

Again, I'm just passing the same process. And then we've got a person for

again, Passing garbage props to everything. Save that. Check it out, make sure that it's actually compiled and seems to be rendering. The actual code I've got here. Yep, that changed. So looking good. Okay, so now all I really done is restructured the exact UI had at the start of the video into sort of the way you would probably structure it in, in component form, right, you've got this tree, you pass things down the tree. Okay, now, how do we get the props here? Well, so obviously, one way we could get these props is we could just say, you know what, I'm going to put the person list in the top of my state atom, and I'm just going to make that you know, person first name, something or another.

And then instead of using props, we could just, we could just yank them out of there, right? We could just say, Oh, well, let's just get the person list out of the absentee, Adam. All right. This is roughly equivalent to a subscription like system, right? I mean, you can put mechanisms between this. And this, right, you don't necessarily have to go directly with an atom. And that's sort of a reframe does, it gives you the sort of event based subscription system, where you can say, Okay, this particular component grabs this particular conceptual data out of this particular conceptual place. And in this, I'm just saying, for all intents and purposes, we might as well just call it the top global atom. Whether or not, we have to think in this component context of where that thing lives in here is kind of irrelevant. And so now I can do, you know, a map indexed. And now we're creating a list of things. So we need a key for it. And so here, we can say person first. Keys, first names, we're going to pull the personality there, and then that's going to be a dev item. And this guy is going to be active when selected. And we'll get to that in a minute. We don't have state for that anyway. But he's definitely going to have a key of ID x. And then here, we're going to throw in first name, we're going to get rid of the extra mess there.

Okay, and I had manually put this state in here. So now this isn't in the atom yet, if I go, and we're to look in a repple, which I should have running to make this easier to follow at times. Again, I've got shadow running in repple at 9000. So I can do that. Run this guy.

Probably used the wrong type there. In ripple. Moving too quick. All right, so shadow Hapoel, we call this an app. And so if I go into that browser, and just look at the current value of app state, all I have is a render frame, which is still counting up. Right? I'm not actually so I'm going to reload this and that'll cut that def once on the app state. That puts my person list in there. And app state person list shouldn't be list of people helps if I put that on this guy. Okay, so now I'm grabbing my stuff out of the state. And now I could you know, globally, modify on the app state. You know, Association, swap app state association, person list, zero. person first name gets Bob, and I got Bob. Joe, I got Joe. Okay, so now I've got to wait update that Hopefully, if you're following along. Now there's the next problem I went and he yanked it out of app state. And I went through and rendered each of these people, that's fine for the list. But what about the for? How does this one figure out which person it's supposed to be editing? Well, I could still pull the person list. But now I've got to invent yet another little thing that where I'd like this guy over here, to have an onClick. That's somehow select the right person. So Id x is the only thing I have to go on right now. So I'd like that to be possible. So I can select which person I want to. And maybe I would even call it you know, edit person. But this ID x thing, huh, that's, that's feeling ugly. That's feeling not nice. So maybe I want to give these guys person ID one, person ID two. So maybe I could say, you know what, let's pull the i t out. And then maybe I should say, you know what, just in case somebody resorts this list, or does some mess, and I don't know, things are out of date, I just kind of worried that. If I don't use the REAL ID of the thing, maybe this generic operation that just doesn't make sense to say, edit a person at some IDs that I might have closed over at some other point in my program, and it's the wrong one now. So I don't like making this generic function. So maybe I do a def and edit person. And Id but but now, well, I've got another problem my person form while I currently stuck it, in this column of the people page. And how do I tell it? How to get to the person? Well, I can build this another, like abstract subscription sort of thing, and maybe abstract that and say, you know, in order to find person with some ID? Well, alright, so maybe what we do there is we go into

the app, state add on, man, we look at the person list, and that's all the people. And then we filter that down to the person that has the ID we want. Right? And that would sort of give us give us what we want. And so then we'd be saying, All right over here. In the person form, we're going to do some sort of lat, where we say, all right, the person we're going to add it is get person with whatever ID but oh, no, how do we pass the ID in here. So we end up with this like, system, we're like thinking about how you're going to get these things to go down through the app and flow through the app, etc, you've got really two ways of doing it, in my opinion. One way is you can feed everything from above, so that your props, you know, the component itself doesn't necessarily, well, I'm sorry, there's several ways you could feed it from from above, where the component itself doesn't really need to know the ultimate source of truth, it doesn't need to know what database is holding them, where it's holding them, how it's holding them. Nothing. However, you do kind of couple, then the parent to knowing in some way, I guess they're docstrings, or something that the child needs a certain things we pass to it, right, I need to pass this, this and this. And if you edit that child, and you have to go edit all the usage sites of that child, right, like here, for example, if I've got some person form, every place that UI person form is used, I'd go search for usages. And I say, Oh, well, a UI person form, it's being called there Am I passing it the right crap out of the database that it needs in order to render properly. And if I use that person form in 20, places in my app, and then I change that form, because I'm relying on the parent to figure out what to supply, I have to make sure I go back and edit all those. That's not very sustainable. As projects grow large, that gets to be a real hassle. So another approach would be to say, Well, you know, for person forums, these things do editing, there's going to be some source of truth. It's, it's really a server. So what I'm going to do like Apollo style, is I'm going to do some sort of, of, you know, in the in the form itself, I still have to Figure out how I'm how I'm deciding which person to edit. But in the form itself, I could have this. And this is basically the subscribe model, again, subscribed to the person, somehow, right? Whatever that is, have it, pull it from the server and just kind of have this subtree of this form be filled out. By by, again, this idea of somebody knows how to get that for me. I'll go subscribe to it. But there's still this, like problem of when I'm putting the person form here. This is the thing that's telling me which thing is picked. So I can then tell this thing, which thing is pick. So I always have this, like, I've got to look at something this thing knows, right and very often and react that's done by just like some sort of callback, right where you say, you know, on select, you give me a function, and you're going to tell me the ID of the person that's selected. And then I'm maybe going to remember that and component local state here. So that I can then pass it down to this guy there, that sort of thing. So, so to hook these things up is still a little bit of a hassle. So no matter what you do here, there's all sorts of things that are kind of going on off to the side that that make things I don't know, more confusing. So let's let's just look at the idea of well, what if we just pass this stuff down as a tree in the exact same shape? Say from root that we've actually got in the UI? What would that look like? And what would we be able to reason over that? In any sort of fashion? That would make sense? So I'm going to shoot component local state, I'm going to leave props as my as my global app, state, Adam. And so I'm saying, All right, I'm gonna pass props into this guy. And UI router. This guy wants a couple of things, the UI router, actually, I'm gonna say, root knows that within the app state model. There's a UI router key, that's going to be the UI routers data. So we'll just go match that up. So up here, we're gonna say, all right, in the database.

There's a UI router that has some stuff. Okay, that's fine. Now the UI router was that actually need Well, it needs the active page. Then what else does it do that then it needs the UI, people page. I'm just naming the, you know, the props in the in the atom after the thing that's going to render for now. Right? So. So once I'm in the UI router, I want an active page and a UI people page. Okay, so I'm gonna make an active page. I think that's one of the pages that I made. Yeah, people. And then UI, people page, which itself is going to have some stuff. Okay. Get rid of that. lead. And then the UI people page, oh, I don't want to alias things like that. Sorry, that'll that'll make it so that I can't call the functions when I D structure them. That's kind of silly. Let's take the UI off as we do that. Right. So we'll say the router has an active page and a people page. That seems good. The people page is what we passed this. By the way, if you've been playing with fogo, you'll note that I use this UI hyphen, notation, this prefix on factories that make you know subtrees basically components usually, but I use it on functions as well. And part of the reason I adopted this naming convention was exactly this kind of conflict. It was really often the case that I was putting things in state that were named, you know, after the thing I wanted to make, but then I was also making a factory named the same and then I was shadowing the renderer with the D structuring and then getting all sorts of weird errors that I Oh, why is it saying I can't call map with a map right now. It's like it would just give These strangers. So anyway, that's where that notation came from. Okay, so now the people page, the people page has two things in it, it's got the person list. So let's just say, person list and it's got a person for

the person was going to be many things. Oh, wait, no, the person list is going to be a component that has many things in the person form is going to be a component that has just the details of the person itself. So here's the list. And here in the list,

let's call this the people.

Now, instead of the person list, let's make that the people. And I know this looks kind of painful, just stick with me.

It falls into place as we go. And get rid of this on click for the moment. Okay, so now I No need that the structure and the personal list, I can instead the structure people. And here, in the person form, there is going to be the person that I'm actually currently editing. So let's say I'm currently editing Tony. And notice, when I'm doing this, I run into a problem here, I just denormalized my data, which is going to cause us other problems, which is probably why you're looking at Velcro to begin with as you run into this problem. But let's, let's just stick with it for the moment. Okay, so there's a person list in person form.

Are we lucky enough that this is? Oh, well, we'd have to reload the page to get the initial data. And that looks like it's actually working. Now, that was actually very lucky. So let's go down. Let's go up here, we can actually see the state. So now the nice thing about this particular way of of, of structuring it is I don't really at the component level, I don't really have to think about where my stuff's coming from. It's coming from above. And the above, doesn't really need to think about you know, it's above, it does need to think about we still have this coupling of Well, what do I actually need to send to the child? Right, when I call this people page will will what's supposed to be in here? I'm not sure what's supposed to be in here. So that problem still exists. But I've gotten rid of this kind of side band. Mysterious like, Where's it coming from? It's very concrete. If I go and look at my, my data here, it is a literal tree of data with duplicated information that exactly mimics the shape of my UI. And, you know, if I swap on this app, state, and associate along one of these pads, let's just do router, active page. Right, I can make my UI dance. Okay, so that's nice. The problem though, was multi fold. Right? We've got all sorts of problems now, that, that this actually makes a lot of things worse. I could go through and define Well, I could say def the people path. And say, all right, that's inside the router. It's in the people page. It's in the person list. And then it's people. And then I could write functions around that, you know, update person ID x, and then the new details. And I could say something like, you know, swap bang on the app state, merge, you know, update in on the people path, merge, etc, right? Ugly, don't want to do that. So what can I do? Well, the answer is I can normalize this. So if I were to give things, these these specific components, some form of identity, to where I could keep track of which one represents which data, then I could switch over to using a different format. That is what full crow uses. And it's, it's a simple, very fast format. So that I can still represent my UI tree and my props tree in parallel the same way, but not have it be this this hard to deal with and hard to manipulate and have duplicates in this in this actual tree form. So what I'm going to do, instead, I'm just going to hand code this, I'm going to say there are some components that just have a fixed ID, I'm going to make it a top level key called component ID. And inside of these, I'm going to put the components here that that are kind of top level things. So I've got a people page. I've got a person list component. And then I've got a person and I'm going to use, those are not constant. There's one person list. There's one people page, there's one route router, but there are many people. So since there are many people, I'm going to go up here and say, okay, each person has an ID, and person ID one is just thing.

And person ID two is that thing, right? And let's see, what else do I have here, oh, and then I have the person form. But the person form? Well, let's make a person form, there's a person form component that has inside of it, the person we're editing. But now instead of embedding the duplicate person that we're editing, we're instead going to give the path which is always a two tuple, a tuple, of two entries of the name of the place it is in the database, the table, and the ID of the person we're interested in. So now I just created a the state for a component, who we're going to call person form. And I pointed it's person at person ID one. So I'm just going to wipe that out of the tree here and say, All right, we've done person four. And then for this people of person list, I'm gonna take person list and I'm going to stick it up here, just like we had before. And I'm going to do the same sort of thing. But this is a too many. So the people edge from person list, it's sub sub edge, just has these two tuples of person one, and person two. That's, that's what people is. Okay, so that gets me person lists. So I don't need this as people things a person list is done. I'm leaving this there because I'm not done people page. So people page needs these. But instead of embedding the literal person list here, well, this is component. Id, person, list. Right? That's its address in this database, component, ID. Person list is now this thing. And then person form. Well, instead of that being a map of stuff, this is component, Id person. form. Right? See, I just manually join that together. And so now I've done the people page, it has its content. don't need that anymore. The router? Oops, I didn't give it its right name.

Right, the router now only needs Oops, sorry. There was one thing I still needed there. I did the people page, but I didn't do the router. So the router which I need to actually call router has an attribute. It's just a plain property, that's people. And then it's got an edge pointing to the people page, which is now component, ID, people page. Case and I've got the router component. Like it's got all its stuff and all its stuff has all its stuff. So I can go to the router. And so now I have normalized that database. Now, full curl comes with. Let's go ahead and pull in the namespace.

This nice function here called DB to tree that can take this normalized database and turn it back into.

So DB to tree takes, well, we have to give it a query. So here we need some eql. So DB to trees gonna follow this for me, but I've kind of got to tell it, what the the overall UI looks like.

So, and I missed one. And that's, that's this UI route. So UI route

needs to be represented here. It's sort of like the entry point to the entire database. And I missed that. So. So I'm just going to make an edge here called route, which has a sub element called the router, which points to the component. router. That duplication might be a little confusing. Because I'm using the same keyword, both the ID of a component and the property edge. We could call router child or something, but let's just just leave it for now. Okay, so now a query

for this lecture that compiled I could ask for root as a prop here. And if I run that, oh, sorry, I have to reload the page to actually get the state loaded.

There we go. So you see what I got back from DVD trees? Is it a route? Well, routes, this map that contains router? And it's the router is a pointer to another thing down? say, Oh, well, alright. Walk down route. And make a sub query on router. That tells me what's inside of it. And I'm just going to put a star there. And that's as well, a router has an active page called people in it. And then it's got a people page. All right, well, active page, right. So I want to go from the root. And then I want to ask the router, active page. And let's see no people page, but people page is another join. And that people page is going to have stuff on it. Let me run that. Alright, well, that gives me active people page. Person list is some sub component and person form is some sub sub component of the people page. Well, this exactly matches what I laid out here. Right? So you can see where I'm going the the idea, the general idea of full grow? Is this makes it fairly easy to manage. I mean, we don't want to write these queries by hand, not not this big compose mess of queries, right? A join to join to the active page, and then the active page as a people page, and then the people page has, what was it? A person less than a person form.

Right. And that person list has a list of people.

Person list has an edge called people. And in that edge, we should find a person first name and a person ID. Right? So we're, we're basically getting back the tree. If you back up in the video and see what we had manually put in this atom earlier. You'll see that it's exactly this tree. And then of course person form as a person edge and that person ad should have a person ID and a person. First Name Okay, now, the beautiful thing about this is if I take this function with that query, and again, the queries, a pain, still we haven't solved that problem. But if I take that down here, and I say, you know what, let me call UI root. And instead of

instead of passing at the app state, let's pass it, that conversion via the query. Route props. Let's see if we see if we look out here, and it actually works.

So Oh, we haven't actually destruction them. So root props. It goes looking for. See now here, we should say we want the root edge from the root props. Just kind of a, or, yeah, that makes sense. And then within those, there's going to be a router. And so now I can pass router there, which actually is what I was already doing. And we can just like, verify real quick. Now we're getting nothing there yet. So I screwed something up. So

Kay, we get back route. And then when the route is a router, so we're getting back the right tree and route props.

And there is a route there. And we go to route. And we're looking for a router. Oh, I guess I need to reload that. There we go. Now we're getting props, in fact that we're getting all the props. Okay, so let's take that log out, because it's making my laptop fan spin. Okay, so now you can see, I've gotten this back to we're out the UI. I do not that I missed something. No, I haven't got us all the way there. So we passed the router to the router, the router pulls out the active page and the people page, the people page gets passed to there and that showed up right the list.

Wait the people page had the person list than the person form? Person list person form? Why is the person form?

Person form has Oh person form has purse overwrite the form didn't have that just the person, we should probably think about, Oh, I didn't. I actually D structure that a little further, I would probably co locate the person. And I would probably make person form be a person. So let me let me change that. So I think person form should really just be a person with a different UI. So that's a different edge to get me to that same person. So let's let's switch that to be B what that is that's more what I would normally do. And say this sort of structure as the person form UI person form would just expect that there will be an ID and first name here. And then in reacts Good idea, just in case you think the properties might be nailed. Protect yourself on value. Okay, reload this to reload the initial state. Provided value prop to a form field without on change handler return by No.

case a person form that's down here and check what are Oh, my query is wrong now. Person form now queries for just what's in a person

Oh, I joined it wrong up here. So my normalized thing.

People page, the people page join. So person form and the person form is now a person ID one, and there is no separate component that is a person form, there's just an edge off the people page two person form. And now I should have Tony in the field. Okay, so stay with me. So now if I want to change a person, I can go straight to them in the database, choose the name I want to mess with. And it changes everywhere in the UI. Okay, so Problem number one solved, we're feeding things from a normalized database. So that now the idea of keeping this up to this database up to date or changing this database in some way, is always just this component by ID, router, active page, home, right, everything becomes addresses a very, very simple update. Because you know exactly where things are. And changing an edge. For example, adding a new person is adding a new edge here to this people link. So let's say this person list, I could say swap on component, person list. People. And then we could say, let's make that an update in. Right, we know there's a vector there. So we could say, you know what, let's con john another. Person ID two says make a duplicate. Now, Emily's on the list twice. We could add a new person to the table. Right? So app state, ASOS, and person ID three, the map, a person with ID three, and a person whose first name is Sally. Right. So you see the atom updated, I've got the person in there. And then we can put Sally on the end of the list. So manipulations of this database are quite easy. So this is a good start, this is a good start for keeping track of what we want. And this is very easy to reason about at any one of these at any one of these points. I'm really thinking about what I've got locally. And I don't really have to think about you know, how these props are getting to me, they're just coming to me from my parent, I don't have to have some subscription or revenge graph or whatever. But what I do have to have is this query. And I also have run myself into the problem that I do have to have a way to generate this thing. And keep this thing up to date as my application evolves. So I haven't gotten myself, you know, out of very many corners yet, I know the video is getting kind of long. So I'm going to I'm going to end soon and continue this in the next part. But I do want you to see that what you're seeing here, what I'm hand constructing is very close to what full curl gives you the tools to do painlessly. If you understand the model, right, the model is, you end up with a normalized database. That is this, it is the reification of the tree of data that exactly limits the tree of your UI. And there are some more advanced features of Velcro that let you get out of this. Like, I've got to walk from root and join everything together. For example, there's a thing called floating routes where you can have something hanging out and starting over at the root that isn't tied to the parent at all. And there's a thing called a link query that lets you say, no particular component. Yeah, I don't have this thing joined here, go back to the root and get it from that table, or that top level prop. So you're not tied to just this model. But this is the basic model. The basic model is there's going to be this normalized database that you can follow route goes to router router goes to component router component router goes to active page, which is a prop and people and people goes to this component that is the people page and that guy goes to a person list. This exactly mimics the composition down here. So what we're interested in

is creating API that makes this trivial to do to start your application up, right? How do you get this initial database constructed? A way to make this these sorts of things, integrate better with things like IO to servers, etc. But, but the basic idea of being able to stick stuff into this graph, this operation that I did right here of adding a person to the person table, and then adding an edge to the graph. Well, what if this person pointed to their address?

Wouldn't you want this address? normalized as well? So you really wouldn't do it that way. You'd say, Oh, well, you know what? I'm going to put? address? Id 11, which is this address? There, I'm gonna put person, Sally there, and I'm gonna say, Oh, well, that she uses address 11. Right. So I've put those two things in the database, and I link to this one to that one. And then I'm going to create another edge for people on the person ID and write these three things together. And then if I go down, and in my person query and say, Oh, I want for my person form, I also want Can I would I call that edge? Person address? I want all the props out of that.

helping the person list people person ID person first name. Oh, that's got to be a join.

How can I screwed something up? I won't bore you with Oh, yeah, I will bore you with typing out because I see what I did wrong.

Well, there's, there's a small, little thing here somewhere, if I look at the app, state that I've got the live app state that I've got, person address points to address 11 address 11 is there. I'm not seeing how I screwed up on the form person, first name, person address, to address 11

I am not seeing the address pop out. It should but I've just got a typo somewhere. And I'm just not seeing it. So again, I won't bore you with that. The point I was trying to make was that this sequence of of right here, I'm saying as well, it's relatively straightforward to have a normalized database. But this isn't all that convenient. And what's going to fall out very quickly, is the idea that each of these things is localized a localized concern to the component that uses it. So when I look at the person forum, for example, person ID and first name and if I also was, you know, pulling out the addresses, or address these things are known as needs of the person for what if we put on the person forum? All right. In my context, I need person ID, person, first name, person address, what if what if I just put that on the metadata of UI person form? Right? I can I can get that out of the var UI person form.

Right? There's my metadata on there, but you knows that now I've got it. added a reload,

hot code reload, come on. I didn't put that in the right place, right? Name, Doc string, Patrick, that Bob attribute and params, I always get the order messed up on those.

Okay, so I could associate the idea of, I've got some query at some component with the component itself. And this isn't exactly how folker does it. But this is the idea is that if I associate the query with this person form, then when I go to build up this query, I could build it by actually constructing it the same way. I do from here to here. So let's say that I put a query on this guy, and this query says, Oh, well, I need my active page. And then I need the people page. But it needs, I'm not sure what it needs. So I'm going to get the query from the UI people page. And what if get query is just this thing.

Again, this is a very meta of the shoot, I'm not sure how I'm going to do though vlaar. There is closure script saw this, this may catch, catch me up, but I've never actually tried it this way. But you get the idea that if I, if I've got a thing that can go and grab the metadata, let's just do it the cheap and dirty way for a moment, let's just say the meta of the var UI people page. Then when I get the up here in UI, people page, if I do the same thing? Well, let's just do it at root here. Right? If I add metadata here that says my query is I get a join to a router that uses the sub query, which is the query on the meta

UI router. And so now, if I go down here to the bottom, if I'm super lucky, let me just move this comment block up where I'm not having to go so far.

This is compiling.

Well, you get the idea. I'm not sure exactly why. I didn't quote thing.

Well, I was hoping that would compose. Like I said, I've never tried it quite this way. But the idea is, I could take the needs at each of these layers and compose them together. And now each layer is saying exactly what it needs. And due to the UI composition, this query naturally falls out. So now I have solved problem number two. Problem number one is, how do I how do I get my data into a form where I can reason about it in a way where there's not duplication? updates are relatively straightforward. I know exactly where everything is in my database. That's, that's the normalization aspect. Problem two is, how do we get the crap back out, when I have to generate this query, I mean, I could generate a naive function that just walks this entire thing from a starting point and follows in YouTube to vector, you know, tuple of two, and joins it all back together. The problem is, I might have pieces of this database that I don't currently render. And I may not want to go down those paths. So I may want this query to sort of changed depending on what's on screen, that sort of thing. So there's optimization concerns with that. But But I'd like to be able to construct this query this way. put together the pieces and We just found a way to do it by co locating the fragment, the query fragment. And this is one of the big misunderstandings in folco query is not a component, local thing that goes in reaches directly into the database to grab things. query is a fragment that has to do with this guy. So you can compose it into this guy. So you can hand it to this guy to get the tree back. As we'll see in the next video, because I think this one's getting o'clock enough, there's a bit more you can do to learn, I'm sorry, the next step is that's how to get it out. That's how to build up a query that by the way, self heals. So as I read, compose my UI and move it around, because the the UI components just need to update their little query fragments, this query will self heal as you refactor the UI. So as you move things around, so now I've got a way of, of making it. So I don't have to say anything at a component local level that isn't really component local, I have to know that I'm running the people page. So I must need to know what the people page wants. But I don't have to know exactly what it wants, I can ask it. Right, so So this composition of the parent needs to know something about its children is still there. But now if I go and change the query on people page, its query fragment, all the usage sites will automatically update. So that maintenance point we talked about in terms of sustainability and scalability of how do I ask for the right things that my children need? Well, I really want my children asking for them, I always want my children asking for them themselves. And I can either do that with this subscription model where, right I've got a lot more like disconnected things to manage and think about. And to me, that doesn't scale well to really large applications to having, you know, event trees and subscriptions. And this then the other things spread out everywhere. It makes it much easier to think about when you've got your component local query that just says here's my fragment, if you compose me on, that's what I need. So we'll see in the next video, the next problem to solve is how do I get the data in the database in the first place, right, we watched for quite some time, I didn't time it myself, but I'm sure you can go back in the time slider and see, it takes a while to hand compose these. And if you mess it up, and it doesn't match the shape of your UI tree, which determines the shape of your query. You won't get data. Right? So you need these to match up. So we'll talk more about that in the next video.

