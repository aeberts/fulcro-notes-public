So in this video, I'm going to give you a quick Well, it's actually probably going to be a fairly long multi part video set that will cover the basics of Fulcro RAD. I've been working on this for some months. And it's still in development, it's still labeled alpha. But I really do think it's the right place to start on pretty much any full group project at this point, it just does so many useful things for you that even though it's an alpha state, the the pieces that are likely to change and evolve, aren't likely to hurt you in a substantive way that the things that are evolving from an alpha perspective are things like the UI generation. And I don't expect anyone to necessarily deploy a production app with just generated UI. And you'll see through the tutorial series, how the general UI is useful for standing things up. And then once you get going, you can just like, start, start using, you know, using other things, do it or write your own plugins, or whatever. But some of the starting pieces just give you some really nice, nice things. And quite a few of those are quite stable, I'm not planning on any major external API changes. So in that sense, I'll probably move it to beta or even a release candidate soon, and maybe leave the red UI plugins marked alpha, something like that. So I've made this repository for this video series, and just made it this is essentially the focal rad demo, pared down so it's a little simpler to look at. It only supports de Tomic free, I'm not trying to show you how to use various database adapters, etc, I'm going to show you the general structure, how things work, how you can escape from the things that you don't want, how you can augment the things that that don't do what you want, etc. It's really meant to be a system that lets you, you know, do base photo development and go in any direction you want to go with just some nice pieces already in place for rapid application development. So I've already cloned this repository, so I'm going to import it to my folder logic. I thought I just stuck it in here.

Sorry, I was just moving things around. Oh, maybe I didn't move it.

There we go. That's where I wanted it. Okay, and I'm just gonna use IntelliJ here, feel free to follow along and whatever system you want. There are instructions in the readme on how to start this up from the command line, but I prefer to have

it now this project comes with quite a bit of stuff. And if you're following along in the readme or are here the way the way we first thing we do is we run yarn up to pull on NPM depths, which I had already done on this project. And then we can run a shadow clgs watch on the main build. And if we look at the shadow clgs hidden file, I've only got one built in here. There's a little bit of extra setup if you want some of rads additional features, like read supports, date time functions that it's time can be timezone aware. And so this is a way of pulling in a smaller time zone definition file so that time zones work Isom isomorphic Lee across closure and closure script, that sort of thing. So once you've got those in there, you can say shadow clgs. Watch me that'll start with the compiler, and it'll start compiling. If you want to see compile errors and stuff, then you need to go to localhost 9630 here and just look at the dashboards good enough, once it starts, it'll give that URL

and then it will start giving you updates on what's what it's doing. Now I'm using I'm using guard rails here, which is a project I forked off of ghost wheel that just does some type checking on functions as they get called. But But using specs, so it's sort of like runtime, instrumentation without exceptions being thrown, it just logs messages to tell you where something didn't match what was expected, which helps you debug problems. Okay, so that's running. I don't really need to look at anymore. Now I could just use, you know, start the closure server down here. But go up to my closure depths tab. And I'm going to set my alias, my dev alias. And if you look in the depths Eden file here, the depths Eden file has a dev alias that adds source Dev. And source dev has my, you know, development namespace for starting things up and seeding some test data, that sort of thing. So I'm gonna, I'm gonna throw that in, make sure that that's, that's loaded. I'm going to add a local, here, let me just do that. So you see what that looks like, I'm going to add a local closure repple, I'm going to tell it in repple, run with IntelliJ classpath, which will use this closure depth tab results. So I can modify that as I go. And then I've got some keyboard shortcuts set up that require me to set this flag for them to work, right. So you could ignore that that bit. The app, the the project itself doesn't care about that. This is something my ad cares about. So the way I've got it set up with the label that clj and apply that. And then while I'm here, I'm gonna go ahead and add a remote clgs which is an in repple, localhost, and then I believe I've got shadow running on port 9000. We'll double check that. Pretty sure. So if I go look at shadow, hope, yeah, in repple, server on port 9000. So once I bring the app up in a browser, I can talk to the browser with that guy. Okay, so I'm going to start my closure repple here, get rid of this depth tab. And this refresh, ders doesn't mean to have all this mess on it anymore. Source main source, don't need the development sources there, that'll make more sense. And then I'm gonna have my keyboard shortcut, which is going to essentially go to the development namespace require it put me in there. And this is why I had to set that thing, I have this, my ID set up so that it won't try to start a server if I'm in, say, a test repple, which could screw up all my tests. So I have a double check to make sure I've set the dev flag so that I don't accidentally run that command in a test repple. So this is running. And this puts the web server on port 3000 does the way I've got it configured, we'll, we'll talk about the bits of this as I go, Oops, wrong key. So I'm gonna pop over to Chrome, I'm going to open a new tab and localhost 3000. And that will open up my Dev Tools just to make sure that caching doesn't bite me. I'm going to log in. And you can see I'm working, I can see some, some tools I can play with here, I can view some accounts, I can sort some things etc. Okay, so let's talk about what all is here. So this, this first video is basically going to be just tour, just a grand tour of what's in the project. And then we'll do some further videos on on mucking with things. So let's talk first about the back end. So the back end has several pieces. And most of these are covered in the red book, which I've got a link to in the Slack channel. But this is still under development. It's 50 or so pages, it covers, you know, a decent amount of the setup and the stuff I'm going to be talking about here. So I'm gonna, you know, let you lean on that as well. But it's just nice to see it. So I'm using Mt. So I have def states, and then the name of the thing that the thing is going to end up in. And this is just an amusing server running middleware. Okay, so normal ring, middleware server, nothing fancy there. If I go to the ring middleware.

This has this rap HTML routes. This is an html5 app. So notice the URL has all this mess in it. Notice I've got let's see, I've got them sorted by account name. And let's go the opposite order. Right, let's put Barbara first, which show inactive accounts and disable one. And then let's reload that. I should see Barbara first and Sally's disabled. And right in completely close that tab, open a new one up and still sorted. That way. I can highlight a row. Reload the page, highlighting is even kept. So in order for this to work, any URL that I pass in, that isn't recognized as like an API URL or something needs to serve just this ad. HTML page. So the ring middleware that HTML routes looks for slash API, which is where my, my eql network API goes. Images is where I serve image files out of files is where I upload files to. And j. s, of course, is where the J s source code is. So if it starts with any of those, then I let the rest of the ring handler handle it. Otherwise, it's the Index page. I do have CSRF installed. And so if you go look at the, I'm using hiccup here to generate the page, this is just sort of a standard little thing, we throw the CSRF token in a VAR in the in the global space of JavaScript, and then the networking remote on the client side picks that up and adds it to a header. So that we can tell, you know, we're talking to something that we initialized through HTML. The automatic render gum using the rendering plugin is using semantic UI. So I'm pulling in semantics, actual the semantic project adopted the semantic UI and is maintaining it, the original maintainer, stopped maintaining it. So I'm pulling on that stylesheet and serving the J s. And I've got a div app. So very standard ring middleware fair. And these bits have to do with making sure full grows, even inputs and outputs are encoded properly. These two are a rad plugin that allows you to do file upload, and file serving. So that's what those are for. This is a file upload plugin from I believe that's coated in full grow itself. Yeah. And what this does is it allows mutations to send, well, basically, you sort of do this parallel thing where you post the file upload. And a temp, Id gets kind of associated with it. And then when you actually send the mutation, the mutation refers to it. And then in the mutation body, you'll see a Java IO file object for that parameter, so it'll kind of join them back up. So that's the middleware that that kind of merges the two back together on a file upload. And then every other part of the API is handled by this rap API, which is a standard, full grow. Set up, right, this is the standard standard handle API request. And you give it a function that can take a query and return a response. And here we're using a path home parser. And we're adding into the parser in the current ring request, and then sending the query. And of course, this will give us our response. So So wrap API is looking at slash API. And so when the URL is slash API that handles it, otherwise, it continues up the chain, to, in this case, not found. Now config is handled by full curls config namespace. And this is a really simple namespace, what it what it does is it allows you to discover the config component, this load config function, utility config path. And this is the config file you want it to load, it always looks for a default file. So if I go look in the config directory here, there's a default theme. And this has all my default settings. Notice, it's just a nested map, Dev, you could put anything in this map that appeared in this map or more, and it does a deep merge of the two. And then prod has the same thing. So basically, this this config, I can pass it through mount this config component, I can pass it a config property so that you know production main could say I want to use property and but in development, I can see dev even then I can get different settings for for different environments. And these even file support some additional things you can look at the full grow docs, their their support for things like environment variables and and such. Okay, so let's pop back to

the middleware i think is where we're at. So other than you know, adding in this, you know, file handling stuff, this is stock, Volker, there's there's really nothing here at all. That's, that's non standard. This is just ring. defaults, like that's ring middleware defaults. This is this function right here. These two are standard folco server, transit encoding stuff. These three, well this one has to do with specifically dealing with file upload, network integration, and these two are an add on from rad for binary lab or large object generalization, they give you some additional helpers that the automatic UI can just deal with. Okay, so the real workhorse in rad is the Python parser. So this really is a standard. And in this case, rad comes with a wrapper, here. So if we go in and look at new parser, you see, that's from rad. This has some preset plugins that it always includes, for doing things like lighting not founds, getting rid of reader errors, putting the query params, from the queries from full grown into the environment, optionally adding in a trace plug in, etc. So it's, you could build this all by hand, but the, the new parser function from rad, gives you some presets, and then you just add additional plugins in and then a list of resolvers you want. And so I'm gonna let you use the Python documentation to kind of understand that fully. But let me talk through what we have here in terms of kind of the the path home plugins that you typically use with rad and what they do for you. This is his plugins are just maps. So each one of these functions returns a map. And so this kind of plugins is wrapped the entire parse. And all I'm doing here is I'm using rads date time with timezone to give a timezone name to say, I want all of the parsing to run in the context of this timezone. So if I wanted to support user locales, as the user came in, I'd look at the request and say, Oh, it's that user and look at their settings and say, oh, they're in this timezone. And I could put it here, and now all of my resolvers will do the right thing. If I use the the RAD date, time library, or date, time namespace. Welcome to send me contributions for this date, time namespace, I'm slowly kind of adding things to it as I get to them. Mainly, what's in there right now are things for supporting, you know, inputs, data inputs. So when I go to something like this inventory, and say, new invoice and I've got a date here, I want that to be a locale aware date. I don't want it to be a date that says eight five for me, just because the server happens to be in Pacific timezone, but it says a, a six for somebody else who's in a different time. I just want it to be right. So these controls, use the timezone aware daytime, namespace from rad to make sure they, they these are all inserts. So you always have if it's a starting date, it's always midnight of this date. If it's an end date, it's actually midnight of the next day. And the control can be told it's an ending date, and it'll automatically show the right dates, you have open ended ranges, which is kind of a standard way of doing like if you're doing a report and you got a start and an ending date. This is actually one 120 21 at midnight, in the Falco database. So just kind of a commentary there. So there's timezone support. So that's what that's adding in. This is the Python plugin from the blog namespace that can handle dealing with file uploads, basically. And so you can look at the documentation on that. This is a path own plugin for the de Tomic read plugin for doing reads and writes to and from a de Tomic database that can be configured, you know. And it takes a function for selecting the connection from the end, basically, so I'm, I'm cheating here and actually just using the one and only connection that I know is here.

There's a forum plugin for doing saves and deletes on entities. So this is a, this is a layer kind of,

above de Tomic, we'll see in a minute when we look at these two pieces of middleware that there's some de Tomic stuff that gets mixed in here as well. And then this attribute plat plugin just makes the overall parser aware of the attributes that are defined in the RAD model. So rad basically has you define everything as attributes, you know, keys, keys that go with a particular factor in your data model. So, so that's basically how you set up the Python parser. And then of course, each one of these pieces has different pieces. I'm not really going to cover the blob stuff very much The Python plugin is trivial. Basically, you'd have to give it a function returns a connection connection, and it gets the path on in. So you can take stuff out of that the forum plug in is required, you have to set up the Save and delete middleware, I'll show you that in just a second. And then this, all attributes is literally just a concatenation of all of the attributes in the entire system, where the attributes is just a vector of these are just manually created vectors of attributes. So So literally, that's just like, a list of them all. And then resolvers. So the way path home works is it uses resolvers, to figure out how to get the data for queries and how to run the mutations for mutations. So each one of these, these are hand written resolvers. So I could take you to account resolvers, you'd see that's just a vector of like, hand written mutations that I that I wrote for some purpose. So in this in this particular demo, I use the resolvers names for things I'm handwritten times on resolvers or sales, resolvers, right, this like for reporting, there's some like handwritten, you know, queries and such. And that neck case, I'm just randomly generating some data just to make up fake report. The blog, blob resolvers. This is the joint point between being able to define an attribute that can refer to a saved file. And the you know, the blob hook up that does the actual saving the form resolvers. Yeah, we'll get to that in a minute. And then the automatic resolvers. So let's see which piece first let's do the middleware for the form. First, this this is kind of mostly boilerplate, some of this stuff might move into the library proper, where you just don't have to enter it at all. But at the same middleware, this is middleware that gets run when rad sees a form safe. So one of the really cool things about rad is that a save save is one function saves are normalized attribute data that a database adapter can figure out from one mutation, there's no reason to have a bunch of mutations. So for example, the de Tomic save, if I pop over here, it has a saved form function. And it's it's this code to TX this delta t x delta the transaction which builds up to one and a two, many transaction. So this namespace from about, oh, I don't know, from about here 176. Through about here, line 300 is all it takes to save a form and de Tomic, any kind of too many to one scalar attributes, etc. That does it all. And it's it's similarly tractable for other databases. So

when you do a form, save, I'm using some extra hand written middleware here that lets me rewrite what the Delta looks like. I'm adding in the blob middleware that will associate the proper things with attributes from the persisted images, and then doing the de Tomic save, which will handle any attributes that say they go into atomic. So it's really a pretty simple, kind of boilerplate II thing to set up, although I guess it's not complete boilerplate, you have to say which pieces you're plugging in. And these are, like, you know, this is that entire plugin. So feel yourself, please look at the source. It's really not hard stuff. In this particular case, this is a multi method rewrite value, where you can dispatch based on the ident of an incoming entity, and rewrite what the diff says. So let's say you've got some field and it always gets, you know, written isn't the end from the client, but you always want it to be a big event in the database, right here, you could, you could make your own multi method that could watch for those and and fix them, that sort of thing. That's what this middleware is for. And so it's really easy for you to add in your own. So let's save middleware. Go back a bit. And then there's delete middleware, which typically you just have your database delete wrapper on that. Now this is also where you could mix insecurity concerns, right? You could, in this middleware, you're going to receive the parsing and which has the request. And so you could add a layer to this that could check the incoming request against the session to see if the they have permission to do the things. And so same thing with the safe middleware, right? that this could have additional layers to this that do the security portion. And your attributes could actually cross various databases, right, you could have an SQL wrap, or SQL, save, and a Redis, wrap, Redis, save, and Firebase and whatever, Mongo and, you know, hard disk file, whatever. Each one of these will get the complete diff of what needs to be saved. And they can pick off the attributes that go in their database. So you can do a multi store story very easily. So that's why that's why it's a middleware sort of structure is to make it kind of arbitrarily pluggable. Okay, and then resolvers, you can hand write all of the resolvers there's nothing in red that requires us generated resolvers if you happen to have a database plugin, and de Tomic, one happens to be one that understands how to generate some resolvers, then you can certainly plug those in, if I go look at automated resolvers, you see this as a def state that calls this base resolvers namespace generate resolvers. This just looks at attributes that explicitly declare pathom resolvers, I'm trying to think of, of one that I've gotten this project.

Yeah, this would be an example of one. But that's, let's see if I can find a better example. Here's one. So this is a an attribute. That is called item all items. That is a ref. Attribute defaults to one. So this is a well, if the to one to many, is is advisory to the database adapter. And since we're not using a database adapter, we don't have to say it, we could write that would look like that. And so here, we can actually declare the things that we put on a path on resolver, a PC output PC resolve. And all this function does back here in the auto resolvers. This function here just goes looking for those, it looks through all the attributes, finds the ones that explicitly declare a PC resolve, and pulls them out as resolvers. And then this guy looks through all attributes for those that are declared to be on this schema, and generates resolvers for them. And so if you had multiple databases with multiple schemas, right, you could generate resolvers for each one. And if you had an SQL database where you wanted some resolvers generated from the same, right, the attributes are the core thing. So again, this is how you could have automatically generated resolvers. And I'll talk about here in a little bit, how de Tomic figures out how to generate resolvers actually really easy for any database to generate these resolvers, because resolvers are just maps. In fact, I could just show you real quick. I go to my repple. Here, when I go into this namespace, I'm going to load it. And then I'm going to just evaluate this, this one expression right here, the Generate resolvers. And notice, this is just a bunch of maps. Right, and we'll just look at the last one that pops out here. So this map is a file, Id resolver. It outputs file ID file Sha file shot file name and file Sha appsec. File uploaded on it can be batched. And it has a function that is the resolver. And its input has to be file ID. Now, if you think about if you know de Tomic you know that if you have an ID of an entity, that there is the pole query for the attributes. So really, if you look at the generated function, all this is is a D poll. Essentially, it's a deep hole, many actually because of the batching with this query, and whatever file ID or IDs came out. So you can see for de Tomic, it's really simple to do one layer. And if it's something that's got to join it like right here, we're line item resolver has an input of line item ID Again, that's a de Tomic pull query, that results in me having an item ID. And then if I've asked for more stuff, Deb's path home can automatically go looking for a resolver that can take me down this leg. So again, this just these are all just really simple generated pull queries. And you can do the same thing for SQL where they're all just, they need to be no more than that deep. Because once you get to the next ID, you can go to the next resolver and resolve it. So it sounds like you know, all fancy, complicated stuff. But in fact, the, the ID resolver for de Tomic is literally that much code. Right, here's the right do an entity query, we're an entity query is nothing more than a bit of data munging, followed by a get by IDs, which is a pole star. So don't be intimidated. You know, again, look at the source if you don't understand something. But hopefully, you're seeing very quickly that there's nothing in red. That puts you into any sort of corner, right? It's all path home resolvers. If you happen to want to use the generated ones, great they work for you. If you don't want to use generative ones, don't use them, use your own database, hand code these things, what have you, I think you'll find that, once you've put the data in the attributes to describe what things are, it's really easy to write code that just generates that crap. So why not do it, why not use it? Okay, so let's go back a little bit. jumping around through a lot of pieces here, a lot of back buttons to find where it was. Okay, so those the automatic resolvers form resolvers. This basically just add, save form and delete entity, these are just two predefined mutations.

And notice what they do is they use the middleware. So the middleware ends up in the path home end. And then these predefined, save and delete mutations in this namespace, allow me to write automatic code on the front end, that knows when I'm trying to save something will call save form, and then it will use the middleware to figure out how to actually put this stuff in the database. So this is, this is, again, pretty thin, right? There's, there's, it's this file is kind of long, but this namespace form is a CLG. c file that that handles saving, deleting, and pretty much all of the UI except for actual UI generation. So for example, if we go up here and take a look, form controls are in here. The the outline for rendering those, there's no Dom stuff in here, but but how the rendering is structured, goes in here. Form nesting, generating new instances of forms. Default Values, the form state machine, what to do on routing, formal enter form leave like doing things like denying route changes, because the forms dirty. Right. So a whole bunch of logic that you would normally have to write is in this namespace, which is why it's so big, but in terms of the server side of it, the server side of it is basically the middleware that you add in there, save, right save, call save forum, star, save forum star pulls up the middleware and calls you're not aware, that save and delete similar. So. So that's what's in the path on partial there's, there's a lot here in terms of functionality. But again, I encourage you not to be intimidated by the fact that it seems to do a lot for you, each one of these pieces is relatively straightforward, if you understand its, its core concepts, and most of those concepts are path home resolvers and middleware. So, so the middleware concept, if you're new to closure in general, study up on that threading these these functions through each other is a little heavy when you first look at. Okay, so there's a ring middleware. Most of our work is done by the parser. Most of the parsers work is done by resolvers. Many of the resolvers can just be generated for you. That's kind of the base, the base level, I'm not going to cover the blobstore. Really, I've already talked about the auto resolvers. Just like literally it looks through all attributes and finds the ones that have PC resolve in them. config is folkers config. This database queries namespace is just some functions that can run data. On inquiries for me in the original demo, there's an SQL version of this in the comment version of this, to pull that into separate source directories, but I just pulled it in here. So like get all categories, just does a query on the database, looking for things that have a category label, and pulls out the category ID, and, you know, maps that over and gives back a map of those. Not really much to it. Notice the end here ends up you end up with the de Tomic databases in here, so you can pull the database out, etc. So, and this is an atom. And that's important. Because if you do a mutation that has follow on reads, or it's a mutation join is what it's called, it doesn't mutation, and then a follow up query. Usually, you're querying for the thing you just mutated, you want to create that out of that updated database. So mutations are automatically update and add them in the in the hole to the database, so that you, you get the most recent database since the last transaction. I've shown you the Delete and save middleware, that's the server that really is the server, the database queries as the majority of the handwritten code on the server. The rest of this is gluing together existing rad pieces or full curl pieces. So you know, glancing through it, again, all resolvers tiny blob store, just setting up this case, this is a little helper that creates a blob store just in your temp directory, whatever that happens to be just for playing so that you can actually upload files to your local disk, but not have to worry about cruft.

config is just that phone call config database queries, these handwritten few queries, the de Tomic bid is just starting the database. The delete middleware is literally one line, the parser itself has the real workhorse, but it's pretty tight too, right? Give me all the resolvers you want, and what plugins you want to use. middleware, very stock stuff, save middleware. Again, this is this is for middleware. So this is just figuring out how to take an incoming save. And this case, rewrite the diff. Persistent images that go with the attributes in the database, are actually associated attributes with the images that are available, and then put them in a database, middleware runs from bottom up, for those of you who are new to it. And then the server itself, literally just a mutant, web run on the middleware. That's the server, there is a logging namespace that clj see that I've put in here just to add in some helpers that configure the logging to make it a little tighter. So if you notice in my log messages over here, restart the server, I just have a, you know, one letter for level D, for debug I for info, more compressed time. And then, uh, you know, my log messages are easier to read and development as a result of this. So I clipped the namespace so that all my messages end up aligned on the same column. So nothing crazy special there. Okay, so that's the overview of the server. It's going to be a bit longer as we walk through this, let's let's take a look at what we have here. So attributes, the basic setup here is, the recommended way to do this is you create a model file. And you create an all attributes stuff and an all attribute validator. And in all attributes, you basically require all of your model namespaces that have attributes. And inside of each of those, you def an attributes vector that you list all of your attributes in. And then you just put them all together here. So there's one of the requirements of rad is you have to hand it all of the attributes in your data model for it to understand how to do anything. And instead of having things that side effect, which I generally they're convenient, but they're also real debugging nightmares. So because this gives you a very explicit traceability path, if something isn't showing up in your model, it's because it's not listed in an attribute. And it's not because you've accidentally cleaned up a require or something and a side effect didn't happen. So So I put all my attributes in a vector, all my handwritten resolvers in the vector, and then attributes I can bind here. This is a function that can make a generic validator based on attributes settings for using in the UI. And so you passed all the attributes and it looks through them and figures out. validation rules for them based on what You've declared in the attributes. Okay, so let's get to the model, the model is pretty straightforward. All of this stuff is, is meant to be pretty tractable. So the namespaces that end in hyphen options. With the exception of picker options, which is a little bit, it's a name I picked before I went to this standard, so pick your options is a little, little odd. But attribute options, forum options, these namespaces defined keys for you. So the trick here is you can say, colon colon at tr slash identity. True. And just use the ATR namespace to name a particular option with this attribute needs. And that's this, this namespace. Unfortunately, this means that if you make a typo, you have no idea you screwed it up. And it also means you've got no doc strings. So instead of doing that mess, what I did instead was I created these namespaces, and they have nothing more in them. But deaths, have a have a VAR, that are the symbol, another symbol, the keyword you want to use along with a doc string. So you can get a doc string. That's, that's really what those are for. And you can get completion, right? You can look there and go oh, yeah, what do I need? Oh, right, I need carnality. One for that. What does it take can be one or many. Right? So that makes it a little easier to to discover things. Good idea to just read the entire, like, just read this entire namespace just to understand what's available. Same thing with any of these options.

Now, read is built around the idea that entities will have an ID that has a unique name that goes with that entity. So that's concept number one. You can use native IDs I've not. I don't personally do that. So I've not spent a lot of time debugging those and making those work well. So for example, if you want to use DB ID I think you can say de Tomic, native, true something like that if you're using de Tomic. And that tells the driver underneath to map these names to dB ID. But I'm going to recommend just for the sake of playing and understanding how the, the de Tomic adapter works. Give yourself something like a UID for account ID. This marks it as something that identifies entities, and any entity in the database has to have at least one identifying attribute. This defines what schema you expect it to go with. Now, you could use the same schema across different kinds of databases, even this is just a made up name. That that used to configure in the other plugins. So when I configure my de Tomic plug in I tell it, I'm going to have a production schema. And when I asked it to do things like generate, Oh, I didn't see the generator, there's actually a generator, which is probably in my server startup. Where I can generate auto generate the schema using the plugin, and I'm not using the SQL, guys, let's just strip those out. So I don't. So we don't confuse ourselves.

So just pretend like those aren't therapies, human resource. So that's kind of the minimum amount of things that you'd put in something that's going to go on a real database. If If this was something you were going to write a resolver for yourself, you wouldn't even need that. Okay, so you go through and you define your, your attributes, you give them a symbolic name, a keyword, they, that becomes its kind of RDF style, namespaced name and the data model, its data type. And these data types are extensible. You can really use anything here. And it really boils down to does your rendering understand it? And does your database adapter understand. So you kinda have to look at the documentation for those two things to find out what, what data types to use there. There's also they're also also things like style, which again, is just kind of a made up thing is can be a keyword or a function that returns a keyword that indicates Okay, this is a string but maybe it's a social security number. Or maybe it's a phone number that I want to have hyphens in it, that sort of thing. So style is a hint to the rest During invalidation layers if your plugin supports it. So this is kind of a fully extensible look at the documentation to find out what you can put here. to kind of say what style this thing is, what is this really and more specific, required as a hint, again, to the various plugin layers of whether or not this thing is required to be on whatever entities that lives on. And this one is the join point. So identities names all of the identity true attributes in your data model, on which this fact account email can live. So in cases where you've got something like, why is that giving me an error? Oh, I accidentally deleted my opening curly brace. Let's see, you've got something that you put on multiple different entities, like a reference number, right?

That might go on, you know, orders, they might might also go on images, it might also go on whatever. Right? So that's the idea is the This defines oops, one more. This defines which entities This fact is expected to live on. This is used by resolver generators. So when de Tomic comes along and it says I'm working on production schema, oh, this is a production attribute. So this must This must go in my database. I want to write a resolver. For that, how do I get to account emails, oh, I get to account emails, because I'll be given an account ID. So given an account ID, I can give you an account email. That's exactly how our resolver is generated for this. So it scans through says I'm a database provider for production schema. This is an account, Id might have an account email. So if somebody gives me an account ID, I can give an account email. And the way I'd look it up is do a query for an entity with account ID blah, and could be account email, right, you can see in SQL, be the same thing, right select account dot email, from account where account.id equals whatever incoming account ID, like it's trivial to generate a resolver for this attribute. And it's trivial to generate more than one resolver. Right, by that now generates two resolvers. If I'm using automatic resolvers in a database, plug in, one that can start from other ID one that can start from account ID if you want additional resolution, so say for example, I decide I want to count email to be resolvable from something else, you could define your own custom, you know, path home resolver and say, PC input is account. So you make these unique, and this code PC output, an account ID. And you've got to wait us to start a query. And then of course, the resolver, you know, the code actually do this query, select where email equals blah, you know, select ID, where email, blah, is the resolver body. This would let you go from account email on a query to an account and get all the details from there. Okay. And then the various adapters, right, these are open maps, you have some custom plug in thing, you just stick it in this map. And then if you want to go find that attribute, you can you can, it's it's in a lookup map in the environment to path home. So every resolver would have all of these facts about each attribute. Now, these are also clj C. So if you do write some, some attribute in here, let's say that this is a function that expects m and this is going to be some closure specific code. Then, you know, make sure that you wrap it in a reader conditional. So that so that doesn't break your front end compiles. So these become a universal source of truth on both the front end and back end about individual attributes. Okay, so that's enough of initial tour of those basics, and we're getting kind of long on this video. Let's see what this actually looks like. Once we start combining the pieces, so you've seen all of the back end, you've seen what attributes look like. Let's go look up, look at what a UI looks like. So our our main UI here just has basically some drop down menus. I can put that on top and this on bottom and, and we can see, this account menu has view all a new view, all in new. And note, I'm using some rad routing, where I can route straight to a UI component. And I've got a form helper that lets me go straight to a particular form. So when I say, new account here, I'm going straight to, I'm going to jump in code, this form. And this form is keyed by form IDs, these are form options. Right? The attributes will act as the primary key for this form. And then I'm going to list out the attributes I want name, primary address, role, timezone, email, right, and notice primary address is a sub form. This is a to one relation just to show how to ones are done. So this entire form that I've got here, which includes file uploads, adding additional addresses, which is to many

sending the email, using a drop down to, you know, find a particular time zone to set myself in a time zone, you know, state drop down, etc. With Undo, I can clear all that stuff out, cancel, etc, which goes back. That's a whole lot of functionality for line 70 back through 3634 lines of code. Actually, there's a little more in that because there's an address form a file form. And so we can see the address form here. There's another seven lines of code. And there's a file form for the file upload. Alright, there's another eight lines of code. So this is the real crux of, of rad, is very quickly being able to stand up some some simple crud style stuff, some reports that show me some things, some editing with some validation to let me make new things if I do new here and hit save. Oops. And I hit a bug.

Yeah, I hit some rendering bug in my rendering plugin.

I had absolutely nothing filled out, which I usually don't do.

Yep. All right. So there's a great demo. That must be something I broke here recently. The point is, the validation is there as well. And I'm not sure why that particular one. There we go. picker, line item category widget. I lose the quantity. Probably timezone related, I was messing with time zones over an account. So you can see I get validation, I get some Calculated Fields out of here. etc. You also see that this, this URL, as I'm moving around, the URL is constantly updating and keeping track of what particular thing I'm doing and where I'm at. So if I reload the, the Oh shoot, I get the Create instead of the Edit. You all

should be able to reload and go back to that. Same Yeah. Same guy. So the combination of this HTML five routing, the, you know, the real quick use of these things. buys you a lot for standing up a system quickly. In the next video, I'll cover a little more about how you build these individual pieces and what some of the pieces mean and how you very quickly can escape from any of it.

