The next thing you'll want to understand about Fulcro is how to get your application in a reasonable initial state for initial frame rendering, followed by then how to evolve that state over time, in the way that we'd actually like to do it in the application, so we're going to stop using these, these, we're gonna use these for educational purposes in terms of dumping state just to see what's happening. But we won't be using these directly. For for this, this step other than other than for those those purposes. So in terms of initial state, you need something in the application for there to be anything showing up. So if I reload this application, it just shows empty stuff. Because again, if I were doing this, you know, properly, I probably wouldn't even render person if there wasn't a person coming to me on props. So it really just see nothing. And I can go down here and do merge component. But you don't necessarily want to have to manually do that step, it turns out that there's a very easy way to deal with this, we compose our query from top to bottom of the tree. So we've got the root of the tree, it has this key that joins to this sub component. And this sub component has this key that joins to this sub component, etc. And, you know, when we get the query of the top level component,

right, we see that entire tree of query, it walks all the way down to the bottom, because that's composed together. I mean, we structured it that way, right? We literally put the query from that one here. And we literally put the query from that one here. And by the way, that composition is very important that you get the query from the component, because remember, that carries along metadata that identifies how to get back to this component for normalization, so can find the identity. So we can do initial state the same way and in fact, focal supports exactly that. So instead of having to do this manual step of inventing a tree and then trying to keep this in the same shape as the UI through refactorings, etc, right, I move some subtree around one that my initial state doesn't match, I gotta go fix that. So they're very simple thing, let's just declare it here. So my initial state of sample, and there's two ways of declaring initial state. And I'm going to show you the nonmagical. One, it looks like a lambda. And it takes a parameter map that we're going to ignore. And it's return a map that contains exactly what this level of the graph should contain. Well, it should contain a link, you know, an entry for route person, but what should that data be? Well, that data should be the initial state of a person with and then an optional parameters map here. So I could say, you know, Id one, name, Bob. Right. So these are really meant to be parameters. And so then up here, in person, I say, Oh, well, my initial state is a lambda. And here I can D structure out the parameters that the parent passed to me. So I have ID and Name are going to be passed in and those are not namespaced. And then what I'd want is to put those in the person ID, person name, person age, we can just default to something. And then person cars will just say is empty. There's an empty list of cars, we don't know what their cars are. Yeah. So if I were to do that construction, I'm going to save and let it reload. Now, just like in do a query, on sample I can ask for Well, what would you like your initial state to be? And if you look at this, this is exactly the tree that I like to essentially merge via something like merge component into my state database. So if I go and reload this now, you'll actually see that's what happens. If I go look at the current state, I've now got a normalized route edge that points to a normalized person that points to an empty list of cars. This just happens to be an ID that the fulgur inspect tool inserts into app state. So we can distinguish multiple apps on the screen from each other. And you'll notice here, I can look at the state database in this tool as well. So I'm seeing the same sort of thing person aged 20, no cars, Id one, Bob, I can, you know, click on these fields and watch them in the inspect tool. So I can watch them change. We'll be using that more as we go. Okay, so initial state, it's as simple as that. You just declare what at this level you need and then ask for things that you join that way and then if you refactor the UI, all you have to refactor is the local concern if you move this UI person, somewhere Welcome, you need to move it's an initial initial state poll, and it's its query to that new place. That's it. Everything self heals from there. So it doesn't matter how deep in the tree you are, you can pick things up and move them around. And of course, you can just continue going down here. So here, I might say, Get initial state of a car with id 40. And I'm trying to specifically make it look like these have simple names as parameters instead of

keywords, you could argue that that's a bit of aliasing, but it's enough to go up here to car.

And then of course, since that's too many, I could decide to do several of them.

Okay, so the next point is on hot code reload, you notice my UI is not updating, that's because this is initial state. So the initial state declaration, the next thing you need to understand about that is it is only for starting up the application. So this data is actually pulled just like I'm pulling it here, right as a tree. By mount, the very first mount. If you call mount again, all mount does is force re renders the UI and doesn't reinitialize the data, which is what you want, right, when you will have hot code reloading, if you're three levels deep in the app, and you're logged in, you're working on a modal and you want to see the modal update, you want to you want to see the entire app reset to the original state. So this is only applied on the very first amount. And that's exactly how it works. If you go and look in in Mt, you'll see it It calls get initial state, it gets this tree, it then uses a different function for merge component is called treated dB, it's in the normalization namespace to convert that into a database, and then stick it in the state Adam. So we no longer need that merge component. And in fact, we no longer need these. So that's how we get the initial state. And because that tree exactly mirrors the destructuring, the join in the query the initial state, to adjoin down to the thing we queried from right, it's exact mirror, it's really easy. To see that you got that right and to and to know what to put there. Now I want to show you the alternate notation for initial state, because you'll much more commonly see that and it can be confusing at first. So because this always parallels the query, the the the join route person, get query person, folk who can actually look at the query and from a much simpler, less boiler boiler plate set of things, figure out what initial state should be without having to type out a lambda. And so again, this is a little bit of magic that def SC can do for you. And so the basic thing is eliminate the lambda. If you had parameters, there's a way to get to those, but just turn it into a regular map. Now behind the scenes, def SC is going to rewrite this to a lambda. And you can still write it this way. But because it knows route person is a join to a person, it knows it needs to call get initial state on a person. So all it really needs is the parameters. So that's equivalent. Now the cool thing about this is if you misspell something in your initial state, it can tell you initial state includes this key, but your query doesn't have that. So you get a little extra, it's less boilerplate, and you get a less a little more error checking just like we got up in here. We tried to D structure something that wasn't in the query, and it told us well, you're asking for root is but you didn't ask for it in the query. So you're not actually going to get it. Because full grow on the query side of things. doesn't force that. Now, these are just parameters, remember, so this is just a parameters map that gets passed into here. So then you might ask, Well, how do I get to the parameters? So in this notation, there's just a simple notational thing that I invented for that. So there's how you get your parameters. That was a complaining about here, I may have Oh, these same thing. These are now just parameter maps. Because you can look at this query and see that Oh, when you're specifying cars, oh, I can call get initial state. On a car, and you can just pass me the extra extra data. And so we can go up here and do the same thing here, we're expecting a parameter for ID parameter for model. And it's just much tighter, it's a little hard to read when you don't understand it. But it's much easier to deal with and read. When you do. Now, I've got that all hot code reloaded, if I reload the application to cause it to re ask for initial state, you can see that the person comes in along with their cars. And if I were to go to Volker inspect, and look at the database, you'd see all the cars got normalized, the person got normalized, the top level edge points to that person, and we have the sub edges. So everything's working the way we would expect it to work. So that's initial state. Okay, so there's step one, you mount the application mount goes looking at things that need to be there for the first frame to render reasonably. Now, of course, in a real application, this data, you know, for cars, and people, and so on, and so forth, would probably be on the server, but you're gonna have some interstitial stuff, you're probably gonna have some UI routing things, you're gonna have some some other things that have data that can change. That's purely client side. So that's what initial state for it's for purely client side setup for the very first frame of rendering.

Okay, so then, what's the next step? Well, the next step is we actually want to be able to, to evolve this state in some way, shape, or form. And so that's the job of mutations. mutation namespace, I've added to, to this file require for it. And def mutation is what we're looking for. So let's go through the basics of def mutation. And the fact the various interesting facts about them, so mutations in full CRO are meant to be dealt with in a data like manner. So when you when you invoke a mutation that actually goes through a transactional processing system as data. And then the combination of local and remote behaviors can be co located and coded into single units of code. And so that's really what def mutation is making for you. So if I say, def mutation make older, and I get params here, so I'm going to pass in as brams a person ID. So I'm just D structuring a map with you know, person prefixed keywords, get the idea there. So deputation looks a lot like a function, if this is showing up yellow in your ID, you can click on click once on it, usually and click once on it light bulb will appear. You can choose resolve, actually click here, not over here, click click here. And you can say specify def mutation. And the older namespaced version of this vocal client mutations, deputation, if you pick that IntelliJ currently understands the old versions, I haven't talked to Collin Fleming yet about updating cursive to support the new namespaces for these. But since it already understands the syntax of this, you can just use that one. And then we'll understand the syntax of this particular macro. And this is a little little bit of boilerplate here. But you'll see why it's not really boilerplate, it is sort of the minimum amount of information you need. So mutations can take a map, a single map, single parameter, that is a map, which of course can contain as much junk as you need. And then it can have several sections. So for example, this mutation needed to talk to some remote and then some REST endpoint and some other thing I can specify remote behaviors here. And the action section of a mutation is what to do locally. So what do you want to do to the database here, and your past and environment. So that's what this this one argument is, which is a map that has various things in it. And one of the things that has in it is a binding to that state atom, we were playing with an earlier videos, which is the state database. So here's where I can do my manipulation. So if I want to make someone older, I have to go to the state database. And I have to do an update in at person iD iD person age, as we did earlier, and increment it. That's a mutation. I'm going to do something here, that's going to seem a little odd. I'm going to unmount the application, because I want you to really concentrate just on the data model. So it's just gonna say loading, but it is actually loaded, right, I can still go down here and say,

give me the current state, and it's showing me Show me empty things because I don't have an initial state now because I unmounted it so i think i do want

I'm just gonna merge some Let's give them an age. Oh, this is the merge namespace. Okay, so I have a normalized person here. So the trick here is I want to show you how mutations work kind of, kind of fully in. And it's really important to understand the pieces of how poker works, it makes it a whole lot easier to understand what's going on. So the first thing you should know, is when I call that mutation as a function, which I can do. So I'm going to run that run clear the repple. So you can see it very clearly, when I run it, it gives me back a piece of data because we back a list that looks like a function call in to this namespace with parameters. And that's a key important thing to understand in full CRO, is mutations when you invoke them this way, as functions, they just return themselves as data. So mutations, as far as the wire protocol goes, you know, to remote and locally in the transaction processing system. A mutation is just data. So I could just as well have back quoted that, and unquoted, this if I needed to put some, you know, bound variable in there. And in folco to in fact, that's what you had to do unless you used an incubator add on. But for fulcrum three, we decided, Thomas Heller of the shadow clgs compiler had suggested some time ago, well, why don't we just make what the deaf mutation outputs work this way, which is nice, because it gets rid of the quoting. And there were reasons in folder to or that that wasn't a good idea. But because we were moving to an API look alike with the focal three rewrite, this was something that I wanted to, to adopt. So again, I quote that, and I'll get that that exact thing, or I cannot quote it, and I'm not what I'm doing here is I'm calling a function that just returns that data structure. That's what that's what def mutation binds to the UI. But the other thing it does, is it registers technically behind the scenes with a multi method, the symbol, so that we can actually get to these, these sections of the mutation later. So that's, that's what's being encoded here. So to actually cause a mutation to run, we have to submit it as a transaction. And that's what transact is about. So transact is meant to submit from the UI and abstract operation that might have both local and remote or just remote or just local effects to your application. So let's say we go up here to the person class, and we add a button. Well, now we'd have to mount it, let's do that in a second. So if I run this mutation, make older person one. So let's look at current state current state person is 20. When I run a transaction, this is actually submitting this data structure as a list of things. So I can put more mutations in here, if I had them to run, it gives me back a transaction ID, then it runs the transaction, which then affects the change to state. So you can see the age went to 21. And you can also see that some state tracking happened for possible remote activity. Now this one didn't ask for any remote activity, so nothing actually went in there. But you could see that that that that has the effect. So this is the state management, evolution story. And because you never talk about remotes in the UI itself, it makes things just much, much cleaner. So let's go back to mounting this. And we'll get the first mount that'll actually populate our state again, right. So here it it was the first mount because it hadn't been mounted sore state went to back to age 20, in the cars, etc. It grabbed initial state, because it hadn't been mounted before. And so now it's very simple for us to add a button who's on click?

Which person are we dealing with now? Oh, this this person, that's switch person we're making older, right? If we had more than one person. Now notice this is is yellow. And that's because closure reads top to bottom. And so this mutation needs to be, you know, above or in a different file or what have you. Or if I if I just want to treat this as pure data, I could do what I was talking about earlier, I can quote it, I can unquote. And that will actually work fine. Let's put a label on that button. And so now if I tried to make them older, their age updates. So now we're getting much much more towards how you really right now Application enfagrow, you've got your initial state frame that shows you what it looks like on the very first render frame. And that will never be applied. Again, this is never This is not a constructor, it's it's, it's really has to do with the initial state of your application database application start, it's just an easy way to compose it, and keep it in the correct shape through refactorings. transactions, RUN RUN mutations, mutations are sent as data structures, which is why I'm quoting here, for convenience. And only for convenience, there's no need for convenience, you can make sure that mutation is visible at that code level. So again, it could be in another namespace, and I could require it here, it could be declared above it. A lot of people like putting their mutations in a different namespace from their actual UI, it's perfectly reasonable concern to want to separate your implementation from your, your view. And but here, once you have the thing visible, this Deaf mutation actually does put a symbol in your namespace called make holder that will return itself as a data structure that's does that just makes the syntax a little nicer and to look at and you can see, it still works just fine. And behind the scenes, if we go to inspect and look at transactions, you can see that when I make older I actually see that mutation come across the wire as the thing that happened. And I can see in here, the diff of you know what it was before and after. So that's initial state, and our first look at how mutations work and fold

