So continuing on, we've seen so far, how we can normalize our data and end up with the ability to show, you know, mirrored data within the UI in a way that's more sane way to update that data that, again, seems more sane, we can just go to a particular entity in the database and update it directly. But the problem we had was getting this to normalize back into a tree required, we write this Big Query. Now, first question you might have, or the first thought that might come to mind is, well, why do I need the query, I can write an algorithm that easily enough when it detects one of these things could just follow it, and resolve it? And if it takes another one, follow it and resolve it, etc, etc? Why not just do that? And that's an excellent question. And the answer is multi fold, actually, but one very clear answer is that as your application gets large, you have lots and lots and lots of screens in your application, and only one of them's on the screen at any given time. Like so far, we've only shown people page, but there's a homepage, there's an addresses page.

Right, and all the things will have data. And if you have an algorithm that just simply walks from the top and expand that in tire tree of potential visible data, well, the performance starts to suffer pretty quickly. If you have, you know, 10 different tabs, and each one of those tabs has 10, potentially little sub things, etc, etc, etc, you end up for every frame of rendering, pulling out way more data. So you end up over querying the database and pulling out way more data than you would naturally want. So so that's one answer. And this naive implementation that we're doing here doesn't actually give us the ability to pair the query down the way that we've been showing it done, and I'll talk about that here, a little later in this video. But that's one reason you don't want just an auto fan out. The other reason is, you might actually want to see this vector as a prop. So it's possible that in your component, what you want to know, is, is this vector, for example, let's say you're doing a drop down and you're selecting things from the database, the thing that you might want to see is what's currently selected. So there a couple of different reasons for, for doing that. But obviously, hand writing this big tree of query that happens to exactly match the big tree of data isn't natural, we talked about, and I kind of played with metadata here, but I knew there weren't bars and clgs. So x, I was surprised I got as far as I did with this, with this metadata attempt at a hack that we were trying here was trying to make it look like it looks in full curl. But in fact, what what you'd have to do to get this to work in JavaScript functions are JavaScript objects, and you can set things on them. So we can actually say, full crow dollar options. This is the the hidden kind of name that folker uses. And I think we'll have to tell it, this is a particular kind of object there has a query function, because in folklore, these are actually functions that wants to look for the join on router, two, whatever the query is for that router. So this is the basic idea is see that that compiles is I can say here locally. And ideally, it would be on the thing itself, but we're playing with functions for right now. So let's just do this to where now I can say,

give me the query for route and it says, Oh, well, you want router and then there's some query for UI router? Well, that's currently nothing. All right, well, then we can walk up a layer and say, Oh, alright, well, UI router, oh, it needs to know what the active pages and it also needs to know what the people page wants, but the people page should just tell us what it wants. So we'll just do this. The same kind of trick is we'll say up what we know we want locally, and then because we're rendering the people page, well, we also need whatever it wants. Walk that up, out the people page and I'm just looking The structure and hair needs person list and person form. And those same thing. Those are going to be joined to other things that have their own localized concern of this as my, the data that I need. let's not let's save that, let that compile and then go.

Strange

guesses. There's more than one error here now. Because we defined the function UI root, which relies on a bunch of other things compiling here, so let's comment that out for a moment and see what else we got going on. Oh, yeah, this is change UI router. That would be better. Tell me line number that's broken, I should have just looked at line number. And then this is changing the query for the people page to use the queries for these pages. That should compile now. And then we should be able to say, All right, now what do we see as the query for UI root, right, that's starting to match what we did down here. Now in the last video, I realized I actually made this one level deeper than it needed to be, I really didn't need that extra root edge in the database, this could have just been, let's place the router itself at the root, and then our root component instead of this could just be our data tree that we pass here.

And then if we reload, that we shouldn't have broken, let's make sure we didn't break the tree we didn't. Okay. So let's just continue with this exercise. I know it's a little tedious. So fast forward, if you if you don't want to watch me, type it all. But here, same exercise UI person form. And this was just some

I'm going to drop the address example. For now there's no reason going that far, we see we see how things are going.

And here, you'll see we didn't go all the way down, we should have made a UI person here.

And that's basically just this function. But now he knows we don't really need the index anymore, because we've got the person's ID. So actually, we can use their ID as the index, or as the key. And that should be fine. It's no, we should be able to just map over UI person, for people. And now we can come back to doing our notice I'm using query instead of get query here. And that's because of gate query requires the thing you get queries from to actually be a real focal component. And we're playing. And so I'm cheating a little bit, there's an internal function here that you don't normally use, because it doesn't handle dynamic queries properly. This literally gets the static query off of folker options on the thing you aim it at. So I'm able to to get this to do what I want, even though I'm not really writing proper focal components. Now UI person list should be person. And so now you can see I've basically got component local concerns. Right, what do I want? I want an ID and a first name. Now note, I don't know whose ID and first name, right I'm not. It's not I can't magically predict which person And ends up in this particular rendering, the parent has to determine that this parent happened to query for an edge called people will which people? Well, people that got composed in some other way, right whatever's in the database of the people that we get there. But how do I know how to get to those? Well, because right, when I went from the people page, the people page said, Well, okay, the person list, right, these prompts are all coming from root essentially. So they get down here and ask, okay, what's the query for root now I should have this is fairly complicated. router goes to active page, people page, router goes to active page and people page, people page has a person list with people with person ID and first name. And then we also have person form with ID and first name, and we dropped the address part. Right, so those queries match now. So I should be able to just say, what is the query for my UI? And I'll turn that into a tree for you. Right, so there's simplification. Number one, you see, it still works, that I should just co locate my query. Now, this has a couple of benefits. I mean, you might just say, Well, you know, all you've really done is taken the, the shape of data that you had to build to match the tree. Just true. And you had to hand normalize it, then, you know, break the tree apart into this nasty, it's not nasty, it's a really nice format. But it's a little bit of a hassle, the canned format that just so that you could turn it back into a tree to feed to the UI. But but but you don't want to feed all of it to the UI, because that could be a huge over query. And so we want the individual components to have this local query where that query is a function. And it turns out that you can dynamically change that at run time, which we've not shown, you know, I'm not going to show you how that's implemented. It's quite, quite a bit of work. But But the idea is, I want the components themselves to be able to decide what they want. But again, it all seems like kind of boilerplate overhead, why am I doing this? So let's talk about the next step. And the next step will to next steps. The first one is, is what I just said, like being able to dynamically change this query to feed the UI based on current needs. Have the animation frame that's currently showing that's that's one being able to dynamically morph this query. But the other one server communication, because think about it, most of the data that I'm showing in this handwritten database won't be here, from the beginning, I won't have the two people, they're stored in a server somewhere. I won't have anybody in this form. I haven't selected anybody yet. So the idea that my database on the first frame after load is going to have the stuff in it is just wrong. That's just not true. So let's talk about, first of all, getting past this, this idea of I've got to hand code, this database, kind of ever, right? I don't really want to have to do that.

And so there are two pieces I need to know, in order to be able to automate this kind of thing. One, which parts of this database should be here on the very first frame of animation, when you first load this application, what what are this? What parts of this data Do I need to be there from the beginning? And this infoq row is known as initial state. Now, this is a little confusing for people, they look at it, and they think, oh, you must mean this is a constructor, or this has has to do with component local state. And in fact, neither is true. This thing is literally, what do I want to be here?

When the application first starts, so I could say, Oh, well, I want router to be 42. Well, no, that's not what I want. But notice, we have the same sort of potential compositional power, what I need is the initial state from UI router. And then there's a parameter option here, we can pass parameters to the child here. So then this guy, same sort of thing, I can just mirror this down. And the initial state I need for this function to function at the very first frame of animation is I need to know which page I'm on. So let's say the active page is going to be the homepage which we've not even coded yet, but let's put one in here.

Alright, I noticed and I can say, Oh, well the people page is that guy, and home page is our wrong place to view the query. People pages, that guy, and the homepage is going to be something called UI homepage. And now we can make our function

message of the day. Maybe that's what it wants to render. And so it's gonna have

then, of course, we need the same sort of extra data to go with this guy, and his query his message of the day. And his initial state his message of the day, hello, world. That was what I'm building here, I'm just going to continue down this this route,

is a tree.

And you should be thinking yourself the Tony, you don't want a tree what you want. And actually, the person list is going to be empty to start and the person forms not going to be there to start. So that's the actual initial state of the application. I just stopped there. Right? There is no initial state for a person, I don't have a person in memory yet. And there is no list of people. I don't have people yet. So my initial state stops right there. But it stops right there. Because that's all I need for the first frame. So if I come up here and ask now, what is my applications? intended? And I forgot to rename one of these guys. Is that line 69? Yep, yeah, my URL page.

If I were to ask what I'd want for this guy, active page home, I must have forgotten to compose something in

back to page homes all are coded into initial state. So page home, but then the home page.

Let's stop there, this is going to get a bit tedious. Think you get the basic idea that I can build up an initial tree of data. And, and an actual query that could be used in combination? Almost, to both deal with my rendering to figure out what I want to render in my render loop. Right? What query does the UI currently want me to use to generate the tree of data that I feed to the UI. And then via the same sort of mechanism, I can build up a tree of initial data, that in reality, right, for this particular case, the person form wouldn't be here on initial and the person list would have an empty list of people. And the person table wouldn't even have data like that's, that's the actual initial state that I'm looking for. And so if I reload this, you'll see you know, while there are no people it's first name and and, you know, I didn't actually use the initial state from the tree because I don't have a way yet to normalize a tree of data into this form, but you saw me hand normalize this in last video. You saw that it is just a mechanical process. However, I have to choose a table name, where I want to put the thing. And an ID under which I want to put it. In de Tomic terminology, this is known as a lookup ref, right, it's a pair of kind of the unique identity sort of keyword combined with value that's unique within the database, right? It gets you to some place for historical purposes. This this came from on next originally, and the term that was chosen then by David Nolan was ident, which is a good enough term as well. And that is just sort of stuck throughout the history of Velcro, since it evolved to kind of out of on next and into kind of its own thing. But this, this format of normalization, is actually the original on on next format for normalization. And so we've just kept the terminology. Okay, so this is the final important piece in full grows, list of things that needs to know, for a given component that needs to be normalized. Now the route Well, we can co locate that with the database itself. As you saw a moment ago, when I when I fixed this edge to just be again, just have a top level sort of root key that doesn't stand for a table, it's actually, you know, a pointer to the next thing in the in the graph. And so what we chose to do early on, very early on very, very early on, is co locate this root node with the root of the actual database application database. So this guy doesn't have any sort of way of being being told where it goes in a table, because it doesn't go into table. It's, it's the root. Now as soon as you walk down to something like the UI router, well, now you've got to if you've got a tree of data that includes the router in it, right, so I sort of got here I've got two choices of where to put data that goes with that, I can put it in a constant location. In other words, the router becomes a single tenant, my database is only has one location, or in the case of a person, I can choose to place that in the table, for example, under person ID, the key. So, terminologies, ident. And this is exactly the key that we put in the full group options. And this is a function that receives two arguments, I believe in reality, and must return

a to vector that says where data associated, for example, initial state goes in the database.

Now something else magical happens when you realize that this is a thing you can do. Well, hopefully you already see the first and I've sort of really just set it right as it is now that I can pull an arbitrary initial map, like tree must add up somehow, yeah, tree of data. Where I get to think locally, right, I get to think about this component renders that component, it's going to call that component this key. Therefore, I can query for that key and say I need whatever that guy needs. I can say I go in the database. So sorry, that's on the wrong thing. That's that goes on this guy.

So I've got the initial tree, I've got the query. And now with this one additional concept, the ident I know where to put the data in the tree into a normalized form. Right, so So now I'm going through and and saying, All right, well, homepage, that's another it's just the homepage component, right? There's not there's not any, any place else to put it, except one place. Same thing with with this guy, this is just a people page.

So on and so forth.

Now here's the other piece of magic is when I get to something that's represented by a dynamic piece. of data one that actually has an identity, then my identity function truly can be a function of props, where I can say, Oh, well, the person that's going to be in the map there is going to have an ID key. And therefore, the place that I want to put that in the database is in the person ID table. At iD iD. Now get I can local about locally reason about that, at some point in time, you're going to grab a maps can come from somewhere could come from the internet, could come from local generated data could come from initial state. And in that state, there's going to be an ID. And I can use that ID to place this, this person's map of data in state and this composes. Now in the interest of seeing things work a little better, right, I've been playing with just playing functions here. And there are a couple more complications, I want to kind of do two things here simultaneously. One, I want to switch us over to using actual folcroft. So we can see some of the stuff in in better action. But in doing so, I also want to show you some of the things that have to be done to get full grow to work. Maybe why you know why some of those pieces are the way they're.

So before we switch, let's talk about what it takes to make a react component. You can make a react component out of pure functions with hooks, right? That is the the modern way to do it. And focus supports this. Or you can do a class based thing, which is more the classic early react, in fact, what vocal versions, one, two, and maybe even early three, React was still very component based. And somewhere in the three versions, react, came up with the new fiber rendering module kind of stuff. And also added hooks. And hooks are pretty cool hooks actually give us some some nifty things. And I need to actually beef up the book some with respect to them, because there's some really nice synergies that happen there. But my main point, is that when I go to render, in this case, you know, this react Dom render of an element with a mount point. I'm going to pass back an element and that element has to be created by a factory. And I think we saw this.

Well, no, we didn't, because we haven't actually had to do it. That's right, because we haven't made it nothing in our system is it actually

is actually using react props. That's that's what I'm trying to say. Right? So what we did here is we called a function, we passed a closure script data. This is an immutable data structure that came from closure script processing, to a function that then returned, whatever UI router returned, well, UI router returned some of these factory things, right. So these are actual react isms. And we've already seen, these are already, you know, macro based, or functional based, depending on what context you use them in. Things that figure out how to deal with the fact that underneath the stuff that's being passed around as JavaScript, you remember that from I think, the very first video, React is a JavaScript library, it expects JavaScript data. So since we want to react in a true ecosystem, React ecosystem way these individual things that I've been writing as pure functions aren't the thing that act as react elements for use in react. So for example, if I wanted to use the React hook use state. Inside of here, I couldn't, because this isn't actually a component. This is just a pure function that hasn't been given a factory. Right? So when you look at the plain react docs, and this is a little obfuscated by the fact that that most people use JSX. We need to find this function. Example, as what what is a pure function and use some things in it. When you go to render that in JSX? you render it with? No, I was hoping that would just show an example like so we'll start to look at him. yada yada yada, right to find a funk. An example. Example many states, right the shareholdings making them but they're not showing you using them yet.

Well, essentially use them as if they're JSX components and JSX automatically wraps them with factory, an element factory. In other words, it calls create element on them. Right. So technically, what we should be doing to render something in react as an actual participant in the React ecosystem, is we should be calling create element on it. So if I come down here to to this guy, and let's just make a

right and this see no, I believe in standard hooks. I think props, props are passed as an RA, as the argument is react so little, that it's kind of funny. That's the component class. Yeah, examples of functional props.

Now, if I were to, let's just get rid of the tree thing and just say, Alright, on the next frame, we're gonna ignore this mess. And we're gonna ignore this mess. And we're just going to call render, on create element, of example. And create element takes options, right, the JavaScript map of props, and then the children, we're just going to pass no children, right. So we want to render example, this is what JSX would do. And we'd have to pass the props as Gs. So I could say, you know, my name is Tony. And let's get that down this render. And then in here. Yeah, that's probably though. These are just like Google closure. functions.

Alright. That's the actual integration with react, that that has to happen. Underneath in order for this thing to now be a proper react component, well, this isn't very convenient. You've got props that are in JavaScript, where I can't do proper destructuring here, because that's a JavaScript object. So then I've got to do what, let around this and say, Oh, well convert j, s to CL, J for props. And yeah, I want to keyword eyes. The thing etc, right? That's kind of a mess. The other thing that I've got to deal with is this, the stuff I was talking about up here, setting this on one of these components, I could still do that. But you can see this is kind of a mess of, of all sorts of fun things that you don't want to have to hand code. This, for example, because dot dash notation, depending on which annotation you use here, depends on whether or not this thing will get renamed at an advanced compile time, for compression purposes by Google closure for its renaming samsa to make the source code smaller. So there's just all sorts of things you can easily screw up, get wrong, make nonperformance, etc. And so this is what the FSC macro is about the FSC macro, is at its core, a macro that keeps you from having to handwrite all this crap, and reduces the amount of boilerplate and does a bit of error checking for you. So, yeah, so just kind of remember that you're in a j. s library, and that GS library, when you're not using JSX. Right is at a JavaScript level. Fairly inconvenient to use within our app. It's not not impossible by any means. But it's also not just not optimal. Okay, so let's fix this up. So I'm going to go in here. I'm going to grab I've already got it. def SC going to grab an application

And all the folk rap, really, I mean, there's a there's a bit in here, folk rap manages, you know, transaction processing interaction with remotes, it does handle the rendering loop. That really isn't a loop. It's more transactional based. So it's not doing the same kind of silly request to frame every 16 milliseconds sort of thing that that our little fake demo here was doing. Fake demo, but demo was doing. It keeps track of the app state, there's an atom inside of here that has this stuff in it. And of course, it does these these kind of startup steps. which you'll see here. Now, as I go through this, when I make a def SC of now I'm going to instead of pretending like these are just magical factories that have already been set up, right, which wasn't right. Right, all I have to do to transform this is pick up these pieces and plop them in to the right place. Now, this macro actually can make this lambda for me, if I just specify the vector, right, that's just a notational convenience. In terms of the ident, technically, this is supposed to be a function of two arguments that calculates the table to put that in, and the ID to use. From the props of some map that matches this guy's concept. For convenience, this can also be specified this way that says, here's the table, here's the key in the map, to get the thing out of the table. Well, that's kind of redundant. So there's also a shorthand notation that says, generate that first thing you saw me, right. But understand that I want to use the this to get the ID out of the map map. And it's also the table name I want to use for instances of this thing. And so this is the most common notation you'll see used for ident on these things, when it when the ID comes from the properties. So we can just continue down this, the person list has some people. And its options include a query and an ident. Now, remember, the shorthand we just gave said, you can give it a function. And in this case, that's going to be a constant, we do need to give it a function because we don't want it to generate one per, you know, based on the map.

And so now notice, I'm just replacing, pull the query from that thing. And so I've essentially, now there is one additional thing here is for this to be a proper react ecosystem thing, something's got a call create element on this thing, and convert the JavaScript stuff back and forth, and the closure script stuff back and forth. And so that's what this does is this basically creates a function that can call create element for you to do the right thing. And this guy has an additional helper.

Since you're creating these, each one you create, if it's in a list, for example, needs a unique key. And because we know the data on this thing has a unique ID. We could tell this factory does this go ahead when you call create element on that. Here's the element type you're creating. And by the way, here's the element key to automatically put on the instances just look up the data and use that as the unique identifier of the element on screen, the key.

This one doesn't need a key function because it's a single thing. Somewhere down here. Actually, this one looks very much like person.

One already Had the weather database, one that I was playing with earlier that again, this can be now simplified. Because the macro can just write these. Well, can't simplify that one. The other thing that I made for these, it's funny when you do these, because I made it so that this boilerplate up here of saying what the current class or instances and saying what the props are, we have to repeat that here. Why not just be able to say what you mean to say. So one additional thing you can do, if you do say this is a function is you can use the D structuring.

Oh, sorry, already. The structuring of this to stand in for passing the props yourself. So, this isn't technically a lambda, it's sort of a funky, domain specific language kind of thing. That usually takes one of two patterns. Either you write it as a as a argument list lambda and use a constant or you typically use the ID of the thing as its table name. And this just sort of evolved over time as the kind of the emergent pattern that we ended up using for this.

I had already done that one.

Okay, so, we've successfully refactor that now you see the query, go in and make ourselves a little comment block here. And we just look at.

Well wish to do it this way.

We see that our database and the photo app is basically generated normalized. We've got the top level key router that points to component ID router, component ID router has active page home, which came from initial state and points to a home page and a people page, which themselves are components. The person list is empty, the message of the day is HelloWorld. So I know that was a lot of gory detail to get to this particular step. But I think it's really important for you to understand that several things will fall out of this and are required by this. And it's just a little side note to notational convenience, this def SC macro also takes some of the the boilerplate out of this as well, it understands that you have to call get initial state whenever a join us followed. So if you're trying to initialize people page, you're most likely going to ask people page what its state is. And so if you specify a lambda, you have to explicitly give it exactly what you want here. So if you wanted people to page to be completely empty props, you could do that. But if you'd rather just have the macro generate this lambda for you, you can raise this out of the macro or out of the function. And then you can raise the parameters for get initial state up to the top level. And now this is a lot more compact, that means exactly the same thing as what we saw just a second ago. So here, message of the day isn't through a join, I can join I can raise that without a problem. initial state here person list is empty. This actually works. If I were to do this, that would be Give me two completely empty people. But that would say go and call get initial state on person twice. And so I could say like, Id one name Bob and Id To name Sally and then appear in the person that that what I've composed there, so hold on a second person list. Oh, sorry, person list isn't that sorry, person list does have initial state and I had it wrong here

should be those person list has an initial state. It's a people, and the list of people is empty. Here we go. So if I see with a lambda, I'm actually gonna, there won't be a here, let me just do that. Let me load that up. And it's broken. On a break.

router goes to the router, component view router has an active page homepage deals and people pages nil. So it did not follow. I probably forgot to read that out of the lambda. didn't I? Miss the day? That one I definitely forgot people page goes to a person list. But did I do the homepage the same way? On page I raised about here. Oh, no, that's okay.

router gets the initial state of router.

likely cause of this is either I'm using mesh the problem. I'm still using the factory, have the silliness. Problem with porting these things over when you've done that play via plane functions. You miss things. And the reason I'm reloading the browser tab here is initial state is just that is the first frame of the app, it's the initial database that we get. So now you see that this got me on a personalist. But personalist is just this empty map, it's not actually pointing at a component of any use. So I have to be kind of careful if I use the magical notation that if I want this to go grab the state of the person list component, that I have to get it out of that lambda, so that the macro knows to do magic on it. And so now the person list has initial state, which is an empty list of people. And if I reload the app to reinitialize, the initial state of the application, I'll see that the people page, point, so person list, which is its own component, and component person list has a list of empty people. Now the thing that I was going to do here is what if we say all right, the initial page isn't homepage, let's go ahead and put the this on. See now as the router has people, what's put the router on people page to begin with now those the UI is not going to change here, it's going to recompile. But I'm not reinitialize the application. So this initial state only counts then. So say we start out on the people page. And I want to go back to having a demonstration of the person list having some people in it. So this is what I started to type a moment ago. So I want to give an ID one and a name, Tony, and Id two and a name Emily. Okay, but notice these this isn't the person ID and this isn't a person first name. Those are just parameters. Because remember, the real thing that's being generated here is get initial state of a person using those parameters. That's what's actually being generated here when I do not put that on a lambda. So up here, I can add an initial state that says Well, if you do call me go ahead and make something that has a person ID with whatever puram id Is and a person first name with whatever the parameter name is. Now, this is a notation for now the function gets the, the class itself, which is usually useless. Right? So you could do this, and then this, and this, that's the lambda that the other notation actually generates. So now if I reload this page, I should start on the people page with two people. And let's look at what happened in my database here. I got people with no anything, I got nil and nil and nil. So that means my parameters. ID name should be the proper parameters for the initial state on person. Maybe I dropped this in full crud, 3x. It's entirely possible. Yeah, that was it. Yeah, that parameter was kind of useless. But I so rarely write these as lambdas anymore that I just didn't remember. Because the shorthand notation for this is to say puram, ID, brand name, and then not write the lambda. So now I should be able to reload this. And I've got an initial frame that has exactly what I wanted. Okay, so now the magic starts. He came all this way with me. Here's where it gets interesting. Our UI, yes, it's a reified tree from root all the way through the entire UI. And right now, my query, when I do my app, root query to render the props is actually getting everything a person form the addresses the home page, right, I'm not rendering the home page right now. But the query currently includes it.

Typically, the UI router kind of concern takes care of this. And you can manually do this, but foco comes with two different pre written macros, that will write the router for you because you've got to deal with either a dynamic query, which is a little bit of work, or what's called a union query, to fix this overcrowding problem. So folker, like I said, has to pre written things for you could manage this yourself if you wanted to manage the query yourself, but you do it so often, that it's just something I supply. Now, the interesting thing is that initial state as a tree, well, that's exactly the sort of thing that you'd want to interact with a server with, right? You'd want to ask a server, hey, server, give me a list of people. And you might do that with some query where you say, Oh, I don't know, people. And then what do you want to know about the people? Well, maybe you want to know their ID, and their first name and their age, and their primary address. And then the addresses Street and city? Right, that's, that's the sort of thing that you want to say to a server where this key is just some graph key that you invent, for the server to respond to that can give you a list of people that you're interested in, sort of. So for example, give me my friends. Right? And these are the details that I want to know about my friends, or give me my enemies or give me my favorite celebrities, whatever, right? So there's some people that I'd like to get. And what the server is going to give you back is a map of data that says, Oh, well, the people that I found are, and then a list of people that have person ID one person, first name, Bob, person, age, 22, person primary address. Now, of course, in our current app, we don't have all this extra sub sub component stuff. But this is essentially the kind of thing that we're going to get from a server.

Now, this looks just like a query fragment from our UI. And this looks just like a fragment of initial state. And so this colocation of query and state can be used to do on things, like for example, let's say we want to load that from a server. And I'm going to use the imagine that folker doesn't, Oops, wrong namespace. Let's suppose for a moment that folker doesn't have load integration, you wanted to just fetch some data from a server. And so falkor comes with merge component, we can give it the app. And you can tell it, which component matches the shape of the thing you've got? Well, I think up here, we had a component called person list that has a people field, and then a subgroup of of those persons. So there's the queries, this query and ident combination on the person tells us how to normalize it. So this merge routine is really just doing exactly what the initial state is doing. It's saying, alright, well, if you give me a tree that matches the query, component is person list. And the tree of data is that data. Then if I asked that to merge that data, I see Bob, Sam and Barbara, suddenly appear in my UI. Right, so my manipulation of UI is really just manipulations of these trees. And now my components have all the information necessary to make that possible. Now, what if my list of people didn't match a given component, this is very common with loads. If you look at the load API, the load API looks like more like something like this, give me my friends, which happened to be people, right, it's a person, each, each one of these friends is going to be a person. But the target edge in the graph that I'd like to hit, or I'd like to place those down is the component with ID, person list. And it has a people field. Right, these are never more than three long, because everything in your database is in a table with an ID, and has top level fields. If it isn't a top level field, it's probably another normalized component that itself is in some table, somewhere in your database. So this is just like this, except for the fact that here we went one level higher and use the well known field in our application to merge the data. And here we're saying, well, there's some server side key, that stands for the edge we want to pull that doesn't match anything that's actually here locally, I'm application, but my application doesn't know what elements of those things that wants to get. So if this is a too many key, this is the this is the target, you know, of the many side. And if this is a to one key, like you know, me, it's still a person, right. So this can be a too many or a two to one edge. And then this targeting mechanism of load lets you essentially rewrite this edge, which looks like a top level sort of Route, like edge in the graph to some other place. And remember, if you look at our regular app state here, component, person list component person list, there's that edge, I want to fill this in with normalized data. And if you look at again, go and look at the current app state, the current app state I've rewritten persons one, two, and three, and that rewrote this to the normalized to many edge. So even though this tree had three maps, and that merge component, and load as well, these two are the ways of pulling a tree into your database, and normalizing. So that's the basic idea of part three, how do we stuffed data into our UI? Without choking on it? The answer is we tell the components how to at each level, deal with the data that they're interested in in terms of asking for it, initializing if there's something to initialize at the very beginning load of the application, right where we said don't give me the initial state.

And then an ident function. And this is of particular importance. This is how new data novelty can come in, in a tree form, whether it be initial state, or data that we invent on the fly, or data that comes from a server. This is the mechanism whereby that data can be properly normalized into this database, so that there really isn't much hand manipulation of Have this sort of format needed. Of course, you know, I can put like active page people in here, this is a particular thing that I might want to twiddle change the routers active page to homepage, or the people page or something like that. And we do that through mutations, which we'll talk about later. But this, this really is how folker was built. And these macros are really doing not much more than some notational convenience, and react adaptation. So that you can work in closure data structures, you can have your query co located, your item function co located and optionally, your initial state co located so that everything just composes and can be moved around and re composed at will with only local reasoning. So I'm glad you hung through me if you made it to the end of this video on with me through part three. And, you know, in the in the upcoming parts, we'll talk about additional implications and further aspects of these elements of fulcrum

