In this video, I'm going to cover how rendering works in fulcrum. focal leverages all of the mechanisms that react provides for optimizing the rendering of an application as efficiently as possible. Now there's an extra layer, full Crow's adding, of course, and that's the, that's the data management layer. So there is an overhead with running a query. So you know, the aspects, I guess we can write them down real quick in the, in the UI over here, just as the query has some overhead, then of course, there's the output of the factory's which is essentially your virtual DOM nodes. And then react is going to do some, you know, Dom diffing. Now, React defines a number of places where optimization can happen here, as does full CRO. So the places where we can make things faster is we can reduce the amount of query we need to run. In terms of the factories, we can reduce the number that need to run period.

And then as far as the React Dom diff goes, we can do things like specifying stable keys. And such and these, these are just like the React low level, things you can do to make react understand the virtual Dom better so that it does a quicker job of the diff. So we're going to go through kind of how foco does the rendering story and to. To see that I'm, I've placed console logs in each of the classes to show when it renders, and which one renders if it can render more than one. So render car render person, render the list of people and render the route. Of course, we're making the app. And here I've substituted the optimized render algorithm out for keyframe render. So keyframe, Render and folk row always runs the entire query like it's the least efficient option, it runs the entire query, and then renders the entire application from root. So it passes the root props to the root component. And everything's supposed to render from there. And so you can see if I, if I delete something, save this, I get a hot code reloading a hot code reload always forces a full rerender of the application. So you can kind of ignore anytime you see shadow, shadows, compile symbol pop up, and then a list of everything rendering. That's a built in feature. So hot code, reload, always re renders everything. So you can see hot code changes, even if data hasn't changed. As far as the UI goes, so we're gonna ignore that for the moment. I've added back in our make older mutation, you give it a person ID, and it goes into the app database finds that person IDs table entry, and increments their age. So if I go down here and run this particular, I'll clear the console just to make it a little clearer what's going on. If I run this mutation, you see that with the keyframe, render, I'm rendering route, I then render the list and then person one renders, you see that person two did not render, nor did any of the six cars that are in the display. The reason for this is reacts, you should component update. Now, raw react, it doesn't define a should component update, because it doesn't understand how you're how you're doing your your data, although you can extend the pure component class in react, and it defaults to just checking to see if the things are equal. Fortunately, we've got immutable data structures. And so from an efficiency standpoint, should component update can be super super fast, because most of the components will receive only the same value of data. The data is immutable, they'll receive the exact reference to the exact map of props they got last time if if those props haven't changed, mean that when we have should component update, check in closure script. It takes nanoseconds, it's very, very fast. But I'm going to do here is I'm going to go through and show you that if you were to, to have just like the raw react behavior, where it just says, yep, that should update that we're going to get quite a bit of over rendering here now. So we'll always get that on hot code reload while we see that one happen. But now if I run this mutation, again, you'll see that not only does the component that whose data changed rerender, everything re renders. And so here are the only optimizations you were getting at all is react ability to then diff the DOM and the V DOM and only update the real DOM nodes that have changed. So it's still relatively fast. It's just not as fast as it can be. So so that's optimization. layer one we'll call that is this should component update is defined for the components. So that So that as we work

and we modify something, you know, deep in the deep in the tree, we get the minimal update for the render we've chosen. Now, keyframe render is not the default, optimized render, you can override the optimized render. In fact, you can override the entire rendering system of afoco. And put whatever you want, if you only use pre preact, or, you know, whatever v Dom diffing thing or if you have your own custom way of getting this data from, you know, folk rows internals on to a screen of some sort native, whatever you can, you can override these functions plug in what you want for doing the rendering, it's just we provide By default, the React bindings. Now, in order to make this even faster, what we said a minute ago, the two additional things we can do, well, would it be nice to skip route and list nothing, nothing changed in these two components, we had to go through them because we query for the entire tree. And the only way to pick the tree apart is to pass it to root and let root pick out the thing that list needs and then list pick out the thing that person needs. And then we're relying on should component update to keep the the extra work at bay. But we'd like to avoid these two things. And there's a way we can do that. Because folker defines data model. And this same little, little bitty bit of data that we've given each of these components gives us a whole bunch of power. So we haven't even gotten to the full stack story here. But let's talk about what additional power, these declarations have given us all of a sudden, folco knows, or can derive very easily, that this person component queries for these attributes, and nothing else. It is formally declared that this is the only data that I rely on. And and render. It's also declared where in the database its data is, Well, again, this is immutable data, it's very quick to compare. So there's a number of things we can do with this information. So the first thing we can do is when these component instances mount, we can index them. And we actually do that in folco with with some hacks on the component lifecycle. So component did mount component will unmount, do some extra work to keep track of the things that are on screen. And that's a nice constant overhead, because they get mounted, they might stay on the screen, move around, whatever, then they get unmounted. Those are fairly rare events compared to the amount of updating you do in the DOM. And so if we want to look for things in these indexes, we can look, for example, for all of the components on the app, that are rendering a person. And this gives me a list of these are actual instances of on screen react components. So we can go from a class to all we can go from a class to any if we just need like, any one of them, for whatever reason. We can also go from a prop to the classes that query for that prop. And so this is a nice way of, of being able to in them in the data model, think about the data model. In this make older, the thing that I changed was a person's age. And so if I knew what components were querying for person age, I'd have kind of an upper bound of the components. Right, and here tells me it's the person who knows this is a keyword. This index keeps track of the classes by keyword, which helps with hot code reload. In the indexing, the indexing tries, not the story actual classes, because the classes can change on hot code reload. So if I know that person age changed, I can derive an upper bound for the things that need to be refreshed, I need to refresh all of the things that have class person in this particular namespace. And as you saw a second ago, I can find all of the instances with this guy. So I've already written this, so I didn't have to take up time in the video, I can write a function. Let's just leave it there.

join these comment blocks. And actually, let's just put this out here. It's a function. So I can write a function that given a prop would tell me all of the instances on screen that that render that Prop, right and so I can do that. Here, I could say tell me all the instances on screen that are rendering age. And it tells me there are two things and that makes sense. There are two things on screen there rendering age And then I could map over those component instances, and I could ask for their items. So now I know not only which on screen components are potentially in need of refresh, I know where they are in the database, I know that one of them is rendering person ID one, and the other ones rendering person 92. So I'm getting closer to, to the point of being able to, to narrow this down to what might be interesting to refresh. Now, there's an additional fact that I can use, I've got that list of items in this case. But I also have the current state oops, that app current state. If you think about this, as I make someone older, right, so let's, let's call this

for her, make someone older. And after.

Right, I can actually look at these two, I can capture them. And since this is structural sharing, this capture is really, really efficient, I can capture the entire state of the app. But the overhead on that is, is very, very small, it's it's approximately the size of the data changed. It's very slightly larger, because there's a little bit of overhead and recreating the, the tree for the new instance, of the structural shared, nested state map. But now, if I were to know, all of the idents, person one, person two, and I've got a before and an after, I can easily see that, oh, the age that actually changed was only on person, one person to nothing changed, still age 20. And because of immutability, this map in the before is exactly this map and the after, which means checking to see if they're equal is a reference compare. It's comparing two Long's, which takes nanoseconds. So the built in default, optimized render is called the ident, optimized render. And it's if you go and look in here, there's a, here's the actual algorithm. And then you see it has to do a decent amount of work, because there are some some corner cases that need to be covered for this to work well. So if you, if you don't define a render, then it does these tricks I've just shown you, it can look things up in indexes, to figure out exactly what on screen needs to be updated. And then I'm going to show you just a little bit more so I can get the identity. And then once I have an identity, let's say person ID one, I can get the query from the person class, I can get the current state, I can get a starting entity, let's just get in on the state of person ID one. And then I can run this function DB to tree to get just the props for that sub tree. Okay, so let's see what this looks like if I reload so that I've got this new optimized render, you see the first initial render renders everything that's an hour down here near the bottom. And so then if I go back to my mutation, and run it, you can see that only person one renders route didn't render listed render, and the sub cars didn't render. Now, I didn't authorize render currently doesn't optimize out the sub tree part of the query, the query actually runs very, very fast, typically in the neighborhood of a millisecond, or less. So so it's kind of a premature optimization to add a bit more narrowing to the, to the query optimization. But this is this is essentially how the ident optimized render works. It uses the indexes, and a before and after snapshot, if you go and look at the actual ident optimized render, what do we call it, it actually saves the prior state of the application on or what the variables called on want to search for video, it actually see does this exact thing, it saves the before and after and then the next the next time through, it can compare the priors before you throw the before before away, etc. So it can figure out which things have changed. The caveat is it also asked to look in the root node to see if any root things have changed, there's a bit more more dirty checking. It has to do and they can find exactly what components update and then it can use this optimization to pull just the query. And then fogo has an additional optimization that sort of built into the def SC components where it can target props directly to and tunnel them directly to an on screen component without having to go through the route and that's why you see route and list Able to be skipped here. So those are the basics of how it works. Now, there are some caveats. And there's some other reasons why I explained these things. So the fact that we have these indexes, this one in particular, right, I can find all of the answering screen components that look for a particular attribute is there are times when something changing is of interest to other components. And this is an optimized render won't detect that a refresh is necessary. So let's do an example of that. So the ident, optimize render is only going to refresh the things on screen that it can detect have changed. Well, what if we decide we want let's go and move this make older transaction up to weigh the person component and actually have the person component able to?

Here we can actually use this instead of the app. And let's just quote that. Unquote, that and then we don't have to move mutation around on let's give it a label. Okay, so let's say we're clicking through and let's say once somebody reaches 30, we want to make the background color or something of this, of this segment yellow. Right, so So the idea here? Oh, wait, no, no, no, that's not what I want to do. That wouldn't that wouldn't give me the problems that I'm looking for. In the list, what I'm trying to do is I'm trying to show a header.

And what I like to do is in this in this outer segment,

I want to show how many people a count of how many people are over 30. And if you think about that, that's really not difficult to do at all, we can just compute that right here, we don't have to make that part of our state. Because we're not going to show big long lists of people, generally, you would want to paginate things. So in this particular case, it totally makes sense that I might want to derive this information just right here in place. And so this is this is a fairly straightforward thing to do. My my count is going to be the people thread people, we can do it a couple of ways. Let's just do it with a reduce, that's easy. And we'll start this at zero, and our count our person we'll have an age coming in. So we're going to walk over the people, we're going to look at their age. And if they're well over 30, if age is greater than 30, then we're going to increment See, and otherwise we're going to leave clo to that should give us a count of people over 30. And we get back the right number. Okay, now here's the problem. If I didn't optimize render, shrink this out of the way, is re rendering adjust person to well, as soon as we reach 31, this number up here should have gone to two. But the list information didn't change. So I didn't optimize render won't detect that people needs to be re rendered. So you've got two choices. The easy, super easy choice is to switch to using keyframe render, and just say, you know what we can query for the whole thing and should component update will be fast enough. And we won't have to worry about derived data in the UI. perfectly valid option. And in fact, that's why optimized one of the reasons why optimized render is configurable, that might be the thing you'd like to do in full chrome two, and in three, you can also indicate which data you consider to be stale with respect to App state. So you sort of give it an explicit hint as to if something queries for this particular thing. Then you might Want to tell that particular thing to rerender. And so we can actually declare that in a number of ways. So one way of doing it is on the transaction itself. So on the transaction itself, we can include a second option. After the after the transaction, there's an options map that's allowed here. And one of the things we can include in the option map is a list of refresh. things, we could say refresh. And then we could literally give, and I'm going to make it obvious This is a vector nesting thing. So we give it a list of the explicit things that we'd like to be refreshed on the screen by their data model. Now remember that the indexes can be used to go and find the things on screen that are rendering person to there might be a forum for person to there might be a list item for person to write, we don't wanna have to think about what's on screen, what we want to think about is the data model. I want to refresh anything that's looking at person ID two that has that live ident. And in the similar vein, we want to we might want to specify this refresh that well, have we queried for, in this case, person list, this is we're derived data is have we queried for person list of people, right? Because if that list of people, since we're going to looking into it, any changes to the underlying data should be considered kind of a change to the person lists people attribute. And so we could list that here, person, list, people. And that will tell this transact that as it changes and so let's reload this so nobody's over 30. As it changes, you're seeing person rerender each time I click this button, even though it didn't necessarily need but now you see, the number one follows and the number two follows my transactions on the subcomponents. So this is the way you can declaratively say this particular transaction is not only affecting well this component in this particular case, it can be affecting some other component

