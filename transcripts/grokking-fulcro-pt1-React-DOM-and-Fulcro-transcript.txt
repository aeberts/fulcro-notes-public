Welcome to the grokking Fulcro video series. I'm doing this series as really, it has multiple purposes here, I'm one of those people who really likes to see how things work internally that I work with, I like to understand the primitives that I'm working with. And I find that that makes better software developers, just in general, when you're in the mode of just using something and not understanding it, you can get things done. But you often do things in very strange ways that that hurt you in the long run. And I also want to just kind of, I guess, another purpose is to dispel some of the myths around Velcro and how it works. And I just want to help the Velcro users do a better job of building their, their applications. So on that note, part one, I'm going to walk through a bit about the low level react. Integration with folders, full grow is a library that allows full stack web app development, but it's not too hard tied to react itself. I mean, React is the central library underneath that does the rendering for both native web electron like whatever deployment targets that react supports. But you can actually hook in custom rendering and allow folker to render through other things. But in this video, I really want to concentrate on the specific react integration, I want to give people a little better understanding of react, how it works, how using closure script, is a bit of a superpower compared to the regular raw react JS ecosystem. And so yeah, I just want to show how a number of those pieces work. So I started a project and I just did an NPM in it, basically, and made a package JSON, which then I added react and react Dom to. Now I prefer using the shadow clgs build tool, which essentially, I didn't mean to double click on that. No, thank you Xcode, which essentially just acts as an interface between NPM and the closure, main closure script compiler. So the closure script compiler is the thing that converts closure script, the language into JavaScript, the transparent, the transpiler. And shadow clgs, is a tool that adds some layers on top of that, to make it more seamlessly operate with NPM. And I actually will cover a little bit of what shadow is doing as well. So people can understand a little better what what, what they're doing when they configure it. So I've created a package, I've also created a shell clgs Eden, which I'm probably gonna have to show you over here. I think I'm in the wrong directory to do that. And so this one's really simple. I'm telling it to use depths for dependency management, which is a closure tool, depths, tools depths, and you can get that on Macs by doing a brew install closure. And there are packages for Linux. And you can get it in Windows as well with a little bit of work. Windows subsystem for Linux, of course, works pretty easily. And I've configured this to do a build for the browser, where I'm wanting it to output to the the subject Republic. I'll get to some more of these pieces here in a minute, I want to make a dev HTTP server on port 8000, that serves that directory. And then I'm asking it to create a network repple port right and connect to the browser and send closure script commands through the compiler to the live browser tab to run. And I want to put that on a specific port so I know where it's at. But basically, this just lets me say which closure script file to look for, for kind of the entry point of the application. And then shadow kind of figures everything else out from there. For me. The depths file is really pretty straightforward as well, I've got closure closure script. I've got full grown there so I can show you focus stuff. And then I've got shadow clgs as dependency. And I would typically make this a bit more separate and customized and to be a lot more in here, but this is sufficient. And then I've told it source main is the directory I'm gonna use in the project. And you saw that, you know, out here in the Finder, source main is the where I'm going to put source and then demos a package subdirectory. And then these are closure script files. But let's start with a really simple exploration. Let's look at this raw HTML file that I've made.

And all I've done here is I've used CD ends to pull in react development and react Dom development, just a straight script tags. I made a style class for red just to have one. I made a div and gave it an ID. So just really plain HTML stuff. And I'm just going to take her in JavaScript for a sec. So let's open this page. And let's open the developer tools. And so notice I've got nothing on the screen because there's really nothing there. And I'm just going to say var root equals document dot get element by D. app. And I'm just going to get that div that I had labeled. While you saw it in the terminal window here, that div I had labeled given an ID. Alright, so now if I look at root, I've got that, that div. Now react, has this concept of a virtual DOM, where it creates sort of a picture of what you want the DOM to look like. Then it reifies it in the real DOM. And then when you tell it to update, it goes and compares what it kept with what you want. So let's do a quick little fun thing, let's say react, Dom, dot render. So this is the one that understands how to render react things into a browser. And it takes an element Well, there's react itself, it has the Create element function, and create element takes the type of thing you want to do. So let's make a div the props that you want to pass, so let's pass john, not sorry, let's pass out map from class name to read, because we have that class name we could do. And then children, so I'm just gonna give it a string of Hello. And then render takes an element. And then it also takes where you want to put it. Oh, I forgot something. Missing a brand. It's funny. Play with.

Alright, I'm doing some stupid.

Oh, you're any JavaScript, Tony. Put some comments in there. Alright, so there's really children. And then container, containers route. There we go. So now Hello is on the screen. Now if I go and look, this is the interesting part. If I go and look at root, remember, that's my DOM element. Now it has react stuff on it.

And if we play for a second here, let's see now. React root container. Current, think? Current. Internal. Yep. And then there's, I think, a current node and here, right, I'm just walking through like, what react just attached. Right here. It went to the thing I told it to render on to ended attached. It's kind of copy of what it wanted to look like look at. So if I look at this current thing, it's it's a react fiber node. And it has a child. That is a div, which has

a div Oh, here we go. No moist props. Oh, I accidentally sent the wood No, that's right children is that it's easier sometimes to explore by clicking through here, current child

got the class read? Oh, I think it would end up. Let's rerender that it would end up doing this. A little more like what I expected if I made this list of children. Oops.

Alright, so we've got our div. Remember, ice props are pending props. Now, you get the idea. I thought we're going to be seeing something a little more than this. But I've forgotten It's been a while since I've wandered around the internals here. Oh, there it is. There's our text node. There's our text child fiber node. Okay, so I expected the hello to be in there. Okay, so you get the basic idea there. So if I go and I say you know what, I want to change the children to Hello there. React doesn't have to delete the node that was already there. And put a new one in there. It can look at this. Tree of stuff that was rendered last time figure out what the difference is or the string changed, and just change that one node, and then just update that one piece of the real DOM. Now, when you use JSX, and something like Webpack, which runs the JSX cross compiler, you can sort of embed this as as HTML in your JavaScript code or your JSX files. And essentially, this, this syntax in JSX, turns into this react create element. Call. So that's that's basically how that that cross compiling works. Okay, now, we could play with this in closure script and see, you know, see what that interrupt looks like. So I'm actually going to re import the project because I cleaned it out, so the tree would look clean there. And I'm going to import this depths file into intelligent with cursive installed. So I have the cursive plugin installed for doing closure. And to tell it's a project, and it's going to pull it in, figure out the dependencies. And I'm off and running. Now, there are a couple things I want to set up here. One, I need to run something like yarn to install my node modules. So now I've got node modules. And then I need to start shadow clgs, I'm going to start it in server mode. So that I've got something that can compile my closure script.

And I'm going to take us to this raw namespace. Now, Shadow starts up a web page for itself. So I can go in here and append this tab. And I can go to the builds and click into this build and click watch. And that'll start compiling my build. Now my shadow clgs configuration file, I've told it just to include the demo raw so far. And demo raw, you can see does nothing but define an empty namespace, really, I've not really given it much. Now the other thing I told shatto to do was start me a regular HTTP server on this port. And if I go here, it will do a nice thing. And I can go to the elements here. And I can see it loaded my index HTML file, which I have the same class in it. But I added this additional script load of the output of shadow clgs itself. So you can see in my console, when this page loaded, it said shadow clgs is ready. So set shadow clgs actually connects with a WebSocket. I don't have the log here. Let me reload this with this turned on. And I can tell it to show me the WebSocket things and you can see this connected to localhost 9630 via WebSockets. So I've got this live connection that that I can talk to the page with. Okay, so I'm going to go up here and add a configuration, I'm gonna say I need a remote repple for closure script. And that's an in repple. And it's on localhost. And I explicitly configured it to be on 9000. So it would just always be in the same place, and I'd be able to find it. And you can see it reported that here. Okay, so I'm gonna start with this repple. Now, this connects me to this running Java process. Right, that's the one with the network port. So I have to tell this Java process, which has a number of runtimes, right? I could be running five, five different compilers and five different applications in five different tabs. So it's got the idea of, Okay, I've got an app running on a browser, that's Chrome. And I can open up Safari, and I can say, localhost. 8000 index dot HTML, I guess I don't need to type that in. And this look, the same page. And now this will see I've got an app on Chrome and an app on safari. So I could connect to either of these browsers via the repple. I'm going to quit Safari, and you see it cleans it up there. So here, I have to say shadow. I'd like you to connect to the repple for app. And it tells me All right, you selected app. All right on this demo raw namespace, I could say define a function that takes a single variable and just returns it. Alright, that's silly. I'm going to save that over here. And if I look at the console, you'll see it just hot loaded this file, it just reloaded it via the WebSocket. So now I should be able to go the way shadow and closure script in generally sets this up as the same way Google closure with an S sets things up. This package becomes a dot separated object in the JavaScript land. So I'll have I'll find a demo object that has a raw object that has an f function in it. So demo, raw dot F, five is five. Okay, so that's straightforward. And notice this, you know, this just hot loads, I don't have to reload the browser. Let me say I want to increment. Why go over here? Wait for a dot load, should be able to find G. Six, that returned seven. Okay, great. Now, let's play with the interrupt and react here. So this raw namespace, I didn't load react, there is no react here, right? I can say react DOM. It's got react dev tools, which is, you know, a browser plugin. So that's why I'm finding some things. But if I try to recall this thing, right, it's like, yeah, you don't have react. So I'm going to say require, and I'm going to do it. Old school. Well, we first include clgs, GS react as CL, j, s, js, react, Dom, these in shadow, these are kind of legacy ones, even the stock closure script compiler doesn't recommend you use this anymore. But these were legacy ways of mapping non Google closure libraries into a format that closure script could understand. And shadowed,

does it automatically through integration. And these are sort of when you use the shadow actually makes a little stubs of them. And all it does is does its own thing, which is that you can just use require on a node NPM kind of dependency. And then it uses this gu export symbol to put the React global symbol back into where you expect it. So that sort of you got this legacy style support of there's a global without that, if I just say require, re react, let's just do that. First. If I just say require react, you'll see that shadow inject the reactive element library for me, it reloads the my raw clgs. But if I go looking for the core react stuff, it's still not there. Right? There's just, it's just nothing. And the reason is, it actually puts it under an internal node, like module node module, React index thing that that gets it out of the global namespace. So So shadow is trying to help you out here with with conflicts. But I'm doing it the old school way first, just to show you that, you know, this, this, this idea of what we were doing over here, right? We were saying, Let's define the function called render, that takes an element. And then in closure script, that would be render on j. s. Doc, wait, we need a route. So let's def route. We already know what that is that's get element by ID on j s document. app. Right, let me clear that. So it doesn't. So I'm just going to save that as a hot code reload, and then I'm going to show what the value of root is. And see it's that div element. So I didn't have to run it, I just said, hot code reload. And because it was a def at the top level, when that file loaded, it automatically evaluated now I've got a route. So I'm just gonna make a quick render function that can say what I did in the repple over here, right, I want to call react DOM, render. So j s, slash react Dom dot render. And I need to pass it the element and a route. Okay, so I've got a quick and easy way of rendering something exactly the way I would over there in the JavaScript Prop, just with closure script notation. I'm going to get rid of these functions. And so then I'm going to try that render. Let's put this in a comment. So I can explicitly try it. I'm gonna try that render, on js, react, create element. And create element, if you remember, takes the kind of thing JavaScript props, JavaScript children. So I'm going to make a div in here, I don't need the commerce. I'm going to need the props. Now, these have to be JavaScript. So I'd have to put this pound JS in front of this to say, convert this to JavaScript props, so that it doesn't try to send a closure script map which is an immutable data structure defined by a closure script that react knows nothing about. And then for children, same thing Up to see this is a JavaScript array, not a persistent, you know, immutable vector from closure script that has Hello in it. So I'm gonna save that in a little hot code reload. And I'm going to run that. And you see Hello, show up over there. Okay, great, wonderful. And from here, you can see that I can just do kind of Rob functional building up of things. So I could do things like Alright, well, I could define a function called div that takes some props, and some children. And then does this this thing, right, okay, well, that renders a div. And now props, I'd like to be able to, to send down a nice closure map. And then children, I like to do the same thing with children.

And so then down here, I could say render a div with class name, read, and children. And notice I'm having to, I guess I could, what I could do here is say, let's make that a variable number of children. And then let's go ahead and pre turn that into a vector, because that could be a lazy sequence. So I want to be careful that I convert it to something that ends up being what I want it to be. I think that would work okay, with the lazy sequence, but let's just be ultra careful with it. And so now I can say, Hello, say that, let it make my div function. up, let's, let's render Hello there. So I'm doing. But in the comment block here, I'm just sending this entire expression, you can see it popping into the repple over here, I'll clear that out. So it's calling that function for me. Okay, now, what are the problems with this? The major problem is that in order to get the convenience of using closure script data structures, I'm essentially ending up with having to do this conversion. And this creates some overhead. Now, in terms of just how react works, you can you can see how we get to kind of motion on the screen. I did want to mention this. Right, so so the idea is I've got a way to say render a frame, render a frame, render a frame. And it's efficient, even if the dominant is very complex. This is a complex tree of elements. When I say render, I get to say render the whole thing, render the whole screen of stuff. You know, if I had, let's say, I made an unordered, list, one and list item one. Right. And then I went in here, and I said,

Make a div with empty props, put in an ordered list with empty props with a list item with empty props, A, B, C, right, so frame one, frame two, frame three, frame four. And here, if I change that one, the actual refresh only has to refresh this one little DOM node, even though I'm sending it a whole tree. So that's the promise of react. And of course, there are a number of things you need to do to make that work well with react. But that's what the raw picture looks like, underneath. So let's go up and see these functions, you can already see there are a couple things wrong with them. One, the props are optional. So like, even if I want, you know, if I wanted this to look a little cleaner, well, now I'd have to put in some logic where I'd say, all right, well, if the first thing you passed, is a map, right? I could do that. Right? I could just say a and R, and then just the structure and figure it out. And it's a bunch of logic, and then every render of everything on my screen is going to have all that conditional logic thrown in it. I mean, it looks nice, it's pretty, but that ends up generating a bit of overhead. And this is where it looks at first, like JSX has a leg up because JSX is a compiler. So it can look at what you've done, figure out how to turn it into kind of the most efficient code and then output the JavaScript for it. Okay, so this takes us to full So let's close this raw namespace, close these guys out, I'm going to go into my shadow clgs file. And I'm going to tell it instead of loading raw, let's let's load app, that's, that's the thing I want to load. And just to get a clean slate after that finishes, compiling, Oh, right, I've mapped brings in full growth. So that's why it was taking a little full time to get its initial stuff in order. And this is index now not raw. And you'll see now if I go to App more, I've got some, some code pre written here. Let's get some of this out of the way just as well, you see, I've kind of pulled some of the things in already, I don't need these anymore. And I'm pulling in fulcrums, Dom helpers that look a lot like the functions, we were just using. The clear the repple, here to make things clear. Alright, so if I, you know, open a line here in the middle, I should see it hot code reload, I do. So that was just a verification that I'm not, you know, gonna see insane things. And just for fun, I'm just gonna go ahead and, and do one of these renders and see that, okay, it's working, I can, I can do this create element. with raw JavaScript data structures, I can evolve it, I can make something read. Great. Alright, let's see how fast that is. So if I try rendering 100,000 divs. So these are these are updates. But the the main overhead here, obviously, is doing the creation of the virtual DOM tree. So calling this create function has some overhead. And then of course, the render has some overhead. So actually, we could just measure, how long does this raw create element take, even when it's not rendering, okay, so 140 638, we'll run that a few times, let the browser warm up and make sure we've really got kind of a solid numbers about 130 536 milliseconds for that many iterations in on this machine for this browser. So that's the kind of base level. Now I'm curious. If we do if we were to do one of our, you know, our times of our functions over in, enroll, let's, let's actually pull one of those over here. I didn't think to do that in my planning, but it just occurred to me that that would be here. Let me undo the so that they are easy to I don't care about that. But I just want the div one. So this is calling that so let's just drop this guy in here. And call this f div. That's a bad name for it. div. Basic. Right. So this is our basic idea of maybe how to do a div. And let's go ahead and throw in our, our convenient version here. div, basic class name,

red, with Hello. Alright, so let's time that. Sorry, we have to save a lot of hot code reload. All right, way slower. Right. So you know, when I try to get it there, I'm nowhere near 136 milliseconds, I'm I'm a little more almost three times, almost exactly three times slower, with this naive approach. So JSX, clear, clear winner here in terms of overhead for notational convenience. Now, can we can we do better? And the answer is, yeah, we can do a lot better. So it turns out that folkers dom namespace leverages closure macros, closure, script, macros, closure, closure script, their macros. And what a macro is, is basically it's just a function that you can write in closure that runs at compile time, transforms your source according to what you output from the function. So for example, a really simple macro. Let's say, we said we call it this, this will be fun. Let's just make a function called exclamation point, a macro called exclamation point, that just takes a body, right, any number of internal things. And what I wanted to do is wrap that body in a try, run the body and then catch default exceptions and do nothing with them. So just basically do this thing and I don't care if it works or not, but don't tell me about it. So that's, that's the macro I'm gonna make. And let's see now, I think shadow will reload that in this namespace. So now if I come down here to my little comment block, and I say macro, expand, bang, you know, print line. Hello. I have to quote that to see what it would do the capital, that manual eating Oh,

actually have to do that.

spell it right, Tony.

Oh, can't write macros and closure script, you have to write them in closure. So I would have to convert that to C. Let's let's just do I forgot these words. See, I usually work in clj. c files where they're both. So let's make a macros namespace enclosure here. macros are because the compiler is written in closure macros actually are written in closure. So let me pull this, this macro over here. And you know what? I'm gonna. That's good enough. Over here.

Okay, that's cleaner. Okay, so now down here. I can macro expander, you can see, now I could use this, this notation of surround my thing with bang to really mean, make a try catch that just catches things and, and doesn't do anything with them. Oops, I see an error in my macro. And that's the this needs to be plain simple. Let's do that. Do this. And there we go. That's what I wanted to downplay. So this command just tries to see what the macro would output. So using this notation, at the top level, right, so I could actually run this now. And you see Hello, come out on the console over here. And if I try throwing some sort of exception Oh, wait, what is it? It's j s error.

I still get Hello. But if I'd done that with a do, I'd get through, I get an exception. So macros let me kind of reform, like invent my own kind of notations. Three form things in a simpler way. Full grow leverages this to great effect to get us back to what we want for these guys. I'm going to get rid of this macro bit back and leave it there. What does it matter? Okay, so div basic. We saw that with slow macros, we see those basically allow me to write new notation, that rewrites my source code before it actually makes it to the next layer of compile ation, which is turning it into JavaScript. Well, I'll leave those there for historical purposes. Okay, so let's look at what closures Dom namespace does for us. It turns out in closure script, you can actually write both a macro version of something and a function version version of something. Because with macros, you can't use macros in higher as a higher order function because they're not functions. So for example, if I went down here, I've still got this exclamation point thing pulled in. If I were just, you know, say, for example, just even tried to write the expression. I'm just gonna make a function here. Where I try to map over exclamation point, that sort of thing. And save that it'll tell me no, no app had bang isn't even a thing that exists at at after compile ation. Right? It's a macro. It's just not even there. But I very well might want to map over a div and put various things in them. Right and it turns out, closure script allows auto, it can auto figure out that if you use divx as a fun introduced the function version. And if you use div in a different context like that as as a invocation if you use the macro, so let's see what we get with that. So if I say macro, expand div Hello, right? So this is the full CRO, thing, these are kind of generated by code code, if they have got macros that generate macros, that also generate functions. So this namespace is actually relatively short. And it just lists all of the possible DOM, things that you might want. And then it uses generators. To generate the Yeah, it's it's fairly involved. But the idea is to try to get as as good a performance as we can get. So let's macro expand div of Hello. And we can see this calls a function called macro create element star. So let's go look at that one macro create. element, star. And so this is literally just create element. And it takes an array. So it uses apply here to use the the theory so. And it's an Nyland side, side concern. But that's what it takes to make it work. And notice the macro has already pre converted the arguments into JavaScript. Same thing, if I put a map here and say class name, red, and I macro expand that it magically outputs source code. That's That's exactly what I want for this to be essentially full speed because I just have this one layer of function call overhead and the optimizations in the compilers in JavaScript over the runtime interpreters that are just in time compilers can pretty easily optimize away kind of redundant function call layers and that sort of thing and make things pretty fast. So you can see I'm already getting pretty good leverage out of this macro. And in fact, if now I change this to Mac, folk rows, div and run this, you can see nearly identical fact, if I run that a few times, right? It's averaging 138 240 130 934, right, just like maybe a percent faster, kind of hard to tell. But you'll see, you know, if I run that enough, it's a little slower, but so much little slower, this 100,000 calls having 100,000 elements in your DOM is, is it's not a it's not impossible. But you know, for most screens, that's a lot, that would be a lot of elements. And so a one millisecond, per 100,000 overhead, and this is a 2013 laptop that we're working on here, this is not a brand new machine. So

differences tiny. Now, I do want full CRO users to understand that you don't always get this optimization. And you can very easily confuse or make it impossible, rather, for the macro to know what to do. So one way to do that is to just say div with a symbol, because this symbol could be a props map, that's a closure data structure, which needs to be converted to JavaScript. Or it could be a child, right? I could have deft a to be list item, right? I could have depth a to be props, I could have depth data be a string, and that at compile time, I don't know what a is. And so if you macro expand that it calls a different function knows there's no star on this with plain closure data. And so that's going to have some overhead. So if I take this guy up, right, if I've got a defined up here, just as a string, if I take that guy up, and put it in here, and run that, you'll see it's slowing down. And it's slow, because it's having to do runtime interpolation of the arguments to figure things out. And that can only be done by a function. And so there's no way to do this, this, you know, these these fancy things. Now, as soon as I throw a map in here, it gets fast again, and it gets fast again, because it's unambiguous div, the macro looks at it and says, Oh, well, the first things map. And so that's, that's a child. I don't know what the child is, but I know it's going to be a child. And so I can go ahead and emit the star version, and convert this to a JavaScript array of things and a JavaScript map of properties, and then run something to force the force children is about lazy sequences. If you were to embed a lazy sequences child, you'd have a potential problem. So the macro on MLA automatically takes care of you being able to say, you know, map over div, A, B, C, that sort of thing. Because this map is going to return a lazy sequence. And so this forced children unmix it a lazy sequence, basically recursively. Okay, so we can see that that's one way of getting your performance back. Now notice, even without the map, it's pretty darn fast, right? That's 100,000 iterations per element. So 250 milliseconds divided by 100,000. Right? You're, what is that 250 microseconds shifted over to more two microseconds per call, versus 1.5 microseconds per call. So we're talking about extremely small differences that can make, you know can make a difference, I have a fairly large page that's changing in large ways. But I just wanted you to understand that this is this is a superpower, I don't need a separate, you know, JSX plugin for my build system, that then turns it into the thing that the compiler really wants to see, I've got that power built into the closure closure script ecosystem, because it's just part of the language, it's part of the language to be able to morph your thing, your call from one thing to another via macros. So this is this is an example of a fairly complex use of a macro, I'm doing a lot of different things. Here, I'm supporting the idea that you might want to, I mean, let's go down here and render some of these. So if I render this to the screen, I get these items, I can add a class with this funny notation, that's just convenient, I don't have to, I don't have to write the whole map of things. I don't have to say, items is a regular function, sorry, items is just this function that does, and it well with a map indexed, making, you know, list items with the proper react key. And let me stay on topic. I find something else to say there, but

so there's some notation here, where I could say, class name, read, write and render that. But for fun, it's nice to be able to do this. Now, we run into an interesting conundrum here is when we macro expand, that the compiler can't still can't guess, this macro, can't guess if A is props now, or a child because some nodes like input, that would just be props. But with div, it could just be prompts, you could just making it making a div with like a width and a height and a color and that sort of thing. And so it can't know. So it uses the non Astra version, right, so that one's that one's gonna be slow again, to fix it, all you have to do is add in props. So then it's unambiguous. Right, and you don't even have to use a map, you can use nil if you want. And it still gets the idea that I can use the fast version and pre convert all the data structures because it's unambiguous. So if you want the absolute fastest Dom rendering, in full CRO, you can get native react speed, just by keeping your your usages unambiguous in terms of what the props are, and what children are. And so that can be as simple as write the keyword has to be a keyword if you use it, do you see you could say dot read wide, fat thing, right? That's multiple classes that that would add. And as long as there's something that it can do that it can no are that nil. Obviously, nil can't be an element. So nil must be props. Because props can be nil, and a map can't be an element. So that must be props. And so that's an ambiguous you get the star version. But as soon as you drop the props, you don't get the star version. So that's kind of your, your overview of how Falco gets full speed, native react, JSX style speed, out of Dom creation, and gives you kind of the power to you know, with some extra notational convenience added in, you can quickly add classes or IDs, right, the ID of that node so I can come up here and and render each one of my render examples here.

If I go and inspect That element, you can see that it added an ID thing to it class red. And if I macro expand that,

you can see that the, the, the this special notation got converted into low level react JavaScript props for direct calling against react. Right there. That happened before the hot code reload ever happened before it ever reached runnable JavaScript. Okay, so then I did want to mention just just one more thing about how react works in terms of this key idea. Hopefully, you're an experienced react developer, and you fully understand key, but you may not, you may be be surprised to to, or mean, maybe you won't be hopefully you won't be. So if I go and manually make this thing that I had shown earlier, do I have a render of that? Now, but we can just render this guy, let's comment this guy out. And say I want an ordered list with a list item of A, B, I'm going to make sure you can see the console here. And if I render this onto the route, you notice I got no warnings, no errors, no problems. If I map over the Li as a function, A, B, I do get a warning. And so this is this is the basic statement of keys, if it's obvious from this, like the children are, are just kind of static parts of the DOM structure. There's no need to tell react anything else about them, because it doesn't expect them to move around or change. But as soon as you pass it, something that looks like an array. Right, so map becomes a lazy sequence. And you saw on that macro, expand macro, expand wraps that with a force children's, the lazy sequence gets unwrapped. And then that gets turned into a JavaScript array. When react sees that JavaScript array, it's, it's Oh, you're sending me something you're programmatically generating. And you're probably going to move those around or edit them or whatever. And when I need to go edit the DOM, I want to be able to find the right one quickly, so that if like, one disappears, I know which one disappeared, that kind of thing. Or if one gets edited, I can tell which one to go and edit without having to like, figure out Did you reorder them? Did you What did you do. And so this warning says, alright, I'm gonna make my best effort at rendering the list. But if you do multiple frames, here, it's it's going to potentially look scary, I'm going to get confused and maybe render wrong or at the very best, it's going to be slower than it needs to be. So you can get away with this kind of warning. But the better thing to do is to make this a function.

And here we can see map indexed. So that we get an index into the list. This is kind of a recommended thing if you don't have a known unique ID on each element. And maybe I should call this label for clarity. Right, so I have my lamda which calls Li to make list items with a react key of ID x, and a child of label and the two labels. Now I'm going to reload this because react will only give you this warning once about a particular area of the DOM. So I'm going to clear out the DOM, rerun this and we'll see we get we get no warning. So so that's what key is about is it's just putting a unique identifier on siblings. But the thing that a lot of people understand is it's it's a generated list or an array of things where react is detecting that Oh, you're generating that from a code algorithm. And therefore it's going to change in a way that I need to understand better to make it fast. Okay, so, that is the low levels of react and how full crow can generate these, these react DOM elements to be as fast as native

