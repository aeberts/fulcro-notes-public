This is a quick demo video, just to talk through some of the design work that I'm doing around making full grow, both less verbose, and less stringent, require less coupling, just generally make it more composable, usable and other libraries. So first of all, let me just say what I've got set up here in this namespace, I'm in a workspaces. namespace. This is in the focal repository on a branch, I've sort of got this announced in the fulcrum channel. So you can find references to it there. I've just created in clgs, a pretend server database, some path home resolvers, for getting various things like users and settings. And the current user as a anonymous global resolver. Being able to save a form, which goes through and uses form diff, you know, there's a nice mechanical way of doing that. To save a form, I've got something for doing an account resolution, this is a separate like demo, and in the same namespace for doing like a login form. So there's a login mutation, a logout mutation, finding who the if your current session, like if you're already currently logged on, and then pulling the details of your account if your login registered the resolvers with the parser, this is a simple Python parser using Connect, I structured it this way to get hot code reload and clgs, I could change the mutations and resolvers and have the hot code reload, just update them. So the parsers and external def with an array of resolvers. And then the AP is the deaf once that calls this guy which can change so that that lets my my remote talk to a server that can hot code reload, and clj. So that's kind of a handy little thing. And I threw an async timeout here, just to make it so that, you know, it gives you the feeling that the servers taking a second so you can see your load markers and such. Okay, so what am I trying to do? I'm trying to make it so that you can use as much raw react without, you know, the features of full crow UI as possible. So for example, if you wanted to use some other rapper library reframe or what have you, and you wanted to let that be the primary render fulco actually doesn't care about the atom that it uses. And it doesn't actually watch the atom except for inspect to update the inspect tool in Chrome, it actually uses the transactions to figure out when it should rerender. So when we create an app, that app can be used pretty much headless, so we don't have to ever mount it, it's actually kind of ready to go as soon as you initialize the database. Now, if I'm not going to mount it, the only way I get it inspect to work is this line 146, I have to actually tell inspect, you know what my app started, I'm not actually going to mount it. Right, because in this demo, I'm actually using cards. Down here at the very bottom. I'm using workspace cards that are just playing react carts, and I'm calling low level JavaScript, React create element on things that are hooks based raw functions. And so I've created this with full grow, where you can give it an app that sets up the contextual stuff so that transactions and stuff work properly. Most things work properly. dynamic routing requires composed queries from the route to work properly. So dynamic routing is never going to work with this, we might write something different that will but that's the basic idea is I can render this thing. I can say with full grow, I can tell it that app I declared above and then I can start doing fun things. So let's let's start up here with the first fun thing. So I made it occurred to me It might be might be nice to have, I kind of started with with a macro called ns NC first, not even a macro this, these are functions actually. And NC I've got a little repple running here basically creates a normalizing component that's anonymous. So I can get the query from it. And notice it, put all the things that I told it to including the join down to settings. I can ask for the identity that if I were to give it user id 34. And it understands Oh yeah, my ident for users is based on the first ID field advise. So what this little function does is it walks the CQ l finds the

first ID field sets that as the generator of the identity function for the top level. component, when it sees a join, it creates another nested, you don't have to call it and see, it just says, Oh, that's a join, you probably want that to be a normalizing component, I can just do that recursively. So there's actually a settings component hidden in here that you didn't even have to write. So you can actually say, get the query of of user go down to 0123. This would be 0123. This is actually for now I changed the query. Is that or is it three? Now it should be four. Go from user 01234. User Settings.

Oh, there needs to be another good career there. I think, Oh, I'm not going to bang on that, just to show you that one little thing. But there is a nested normalizing component here with that. After I did that, it occurred to me, it would be just as trivial I went to play with forms of that guy. And what forms needs is not only does it need the query, and the ident. And notice the query now has, where is it? Right here has the forum state config added. So that's what this guy does is this adds the forum state. And it also adds, if you look at the just base component, options of users, it adds the form fields. And notice it added the sub form for settings. And if you walk down that query to this node, that normalizing component that's associated with this part of the query has automatically been giving its form fields, settings, marketing. So basically, it's just the naming heuristic if it's not an ident. So there's an embedded identity. And it's not a UI field. And it's not an ID field than it must be a form field. So that's why user name and user settings got in this one. And if I got down to this, this sub one, I'd see that it has settings marketing as its form field. So that was a fun little realization that we could generate anonymous components that are hooked based. And this is all the code it took, like that's, that's it. This is and this is the form based one, the one that's not for me, it is even shorter. Okay, so what I've got that form, once I've got that form component, I can do my normal form, state ad form config mark the fields complete, but I might want to load it, well, that component acts, right. So I can actually use a lifecycle hook in the user forum to load the user, do a post mutation to initialize the form. And even set a load marker for user that as you saw, earlier, I asked for the marker table, I can use to see when it's loading. So if I come over here, and look at this form, and I'll remount it, which will cause it to load. And I'll put some stuff in it and save. And then I'll remount it, which will cause it to load. And you'll see it's still got its state. And it's fully normalized to see settings ID one has its form config, it has its settings it has the true false kind of thing. The user current user is user id 100. User ID 100 is normalized. It's kind of hard to see that it has this forum state config and updates of course in the correct way. So way less boilerplate and in fact if you if you look carefully here, the UI of this form here's the card here's the card create element of raw react with full cryo which is a deaf in which does a with full grow UI user form which is a deaf in plain deaf in like this isn't even notice UI user forum is interrupt react factory. So this is a real hook space component now, but just raw function created with a factory for react use lifecycle I can use that user thing that I created up above in load without a problem, I get the normalization route properly. And then I wrote this helper for react use route, which looks pretty much like load. Right? This is this is pull it from the local database. This is get it from the server and put it in the local database which is either Patterns identical, right? And this is just becomes a root key on the database, and load. And so it makes sense to be able to just use a root key in the database. So this kind of gets rid of a couple of problems, when you're trying to first initialize your UI, you may not have a user yet. So you need some way of routing the data query. And the route is just the natural place to do that. So I was using us tree use component I've played with these and other namespaces. And it occurred to me that we have an infinite number of namespaces. To put on keywords, it really isn't that hard for main components of an application to name a root key that they also have a resolver for, for doing this sort of pattern.

And then if you have a component that you want to use that you've already say, initialized or can initialize that use time, then there's another use component or use, use tree kind of helper for that. But this, this ended up working out much better this way. So user, it ends up giving me the user properties, of course, and then the sub properties. And then I can just look for the load marker, I can use these raw set values, which are nothing more than helpers, that that, you know, call transact on mutation set props. For me, in a more convenient way, update value. So you know, it's it looks very much like a normal folk rap in terms of how you use the, the actual internals here. And then it occurred to me, well, we have state machines. And now we've got a way to kind of generate actors on the fly. What if we were to actually use that to generate actors on the fly? Now UI SM actually uses the component name of the component to find it in the registry. Because we can't put the components themselves in app state. The state machine needs to keep track of who the actors are. So it stores them by component name. So in order for components that are generated by NC to work, right, you have to pass a component name as the you know, put that in the component options map which is normally done for you by def sc. So within C, it can't make up a name for you. Well, it could I guess we could Jensen one, but then who would garbage collect those names? So we've got this, we can generate a login form in a session form as pure database to components store those

Oh, I shouldn't have actually stored those like that we had them in mer, why did that this isn't necessary, because I've got them in the registry. Now I can just find them. So this was, this was something I did earlier that I don't need any more than I can do your normal and what kind of apply actions reset the actor idents for the current account actor to be that session actor. Reset the actor ident for the login form to be the one I just made up. So now I can do a US UI SM tell it the app, tell it the session machines definition which we were just looking at the name or ID of that, that particular instance of this machine, and then initial event data. And then this returns to me, the active state of the machine. And the actors merged together. So after keys login form current account, so I can just pull their props out and start rendering them. So you can see I've got a little login form here. That's nothing more than a plain function here. I didn't make it even a react based thing. But I've got my email, or I can set value password set value error message if I have the credentials wrong. And so now I've got this little no bob@example.com login, login that shows it's checking, you're logged in, log out. So I've got a full blown. Well, I mean, it's, it's, it's a quick hack. It doesn't do everything it's supposed to do on the screen. I don't even think I've checked the credential part yet. Yeah, I just like it just like let you in no matter what you type. But it gives you a very clear idea of the power of this sort of, let's make a state machine let's say use that state machine. Give me back the actor states and then I will hook the rendering up to it by hand. Now I don't. I don't need to pre write components to be the actors I can have the actors be just pure data concepts, where I can document what the actors give you back as props and how they work and then you just wrap the UI around them. So these pieces I'm working on, I'm trying To see you know about how well this is going to compose into regular folk raps and vice versa if we want to use def sees within these, these components that aren't composed a root and full grow, I mean those should work fine because in C is really just generating on the fly something that def st would generate. So that's where it's at.

