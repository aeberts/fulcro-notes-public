In this video, I want to continue talking about the full stack story of full CRO. And some of the nuances that you'll need to understand to, to do a good job there. I'd like to start off this video just by noting a few things about the ID, stuff that I'm using here, you may be noticing in your ad, when you're playing with the source code, the deaf SC might be turning up yellow, as if it's not. Or actually Deaf a C will be yellow person picker would be yellow on if you're experiencing this problem. And that if you're on the symbol, and you say, navigate, jump to the declaration, it doesn't do that. And that's a good one to know, jump to declaration. on mine, I've got it set the command to be. And then I've got back, which is navigate backs at the command left bracket like in browser, you know back. So I can jump to something and then go back. Now, if this is showing up yellow that won't be working for you. And the way to fix it in IntelliJ is to click on this light bulb. And it will say well, no, we don't want to resolve you want to click on the macro name. So def se click on the light bulb resolve def SC as and then specify and then type in dev sc and use the old one from full grow too. So cursive has built in support for some full grow definitions and macros for and the syntax of them's identical. So if you tell IntelliJ, that def sc in compact logic focal components, the new one works like the old one, then it'll recognize the syntax of that. And and index those. The same thing goes for mutations mutations internally are actually multi methods. That's that's technically what def mutation outputs. So for example, this make older mutation here, you can actually write as a def method, in slash mutate, on the symbol make older, right, because this is a data kind of thing. But that was the multi method name, mutate, excuse me, mutate. And this takes, I don't remember what I made this taken folk with, or I think it just takes an environment. And then this returns a map with the sections in it. I think each of these gets an end. And maybe this gets to the end as well, I don't remember exactly what it looks like is always used def mutation. But if you go and look at the macro, it outputs def method, your end. And then it outputs a method map, which is just a map that has the various handlers and it has keys. So there'll be an action, and there'd be a remote. Right, that's, that's the equivalent. The problem is, I can't if I if I do it that way, not only does make older show up as a unknown symbol, because it's just a piece of data, there's no way to make the ID he understand that multi methods symbol resolution is this mutation. Whereas if I give you a macro, not only can I syntax, check it a little bit, I can also let you then really the ID he can then let you say oh this thing resolve that as if it. And again, if you go looking for the old Deaf mutation, cursive already knows how to resolve those I'll be talking with with the developers of cursive soon to see if they'll alias over these for us. But if you do that, and it hadn't been done, these should index they should no longer be yellow and your your jump to the definition should work. So these didn't have to be macros. Really neither did def sc. def SC is just a convenience, you can actually define a function. I mean, this is sort of how you do it in react, right. Or in JavaScript, it's how you make a class, you make some function. And then there's a configure component function call that you can pass a function to, and it'll turn it into a react class that's essentially along with the the options map. So that's essentially what the macro does. But again, it's much easier to have something that goes through and defines the symbol does some syntax error checking for you.

And then does you know, declares it does a little bit less magic, like it's just making it a little easier to deal with. But to me, the big deal is, once you've got these things, developed as macros that behave sort of like def n, or def mutation or whatever, you can tell the ID they define something and get symbol resolution, get ID navigation, which as your project gets larger, becomes very, very important when you're working with something like say, say Redux, where you go and you define all of your your things as strings. Okay, I want to jump to this thing that executes this action string, well, you just have to know where that is where you have to drop to a command line and grep. for it, you can't just say jump me to that thing. It's just not something the the, the development environments going to be able to do for you very easily or accurately. You know, just be at best a heuristic of already find all the strings that say that and we'll jump into the one that we think is that thing. So. So, you know, closure really is a superpower here. macros for library use, and these sorts of situations really buy you a lot in scalability. Okay, so that's enough of ID commentary. So let's talk about this refactoring that I've done here, you see, I've set this up. So I'm going to show a list of people on the left, and then you're gonna be able to select one, and then it's going to show you the selected person on the right. And this is enough to let me show you a number of common things you run into when dealing with interactions with the server. So we're not quite to forums, but but this is sort of on the way to that sort of interaction. So what I've done is I still have my root component, remember, that's kind of special. So we typically just link that down to the thing that we really are interested in. Search, look at my header here. And then person picker. And people are sometimes tempted. So this is a quick note about mistake, a big mistake you can make. And that is if you run this Git query, in a repple, let me do clgs repple. You'll see that returns a vector, well, vectors illegal query. So people think, Oh, well, I'll just do that. That's all I really want. And then I'll just pass the props straight through. And actually, this will this will error checking complain if you do that. But you could get away with doing it that way. Oh, wait, query needs? Oh, no, no, it's complaining that initial state has to be a function if you make query as a function, because it can't analyze this, it's sort of like telling you Well, if you make the query, right, I can't check it out, I can't do any magic for you. And in the initial state. So this compiles, it doesn't give you an error. This is a vector, which is what a query should be. Technically, this looks like it will work. And technically it sort of will. Well, as you can see, things are things are rendering. The problem is what I talked about the other day, and in maybe two or three videos ago, with refresh story, remember, there's a metadata on this query, that tells you that tells the system, which component that query came from. And what we've done here is we've made that metadata mismatch, the component it's coming from. And so that's a problem. So we we don't, we don't want that. In fact, if we were composing these together, that would be a mismatch that then if you compose it into another thing above it, the one above it would call get query on whatever this returned and replace that metadata. And now things are just all wonky. So don't return another components query as your own. That's, that's a big No, no. So always, you always want to make up an edge. In a join, to go to go down a level, right, this is a node to travel out of a node via query or props or rendering, you need a data edge. That rule is sort of flexible, you could have a component in the middle that's completely stateless, that has no query ident, or anything, it's just acting as a react component, transmitting data through it, but they're not asking for any of its own. So

there's a little bit of technicality in there. But for the most part, if you want to move from one layer to the next, there has to be a join. And the joint has to use an invented key. And part of making that tractable is initial state healing or setting up these edges for you. As the application starts, as the application runs, of course, you're responsible for, you know, making these edges exist in your reified data here in the database. And that's one of the central tasks of doing any programming and folk are really in focal, you're not UI programming as much as you are data model programming, which is a much better thing to do, in my opinion. And a much easier thing to test technically, like you can very easily test a pure data model, which is just an immutable data structure. And your mutations are just functions that take it from one state to the next. And the UI just happens to show it right. It's a visualization of this graph. Snow, no way to look at it. Okay, so don't steal queries. All right, next. I mean, along those same lines don't mismatch queries like if you've got a query that you used, like up here, I've got two things that are representing people, I've got person list item. Now let's go through the refactoring, let's just get to get to it. Okay, so route goes to a person picker, which is this thing that has two columns. So you see person picker has two column grid, one of the columns is the person list, and one of the columns is person to tail, we see two edges going out of the UI tree, we see two edges in joins in the query, we see one edge in the initial state, because selected person was nobody selected yet. So I don't have anything to initialize there. So I'm actually going to leave that edge on populated, it's just going to not exist. So as a result, this is going to come in nil. So there's, you know, there's some argument, some valid argument to say, Well, you know, since that could be no, maybe I should say, when there's a selected person, all render something in that column, right, so then the column doesn't even appear there. And then avoids potential warnings and things in the console over here, which I was probably getting, which I was right, it was telling me, I was getting something where the idea was nil for a thing. So that's, that's probably why I was getting that warning. Okay. So I've got those. And then I made two different person components. So this is the next interesting detail. I think, for people who are new to fold grow, is there's a person list. No, sorry. These aren't what I was trying to compare contrast, let's talk about the person list. First, the person list is just what you saw before. It's just a component that represents the people that are going to be shown. It doesn't look for formatting, and then it maps over the people. This is another place where it's tempting to steal the query right there, the only data that you need here came from this thing, why not just promote that up and ignore the edge, don't do that you'll break things, you always need the edge. And chances are at some point in the future, you're going to add some additional stuff to this list, sort order, whatever. That's, that's specific to this list. So make it an edge. And then that goes down to the UI person list item. So this is the thing that I changed. So UI person list item. Well, this is just, you know, a list of people, I don't need to know their name, I don't need to know their ages, I might not definitely don't need to know their cars, I don't need to know their subgraph of details, all I need to know is their ID, so I can normalize them, and the name, that's all I'm going to show. And then I'm going to make an Li with a link that lets me somehow select a person via transaction. And then I'm going to show this is actually the label of the button or the label of the link here. Maybe a little easier to read that way, I'm just going to show the person's name in the list item. At the same time, on the right hand side of that, side by side things, if I get rid of this, when for the moment, on the right hand side here, I am going to show all of the details of the person here. So I need a different component for that. But I'm using a normalized database. So person detail is gonna have the same ident it represents a person, but in this case, the person detail wants to know the name, the age their cars, etc. Okay, now, it's important that you remember that queries on these components are overloaded in their purpose. Purpose number one is when we reach this node in the graph, which the parent directed is to

by having a join, right, so up here, we had people took us to a person list I'm sorry, person to tail we had selected person up here, going to person to tail, this is a real edge in the database, just like pick your list as an edge in the database. When the query engine started at route, it walked across this edge, got to this component, this component said, Okay, these are the things I'm picking out and walk these edges, right? These are relative queries, these queries apply as you go. And if you remember in an earlier video, I showed you how the query system can start at an ident and move from there. So I could say, Okay, we'll start at person three, and resolve these things and everything below it. And that's a legal thing to do as well. So we can start at a component. But we're always starting at some entity in the database that has that particular item or some particular ident to pull the data. So this query serves, the first purpose it serves is pulling data from this client database into this UI. Right? That's purpose number one. Purpose number two, we saw in the last video, and that's to pull data from the server

And so here, Now which one I want the person list component. For the moment, I've dropped the double colons from, from these just to avoid confusion in viewers. So the person list has a person list of people edge. Right? So I'm going to load all people. And I'm going to tell it take that edge you got from the server that was at the root of a graph and make it this edge of my graph. Right, so then that happens on initial load. So if I load this up, I now see two people. So that's all I really wanted from the server, right? This is the promise of eql. And graph QL. It's that I can say, Oh, yeah, to fill out this particular bit of the UI, I just need the ID and the name. And if I look in photo here at the network, thing that happened, it asked for person ID and Name and the thing it got back were person IDs and names. That's the only network transfer that happened. It's more compact, and precise for the particular UI thing that I'm doing at the moments when the thing starts, that's exactly what I want to happen. So that's use number two of queries, is asking for something from the server. Now, it is perfectly legal to use def SC to define some query, and then drop the UI all together. So I could say I want person ID here, I want person ID here, and maybe I just want person age. And then, you know, I'm not going to render anything. So I just want to say person query, right, I can reload this over here. And down here, I can see oh, you know, I want to I want to use person query for that. Right, that's a perfectly legal thing to do. And if I reload, you'll see I'll get to bullet items, blank names, because I didn't ask for the names. And the transaction. On the network, you see asked for person age, and it got person ages. But of course, that's not what my UI needs. In this case, I'm sort of mismatching the two. But it's perfectly legal to structure your queries for normalization purposes, into a def SC for just that reason, I just want to load the data. Do not however, ever, ever, ever put this thing here, right, because this query is a query trying to satisfy UI concerns. And this query, if it were a person query, is a query that can technically get some data, but is not tied to the actual component you're going to render. So that's Mistake number two, never ever use a query only component in a UI position, you can use it in load, that's perfectly fine. You just saw me do it. But if you're if you're using that for some, like pre caching purpose, or whatever, make sure that you don't make the mistake of of double purchasing that because queries again, are overloaded. And in this particular case, the meaning is just, I'm going to use this to pull things from a server and normalize it. I'm never going to render anything with this as as evidenced by the fact that I didn't give it any render body. Okay, most of the time, you will not write def SC components like that, you'll write it like this. So we've got two phases here. Let's go back in and change this. Back to person list item. So that we get the correct query on load. And I've got the people. So let's talk about selecting a person. When I go to select a person, I need to make this edge and this edge in my database. We go look at person, person ID, oh, no selected person. Sorry. That's going to be one of these guys. Right? So person picker list. So right here, the person picker. So I want an edge here that says person picker slash selected person and has the ident of the person that I'm interested in seeing the details of. So let's go write that. I've already actually written it. So select person is a mutation that swaps against the app state and Association and I made these little helper functions so that, you know, when you have to do these often, you can just say, okay, associate an app picker path for the selected person. Person ID and then whatever ID the mutation was passed. Okay, Bob, Sally, Sally. Great. That's pretty easy. So really, you're seeing right here again, what you're doing is is management of the state model. So all I need to do is have this edge here and the We'll just render what the model says it's supposed to render.

Now the problem though, you should notice is, well, my load of the list while it didn't get agent cars, so ages empty cars is empty. If I start making older, they're going to start at one, right, this is wrong. I mean, it's working the way it's been told to work. But obviously, there's some data missing here. So we need to heal this. And there are a number of ways we can do this. And I'm going to start with kind of the worst, and move towards the the best. And, of course, worst versus best, as is always relative. But one of the things we could do, you might be thinking right away, is, well, why not just put a transact in here, not a transact a load in here. You can actually get the app from the environment of the action, or you could pull it in via require. And then we could say, Okay, well, we're going to load Whoa, let's just person ID, ID and ident. And then I need the person class, well, which person class I need person to tail? Oh, that's a problem. The reason that's a problem, and it's not a terrible problem, but

if I do that, I'm going to get a circular reference. closure and closure script don't like you going back and forth to each other. So client over here is requiring for convenience really model person, because I want these these two things to be in scope. And so I could fix this this way. I could comment that out. Okay. Now, I don't have that going on. But Alright, so now I've got to quote this thing. And say, all right, that's an app model. Version. Remember, these are just data. So I can, you know, I can fix that. But you can see, hopefully, immediately why this is less ideal is now I don't have any way to alias these. So I'm stuck with just like, typing them out. There's literal symbols. And then if I forget to do something like unquote, these maps, then, of course, I've got a different bug I've got to deal with. But I can say that and, and so this is this is a way that this can work. There's another problem here. But let's just let's just say we do that. So we say, Alright, what we're going to do is we're going to make that edge. And then we're going to reload the person from the server, but we're going to load them using person details query, which has name age cars, etc. Now, if I select that should work. What am I network transactions look like? Oh, can I do it? Right? Let me reload and make sure. Oh, person, select person load app property. detail. That looks right to me. We're getting errors. Let's see what the error say. Unknown app state mutation, oh, haha. So there's my other problem is if I have not required this file anywhere in my application, then the mutations don't get installed. So you can see why this kind of just isn't so great. So I want to I do want to go back to the what I had before here, right, so that my mutations end up being installed. Remember, they're multi methods underneath. So if you don't require a multi method file, it just doesn't end up in the application and your mutations aren't there. So that's what it was complaining about. So I go back and do this, make these a lot nicer and cleaner. The other problem that that I didn't like about that, over here was I'm tying this UI class concern with load into the middle of this select person and select person is meant to be sort of an abstract operation, I'd sort of like what select person is going to do in terms of IO to be kind of a separate thing. Right? I don't necessarily want it there. So because that ties me to let's say, I had a different part of my UI where I select the people and I need to use a different class to query for I'd be stuck, right? Oh, so there's, there's a thing I could do here. I could say, all right, well, you know what, let's just get the target class as as a as a parameter, right? Let's let you pass that in the mutate mutation. And so we can just say that that's my query class, we can just call it query class. That's better. Right? Okay. So that that doesn't seem so bad. So I could go over here and I could see, okay, select person. And then when I'm selecting them, I need to say there's a query class and that's going to be in this particular case, person detail. That's what I want. Alright, and then I can click on this thing, hey, there we go, now we're getting the right thing. And you can see as I select them on the network, it loads the details that I need, and gets the answer back. Of course, you're in a distributed system. So other people could be modifying Sally. And so this sort of makes sense, as you select one, you probably want to see the most recent information. So this is a very common pattern. Now, we're not done yet, because there are still some problems with this. We can do this this way. But this puts a react class into our transaction. So our transaction, which could be a remote thing, we don't know from the UI layer. So if you put data into a transaction that's not serializable, via transit, you'll get transit errors, and the thing will fail. So and this takes me to another another point, this load is kind of a separate, like, individual step here. I mean, I could come over here and say, all right, I want to load that person, right, this kind of this kind of is just another way of doing it. I could say, Oh, alright, on click, load the person and then select them.

And that's seems like a reasonable thing to do. And over here, this now becomes just a pure UI concern of adding the edge in. Alright. And, in fact, this is kind of a nice option. Actually, now that I think about it, I hadn't done it this way. And when I was thinking about it, but this, this solves it the same way, if I go look at the network, you can see, I'm getting these things, the transactions are literal loads now, and then select this is reverse chronological, by the way. So the, the stuff goes down. the topmost ones most recent, this is another way of doing it. And if you remember, load has a way to target edges. Well, my target edge is this picker path. So I could just grab this picker path function, which probably shouldn't be in that namespace now that I think about it. But let's just pick it up. For convenience, we'll organize code on someone else's time.

Person picker selected person, I could do that get rid of the transaction altogether. And now my load heals the edge as part of the load. That's kind of nice. I actually actually kind of like that solution for this particular case. Because it indicates exactly the complete thing that you're doing. The the criticism that I would have of it, is it sort of exposes to this particular person list item, exactly. What needs to be done sort of in kind of a non component local sense. So you kind of peppering some logic in there. But let me show you some other alternatives. Okay, so we have that alternative. Let's say we don't want to use load. Let's see, instead, well, we're already doing a transaction that has the abstract operation in mind. We did complain about, well, you know, we've got this target was a query class, we could pass this query class, person detail. And we're going to want that no matter how we do this, because we do need to interact with the server and say, here's the stuff that I need back when selecting this person. So we knew we do want to pass something like that.

But we could do is we could say that this is a remote operation. Now, you might say, Well, what, what does the server need to know? Or do in response to selecting a person? Well, the answer is nothing. In particular, however, this is a graph system. So the mutation for select person on the server. And this seems a little silly, could just echo back the parameter, write the parameter map. Specifically, it's echoing back a map that specifies I'm returning an entity that has this person ID fact that's this ID. And then here, I can say that I'm returning. Well, I don't say I'm returning anything, because it's person IDs already in context. So that's really all I need to see for that mutation. Then I can add it to my list of things, restart the, in the right repple. Restart the server.

Okay, so now, what I've said is, this is my local thing that I need to do heel, this edge, so it points at the right person. And then here I've said, Oh, and I'm going to go remotely. Now, first, let me point out the problem. The first problem, we're going to run into with this with this technique, and that's that when I click on this, I'm going to get an error. And I'm going to get an error for the reason I mentioned just a minute ago, I can't write that class across the network. So this is actually if we search through it, we're going to see in here, at some at some layer, some some trends, that thing happened. And it may not even be easy to see that that's what happened. But there during transmitted, tried to send it, and it wasn't able to encode it. So that's because the query class here is a JavaScript object. It's a JavaScript class, and it's got a bunch of crap on it that just can't be serialized. So if we go back to the UI, Volkow has a registry of all classes that have been defined, and it puts them in there under a keyword, that's the namespace of that they're in so app, client, and then the name of the class. So I could pass this as a keyword, which can be encoded over the network. And so now, when I clear this, and click on someone, I no longer get an error. Right? I've still got the one error before. But if I clear that out, you can see that I'm going back and forth. So this is actually demonstrating two interesting things. One, select person is going across the network, and the Select person mutation is actually returning. Let me do that as a network, the Select person mutation, notice it sent tagged value unknown person to tail like it, it encoded the keyword into into something, it's it shows it as unknown here, because the way the application has to talk to a Chrome extension, it can't actually encode the stuff quite right. So when you see these tagged values unknown, it's just, it's just an artifact of how inspect works. So you see, it tried to send that query class across the network, that was okay. And then it returned. Well actually returned nothing. It says pending, why does it say pending? Could be that my server did like it. Yeah, I think I've still got some, Oh, did I restart my server, I did restart my server.

Just make sure we haven't missed something. Okay, we got a warning there. And here, we got transactions, the network, we got something we succeeded. So here's a comment. That's important to understand. If a network request hangs on the server, full crew does queue transactions, this is a transaction processing system and the remotes are serialized so that you can reason about them. And so if one hangs the rest can hang so that may be what we ran into there. A second ago. You can see the response here did return person ID two right so that's even though I sent a query of person ID two, I got a response a person ID two, but I didn't tell the path home side any extra details I wanted, nor did they tell full grow, how that data might need to be merged. And so it really didn't help me. However,

there are ways to do this. Okay, so that one of the things I was trying to show you is how to get around this query class being passed as as a thing but notice it's still trying to put it over the network in in full girl land prefixing a keyword with UI should cause it to be alighted from queries or mutations that go across the network. These are considered this namespace on keyword are considered UI only details and the internals of foco try to keep those from going places. So So now if we run this Can we see that it's still there? Sorry, that evidently is only working for queries, which is actually what I expected. So let's not, let's not do that there. Okay. So the fact that we're trying to pass this as a parameter causes us some some issues. But let me go ahead and and take the UI out of that and show you where I was headed with this. Again, this isn't the best solution, but I've got the query class. So what you can do here in the remote is you can change how the request is sent. And the mutations namespace has these. So you can change the parameters. And I can go back here and I can just use person to tail now. Because basically, now I'm saying only send the parameter person ID, and then the ID, which is rewriting the parameter list that had query class in it. So this is keeping that from going over the network. The other interesting thing that I can do is I can say returning, and then the class that I'd like to return. Okay, so this is this is the other option that I have. So returning takes an end, remember, you can return in from remote to indicate Yeah, I just want to do whatever's in and these functions modify the end to say what should go on. So this is indicating to folco that the remote mutation can return stuff. And here's the stuff that I'd like it to return. So remember, on the server side, all I did was said, select persons or mutation, and it gets person ID, and then it returns a map with person ID. But remember that the resolvers, all these resolvers work with person ID as an input. So any of those can run to fulfill the rest of any query that happens to be sitting on the back end of this mutation. And so that's what we're doing now. And so you see, the details are filling out now. Right. And if we look in the request that gets sent, we see the call select person is surrounded by a join. So the call is now the key. And then the sub query of the join is I want name, ID, age and their cars with car ID and car model. And so that fills out the details, we look at what what came back select person has all that stuff. And the nested stuff filled out. And pathom just magically did that for us because we gave it enough context on the return value of the mutation, that the return query on the mutation could be satisfied and folker understands from that metadata on the query of that component, where to put it, and how to normalize it. So we're essentially overriding those elements as we go.

Okay, so let's take this a step further. So we've got this extra mutation we've defined on the server. And we kind of need that if we want to deal with these return values like this, we have the option of doing the load here, and then we're passing in this whole query class thing. And this is sort of a join point that I don't love, right? It's making us have to change the parameters, etc. So what if we could find a way to eliminate that? So that we didn't have to have that. So we could just say, yeah, this is gonna run remotely and return some stuff. Right? So we want to kind of get it out of this place, and bring it back over to here. Well, you saw just a second ago exactly what query that resulted in, you can actually write that inside of this transact. So let's reload show this is broken again. Right, I get Sally Bob Sally no age or cars. And so what I can do here is wrap that in the join. And then as the sub query of the join, I can say comp, get query person detail. And so now I'm saying run this mutation. And if it happens to be remote, merge the remote returned value via this person to tail query. Well query for it this way and merge it. So I need to make sure this like person is still remote. manually, right, the mutation join here. And now my details detail should fill in. Did I not save?

There goes I'm not sure why I needed to reload, but we can see the transaction on the network is still the same. transaction that had before, it's just a different way of writing it. So these some, these are the various ways you can deal with getting these things. And again, now that we've gone through them all, I think I personally would have preferred the load in this particular scenario. But there are places where kind of all these different combinations make sense in your, in your tool toolbox. So sometimes you might want to explicitly write the mutation joined, sometimes you want to go into this actual mutation, and throw it in here as part of your returning on your remote. Sometimes you might want to issue a load in here. It just depends on how your namespaces are laid out how your things are coupled, or decoupled, how they're designed. There's just a lot of variability. But again, I think, for this particular example, at least, I think the most clear way of doing this was to say, Well, I want to load person using the person to tail query and targeted at the picker path. For selected person, that seemed to be the one that kind of had the clearest semantics, particularly since we don't need to reify the idea of selection. So that's that's kind of a trade off. The nice thing about the alternative that we had with a transact is that the Select is now a mutation that you could use and say generative testing, like you could simulate clicking on someone by invoking that mutation, whereas here, you kind of have to have a real browser click. So again, I can I can go back and forth on on the different pros and cons to all of this. But I wanted you to see these these different scenarios for progressing your state model over time.

