One of the things that you'll run into in react applications at times is performance problems. And very often these are usually caused by large Dom's lots of elements in them. And there are all sorts of ways of addressing these. I'm going to attack a particular problem that's annoying. Me personally, in this video just to show you how I go about trying to improve the performance of UI when I find a problem. So hopefully, you're using full chrome inspect in your work when you're using full Chrome. And what I'm going to do here is open up the template. And I'm going to, I've already done this just for for speed here, I've started up shadow clgs. On this project, I've already started the main build. And then I did start a repple over here, and that's not the right project. I started repple over here and and ran this and then ran start in the repple. And so this started up the server on port 3004, running this application, but then I changed the UI of the template. So you can look at the template to read me to start it up. But I changed it and just added this new placeholder component. And I just gave it an ID and a name. And then I give it initial state that ignored the parameters, but generated a random UID for the ID, and then used closure spec to generate arbitrary strings for names just so I'd have some data and CC guides, spelled respectin, alpha and spec alpha. and then generate. And then in the route, I changed this guy from this top chrome thing, I just like I'm ignoring everything above line 196 there, so that it would have an initial state of 1000 placeholder elements, and then render them. So what this looks like in the UI, is I load this and it just gives me you know, 1000 random strings as DOM elements. So that's a fairly hefty react thing. And this is not the thing I'm trying to tune, the thing I really want to tune is inspect, because when inspect has this size of a database table, it gets pretty pokey right now. So you're gonna get to see a little bit about how inspect gets developed. The other change that I made to the template to get this going, is in the shadow clgs even file, I went to the main build, and I changed this to use the web socket preload. Because it's, it's a lot easier to deal with the electron version of the app, as opposed to the Chrome extension. So this just keeps everything a little a little easier to deal with. So I changed the preload from preload to WebSocket. preload. And then I can show you how to run the electron version of this. Okay, so that's all what's going on on the template here, I'm just generating a project that can connect to inspect and perform badly. Okay, so I'm gonna shrink that guy all the way because it's, it's really irrelevant beyond that. Okay, inspect just a quick little overview of the project, this shells directory contains the actual build, for running electron and electron runs both a node back end and a V eight front end. And so really, what you have to do is start shadow clgs. And in this project, which I've already done, right here, jump to its interface, and then make sure electron main and electron renderer builds a running. So that's the back end and this is the front end. This back end creates a WebSocket server to listen for applications connecting so if you have that WebSocket preload, it goes looking for this guy at a well known port on localhost. Okay, so that's how I get that running. And then in the terminal, you can change directories into the shells electron directory, do a yarn to install the packages, and you need to of course have done that. Here if you've cloned clone this guy. And then I've also changed the depths for inspect to include this library by Peter called tuft. It's a great library for doing performance measuring. And I'm using 210 RC four, which works a little better with closure script than the 210 release. I seem to remember that's why I'm using it. It's been a while since I looked up that stuff so anyway, I've got shadow running both builds with this tuft library added to the depths. If you've checked out inspect it won't have this by default. So I did add that to depth Eden. And then I'm going to go into this electron directory. I'm going to do yarn to install yarn Depp's or NPM, install whichever you prefer, and then you should be able to run electron dot. And I think on my path,

my path always includes node modules slash dot bin. So I kind of automatically get, you know, executables that have been been installed by node. Or you can do that, you know, np x kind of stuff. I'm gonna start that up, and that'll start poker inspect with the build them interested in. Okay. So now if I go to my application loaded, I should see inspect over here, you know, refresh, okay, things look good. Looks like I'm talking. Okay, now, to show you the performance problem. I'm gonna open this ID table, and I clicked on it, and you see one, three. So it's about five or six second response time there. Now part of that is react overhead and just making the DOM per 1000 new sub elements, that's it's going to be expensive to expand that in react or anything else, like adding that many DOM elements to the tree is just expensive, especially when they're formatted, etc, etc. So I'm not sure how much hope I have of of speeding that up, possibly some, but I do expect there's going to be some cost related to that. Now, in order to optimize the course, I need to know what's actually slow. And so the thing things I'm interested in are, for example, if I'm going to try to search for one of these things, arbitrary things that say, I'm going to search for three c nine to press enter here, and I should see something light up, you saw it took a little while for that to light up. So this is kind of a use case. And then I might go down here and click on the expand. Oh, that was actually pretty fast. Oh, that was it expanding? Sorry. That's how long it took. My CPU still burning up here. So you see this is really annoying to use, this is quite slow. Wow, it's still going. Right? So see this, this kind of table is just intolerably slow. Okay, so let's see what we can do about this. First thing I want to do is just show you a little bit about the basics of measuring things with tufte. Because you can't really optimize something unless you can figure out exactly what's wrong. So the layout of the project here, this renderer is just a really light thing over top of the real UI. And so Data Viewer over here is the namespace where all of this rendering happens. And so it's pretty straightforward. I didn't expect that to get that hung up. wasn't getting that hung up earlier. Gonna make me reload it.

Oh, right. Now we'll reconnect to the app. And let's say the electron one still in, sort of, I see what I did, I accidentally highlighted some things. Okay, so open that. Alright, so while that's working to expand, let's look at this data viewer. So most of this stuff, you know, isn't involved. It really is this namespace that does the Data Viewer. And so let's glance at how that's written. So if we look, Data Viewer is a function. And then there's this Data Viewer component and the Data Viewer component, get some stuff like what search string is currently being used, etc. And then it calls this render data. And it passes then this is expanded as a set of paths in your app state that you currently want expanded out over what static is for searches, the search string, you've typed, obviously, titles, this, this lambda here, etc. And then the CSS is being pulled from this component, local CSS. So I don't expect that to change. during runtime, the CSS should just be a constant. Okay, so let's go look at what render data does. So render data is just a recursive function, which calls render vector which calls render sequential, which calls rendered ordered list and render data. So you see, it's like this, basically, this just pure functional recursive rendering algorithm that doesn't really involve react much. So I already suspect I'm going to have some, some issues making this faster. I mean, if I look at some of these algorithms, like right here, you know, turning that into what's you know, map view with a concat. Alright, so turning that into a map, cat, maybe memorizing the sword, right? I can, like potentially save myself some overhead there. But I don't know exactly what's costing what. So let's do some measurement. Now. As long as you're holding a thread tufte can measure things within that thread. But because we're also going to be measuring things in components that react renders asynchronously, we need a way to collect up our measurements. And so so tufte actually supports this sort of thing. I'm going to glance at what I did here on Master, so don't have to go reread the doc stuff, figure it out, this is stuff that I'm going to show you here in a minute, here, this is it right here. This is the little bit of stuff that I need. Okay, so I'm going to go to the main No, not even, maybe I can just do this in the Data Viewer.

So I've added tuft this side effect and adds an accumulating handler to tufts infrastructure. And then this makes a function that I've exported, where I can just call it from the JavaScript console over here to dump stats. So basically, when you profile things here, I'll just show you. So let's say go up here to render ordered list. So in here, I could say, Actually, I'm just going to go up here to tufts and say, refer profile and P

profile takes a configuration. And then you can do nested calls to pee with, with keywords to name the sections you want to measure. And in this particular case, again, I'm kind of assuming that this might be called asynchronously. And so I need to start profile, which does the gathering and then Pete to measure a particular thing. Okay, so if I do that, come over here, I'm going to let that hot code reload. And then I should be able to call that stats function I just made, I may have to, or may not have actually didn't hit render ordered list. That's why I didn't measure anything. reload my app to get it connected. Nothing measured. But if I pop open this, this list here, after a couple of seconds, still nothing sound must not be hitting that function at all. Let's go towards the top.

There we go. So render data to three seconds. beastly. And calling that function is a side effect that clears the current collection. So if I, you know, do something again, it'll recollect data, and I'll get my numbers. Okay, so now I've got a way of measuring badness. Okay, so we've got this sort by thing, let's measure that.

And depending on since this is in line, it'll get caught by that top level profile. And I should just be able to see, okay, sort by thing. Okay, so it's saying that a guy called three times the minimum time it took was to millisecond, half the time it took at least 2.78, etc. So that's fairly expensive one, but remember, I'm doing recursive calls to render data here. So even though it says this particular algorithm is slow, a lot of that time is probably being consumed by these recursive calls to render data. Okay, so what else can I do here. So that's, that's sort of the measurement technique that I'm going to play with to figure out where my hotspots are. Because it's not, it's not profitable to, to do changes to the code unless you just have actually measured a place where it's where it's good to do. So. Now, when I'm looking at this in react, the the thing that I'd like to avoid is like when I fold or unfold this particular node, I don't want to even look at all these other notes, right, that's a lot of what the overhead is going on here is it's actually running code to generate virtual Dom to then diff against the real DOM, which is just a waste of time. Most of these nodes haven't changed. But I can't do that the way this is currently written, because this is currently written as pure functions, and there is no kind of should component update around these. So I'm going to flip back to my actual start to fix this here. And we'll see, see the kinds of things that I've done to kind of refactor this to try to pull out pieces. So to clear my notes here. Okay, so where did I put in some measurements? So I've got the top level render data. And then what I've done is up here, render map I made instead of having this be just a pure function, I turned this into a component, a map component. So I can add a should component update element to it. So I'm going to comment that part out yet. So far, and then I profiled this, this, this call here saying, Okay, I'm rendering a map. So how many times do I do that? And how much does it cost is what I'm measuring there. So if I come over here, let's reload that. And then let's reload the app. folder, open our problem child.

And then look at our stats, some apps are getting called a little over 1000 times, which is what we expect, we put 1000 things in this table. And then there are other maps up here, right, so there's the remainder of them. And we have to be careful about looking at the total here. So the clock time was 3.4 seconds, but then we over counted, because some of these things are nested, right sorted, one is inside of, etc. So so we kind of added up more than we had. But if you look here, some of the calls to map, in fact, quite a few of them, right? The average, they're very quick, three, five milliseconds, right there, they're not a whole lot. But since we call it 1000, times, it ends up adding up, you know, the average is just three milliseconds. But then, of course, since we call it 1000 times, now we've got react in the background doing a bunch of diffing. And that's going to kind of eat us alive. So when I look at this, the the thing that occurs to me in the case of fulcrum is that this is a table, which means its entries are going to be keyed by some scalar value. And then the value itself is largely going to be a map that contains scalars or idents. Right? So I don't really need to walk any further recursively in these data structures, if what's here looks like one of these leaf nodes, right. So what I can do is attempt changing should component update of this thing that I've just made, which is what I had already done, to try to prevent react from having to do any work on a component. So should component update gets passed new props, we're not using component local states, we don't have to worry about the new state. And we can get the old props by calling print props, or props on this focus primitives, props on this, this is a phone call to App inspectors. And so I've got the current search term, the current listings, or expanded the current content of the node and the path I'm at. And I can get the old version of of those, I don't expect the path for a particular node to change, right? It's a path in a data structure. So if I call the same node twice, I should see the same path twice. So and I've added a kind of a should component Update Profile marker here, just to measure how long the should component update check takes now, when should I update this particular component? Well, I should update it if, let's see, no. So I'm going to check here, I'm going to turn off this leaf thing. So if the search hasn't changed, right, I'm going to have to, you know, render it if the search changes. If in this Remember, this is a set of pads that are currently expanded with these little things. So if if my status as an expanded node has changed, or content has changed, right, if any of those is true, I'm sorry, opposite, right? If my contents the same, and I my expansion hasn't changed and the search hasn't changed, then invert that. And I don't need the order there. That was an earlier play. So this is this is one kind of should component update. I shouldn't bother updating. If searches the same contents the same and whether or not I've I've changed is the same and we're gonna find that that's Actually problematic I think. Okay, so I'm going to click on this node, and nothing happens. And the reason nothing happens is that this guy up here, short circuited, right, so this guy's content didn't change, his expanded didn't change, right? So really, it's whether or not this leaf is really what I'm interested in by saying that these three conditions aren't sufficient because this is a recursive algorithm. So down here in some nested render, that's where I was trying to change the expanded Well, at the top that the expanded check failed, right? It said, Nope, I didn't change my expansion. So you'll see if I fold the whole thing closed. It's burnand CPUs, and fold it back open. That's running an old tree again, now the thing that I expanded earlier is expanded. So that's not so good. So that's where we need the extra, the extra check of, I'm going to tell you to update in less. You're

a leaf. So if it's a leaf, and all these things are true. And I flipped that, then I'm saying basically, leafs shouldn't update and for full grown spec, that's actually pretty decent optimization, I think we'll find out here, right? We'll measure fold something we'll measure lcst was called 1000 times a bit map was only called six will expand. Right? It's not super snappy, but it's also way better than it was. So we went from, you know, 1000, calls to map to 1000 calls to should component update. And we can see that should component update totaled a grand total of 12 milliseconds. And our overall time is significantly better. So let's let's just say, you know, this was essentially true, right? We were always saying it should update. And so if we,

that sort of thing, see the 1000 calls the map, right, we can see, there's there's a big difference here. And so that's a big win for a fairly small change, just by figuring out, is it a leaf, it's a leaf, if it's a map, and everything's a scalar. In the bowels of that map, where it's a scalar, if it's not a map or a vector. And I guess we should be careful about the vector check here. We can make this a little better, right? This is currently buggy. I've made it faster. But if these things had ref two minis or ref ones, in a lot of places, they would still say they need to update when in fact, they probably don't. unless those vectors have changed. So my thing is the content is the old content. Episode epital relief. Yeah. So there's a little bit of work to do here to make this work right in, in other cases, but this is the general idea of walking through here and trying to see, you know, where your performance problems are, how you can improve them. And here that was, that was I have forgotten to clear them. And I'll just a little bit of work. You know, I've already essentially more than doubled, potentially tripled the performance of this of this Data Viewer with just a few minutes of, of measuring and judicious use of should component update.

