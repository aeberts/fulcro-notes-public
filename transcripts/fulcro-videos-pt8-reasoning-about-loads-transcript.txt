In this video, I want to continue talking about the full stack story. Hopefully this will be a little shorter than the prior two. But I want to talk about some of the nature of distributed systems and how foco deals with them. So the fact that you're on a client, well, first of all, I want to get on a soapbox for just a moment about the concept of subscriptions. A lot of people ask about it, subscriptions are something that you can implement as far as the UI and network protocol goes and full grow very, very easily. The difficulty with subscriptions is the same thing that everybody else struggles with. And that's how do you figure out on the server, that your data is stale in order to push it? So some answers are well, we could watch the de Tomic transactor. Log. I'll try that. See how it scales? Not vertically? Or up sorry, not horizontally. We could use Firebase Oh, great. A document database. Okay, how many database features Did you need? It's a hard problem. It's not something that full crow solves, nor do any of the other systems, the only one that comes to mind that actually does any sort of job for it is Meteor. In terms of like a whole web based framework, and you have to use Mongo for it to work. And Mongo is a document database, atomistic, concerns difficulty doing all sorts of things. So it's got a very limited applicability focus, trying to be a general purpose tool for writing any kind of app. So if you have a database, that can tell you such and such as out of date, it's very easy to set up WebSockets and Velcro, push that data use the merge facilities you've already seen. To make some subscription system work. It's it's, it's trivial to code that part of it. The hard part is figuring out when your data is stale. So let's deal with what we're actually going to do, what we're actually going to do is we're going to pull data on some sort of basis, typically on demand to the client when the user has expressed a need for it. There are some cases where we'll know we we've got data to update and we'll be able to push that, again, it's a separate concern, most applications are going to be operating in a true distributed mode, where their copy of the data can be stale relative to what's on the server. Even in Meteor with automatic pushes you are sometimes in that state, right? There's there's a nonzero lag between the time you figured out the data changed, and the time the client got to see it. There is no acid compliant full stack framework. Sorry. That's a very, very, very hard problem. Having some horizontally scalable, millions of clients supported where everybody's data in their browser exactly matches what's on the server, it's a pipe dream doesn't exist, stop asking about it. work in the real world. So the real world is this data on the server can be out of date. So how does Falco deal with that? So here's the basic heuristic, and you should be aware of it because you're gonna have to deal with this. And you might choose to structure your app or code your app differently based on requirements for your own data model your own data consistency, your own specifications. So focus urist, ik is quite simple. And it does kind of the minimum amount that makes code makes sense. So let's talk about what that is. So when you run a query to the server, you're asking for very specific data. So if I go in here and look at the, at the client, if I go to load, person list item, right? Say I'm trying to refresh this is exactly refresh person one, right? And no excuse for you have to be in a closure script repple to run that. So I can run that and you see it, it pulled up, pull the name down. And if I rerun that, of course, nothing useful is going to happen because I've kind of got the updated name. Now if I go over in the server and emulate changing that person's name to Tony, Ron rebel, changing that person's name to Tony, changing that person's age to 99. And come back here and run this load again. Well, helps if I use the right repple on this load again, I see the name update. Sorry, I was tinkering with this before I started the lecture and things were already out of date. And I've queried for it. Let me reset the database.

We should have Bob and whatever. Oh, I've got that def onced. Alright, Bob is 22. Okay, that's the starting state. So if I go over here and I change the name to Tony and the age to 99, I come back to the closure script repple in the closure script file and run this load, it works. It should have worked as expected, did I actually run these in the right repple?

Warning, this one on the right repple the person was tight on the person list item is asking for person name, I really should see that updating, I'm not sure why I'm not seeing that updating. Because it's not changed in the server's database. Oh, shoot, I hit a keyboard shortcut I shouldn't have hit. And I think I mentioned in an earlier video about having stale stuff on the server where I couldn't reallocate the thing. That's what was happening. I was actually, I'm actually talking to an older version of the server that I can't reach anymore, because I've loaded the code overtop of it, but it's still connected to the existing Old Port. Let me go here, start the server, Bob 22. Going to this namespace, change the name to Tony the H 299. closure script namespace, run our person list item, we see the name change but not the age. So this is what I was trying to demonstrate right, I've done a query that's only asking for the name, if I look at the transaction, that's exactly what you expect, should have been sent. And so that's the only attribute in my local database here that changed. But now it's out of sync, right, I've got a person in my application that is being displayed to the user in a form that never ever, ever, ever, ever existed in that form in the real database. But this is really the best Volker can do. That's what you asked for. That's what it gave you. You have to keep track of the fact that Oh, I've got this other thing on the screen. At the same time, when I do loads for this person to refresh them, I probably ought to use the one that has more details in it. So same thing can happen if a particular attribute disappeared. But let's let's see our our real thing that we probably wanted to do here, and that was we probably wanted to query for person to tail. So if I run that query, you see age update, because it asked for the right thing. So heuristic number one is full CRO will not remove or modify anything. In your existing database, right person had stuff in it, it had all these things in it. I only queried for name. So name updated. But it didn't touch cars. It didn't touch age, because they weren't asked about. So I don't know anything about how they changed. It makes no sense for me to remove them, it makes no sense for me to update them. One could argue that it might make sense to remove them. But because you have things potentially on screen that are showing those details, it's really up to you, the application author to decide whether or not that's appropriate. So kind of garbage collection of attributes is a problem foco can't solve for you, because it doesn't know what you're thinking. Right? It's to do what I say not what I mean, as most programming library libraries should be. So now the question is, what happens if I do query for something like age, and I don't get a response from the server on age? Well, in that case, the server is indicating to me that age really has gone away, and I should remove it. So folcroft has internal logic that handles this case, which is is a separate case that you have to explicitly handle on the merger team. So if I disclose this, the server now age isn't there. If I go to the closure script side and run my person to tail query, which asks for age, you see age disappear. And you see on the network, right, the request was for person age. And the response didn't say garbage collect age, it just didn't bother responding with age because it wasn't there. So this is an explicit step that folk road does for you that you can actually turn on or off. And you can read the doc strings and such to figure out how to do that. Most of the time, you just want it on, right. If you asked for age, and the server said, well, it's gone. You should remove it. And so that's the default behavior of load infogroup merge components, a different story, it behaves slightly differently. But I may actually add to the API's a little bit to give you a little finer grained control over that it's just not come up and so I've not bothered implementing any Find a green control, because what's here has worked for quite a few large applications that I've worked on.

Okay, so that's the, that's the heuristic. It's essentially, if you ask for and it doesn't come, drop it, if you don't ask for it, leave it alone. And that can lead to mismatches in in, in what your UI is showing versus what's actually in your real database. It's a distributed system. These are issues you have to think about whether or not you've been thinking about them in other libraries, frameworks, or what have you. You've always had this problem as soon as you moved data to a client in Java and used it in JavaScript. Really, even back in the days of you just sent a static page that had derived data from the database, the database was still changing. So you've always got to deal with this problem. This is just the nuance. Because of these queries. You have a specific accurate way of asking for just what you need. You have to think a little bit more about the nuances of what did I ask for what did I get and does my database still make sense?

