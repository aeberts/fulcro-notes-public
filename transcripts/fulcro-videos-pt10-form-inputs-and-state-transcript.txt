In this video, I want to cover an introduction to form support in Fulcro. And I want to prefix that I said form support, there are some helper functions in full Grover forms. My intention is that if you want full featured, crazy, you know, widget building forms, libraries, that that's something that you need to build yourself. There are too many variables for a library like full crud to try to be the end all and be all forms. You want to render them in different ways, you want to validate them in different ways, all this code, typically, you can, you can start with some, you know, get started quick library, but typically you'll you'll run into problems extending those, etc. I just don't want to be in that game. So I do hope to contribute us, at some point will will build some nice, you know, rapid application development form system. But for the moment, you need to know how to deal with forms and form values, so that you can write your single page applications with focus. So, with that, let's start off with some basics. I want to show you what I've set up here, I've changed the project, the demo project that's available on GitHub. If you look at the videos, you can see links to to these files, there's going to be on the forums tag, or forums, one, I'll label it, of course, in the repository when I'm done. And so we're first going to look at item clj. This is my my database. So I've set up a simple, simple atom based database. Again, like I did in earlier demos, I've imported the project. And I've got the dev dependency turned on so that when I start my closure environment, I can start a server just by running restart in the user namespace, that'll reload code and, and start the thing that I'm going to Port 3000 index HTML file name is required because I haven't dolled up the middleware at all. And this will render the app. So get this database, I've got a resolver for getting individual items. This is similar to what we saw earlier, ideas and input. And then this can output the rest of the attributes real simple implementation. All items resolver. If you query for item, all items with no inputs, you can get back all the items in the database, and I sorted them by item ID just to keep the list consistent. Well, I only have one, so I guess it doesn't matter. Then I stack the resolvers. And there are no real other changes to the server other than deleting the other examples that I had going from prior videos. Now notice that my database, if you're using something like de Tomic or Postgres, or any decent database is going to have the support for a fairly wide range of types. You know, if you go and look at the Postgres data types page and the actual documentation, there's a huge array of data types. Everything from you, you IDs to arrays to geometric types. And of course, using de Tomic, you have a number of these you have big decimal, which is a decimal type, you know, here, we can get accurate numeric representations, etc. Now, one of the things that I'm interested in when I'm dealing with a full gr application is that I've got this language closure on the server side, I've got closure script on the client side, it would be nice if things just behave the same in both places, unfortunately, do some slight language differences. closure has big decimal support. That's what the capital M at the end of this number is for arbitrary precision numbers. But JavaScript and closure script for that matter, do not have a standard representation for those. Although the transit protocol that folklore uses to communicate these things between the front end and back end does support these data types. In fact, that supports instance, so you can go from a Java util date on the JVM to JS date on the JavaScript and vice versa, right, those will transfer over which means it's possible for me when I load these into my app, so I can go back to client here and show when I start this application, that's for later on, my client-did-mount I load all items. And I'm just asking him, he gets, you know, target that at this component. So they'll show up. And of course, that's putting things in my database here. Now, the interesting interesting thing to note, of course, is that since my database is giving me the raw database types, that I would get, say if I queried this from Datomic directly, or even Postgres, I believe that a lot of Postgres drivers if you if you query a decimal field type, you'll get a big decimal Java, you know, Java util, big decimal

out of the JVM. And Fulcro actually transmits that across the wire, RV cognitive transit, which supports those types. So if you go look at the transit documentation, right, you can see what what data types are kind of standard supported. And it's, you know, it's a fairly rich set. And this is extensible. So you can add your own data types, you get something, you want to throw in a class slash record, go for it, you can just add extensions, to both the client side networking, and the server side networking at the cognitive transit layer. And then your types of going across. For the most part, the data types are rich enough to support most of what you'd have in forms, right, big integers, big decimals, symbols, keywords, like, you know, etc, things that you would have in state in a in a common closure application, even ratios. So, what I'm interested in when I'm building forms is, you know, where we were in the 90s, way back in the day, right is we had the data in the database, and then we generated the HTML on the server. And we knew, and this is something a lot of people don't, don't always remember. But inputs no matter what data type they are. So let me go ahead and show you what I end up with here. So if I, if I run this, I get my query. I've got my item by ID. And notice here in state, I have this thing called a tag value, which is the way cognitive transmits complex data types. F is the tag for big decimals, and then an actual string representation of the number because that's the only way you can carry that around in JavaScript, with any accuracy knows that my n stock number is it is an integer, and then my title is a string. Now, if I make an input here, in my UI, which I've already done, what I'm gonna do here is log to the console, that type of the value I get back and EBD target value is simply a JavaScript, right, it's taking the JavaScript event, and it's asking for the target, prop and then the value prop. So that's just the normal, you know, you'd write this in JavaScript is as EBT dot target dot value, right, that's, that's the equivalent notation. So there's just a helper function in the events namespace of fo grow, that lets you type that without seeing yellow everywhere. So I'm going to log the type of that, and I'm going to call set value, which is just a little helper in the mutations namespace that can set a particular property on this. And I'm going to pass it the event target value. And so if you watch closely here, even though I've called this a numeric input, if I change this number to 34, eight changes to a string, I reload, I use these increment decrement kinds of things, and immediately string. And that's true of all of the input types. So take the set value out of well, now let's leave the set value in there, what the heck, if I change this to a date, Ctrl, I get a date string, if I change this to a time control, etc, local time, whatever, these are all, these all come back with strings. That's not ideal for what I just said. Right, I would probably like to say this is a number of input because it gives them nice increment decrement little buttons on their, on their thing, if they want to do that. But this generates an inconsistency between my client and server, my database now doesn't have in the client that the same data type as the server. So this is really the main thing this particular video is about is I highly recommend that when dealing with forms and full grow, that you make your data types in the client database, match exactly the data types in your server database, so that you don't have to think about these things as you go, right. As you scale up to a larger and larger application, you build more and more forms. It's nice just to have some pre wrapped functions that do this stuff. And pre wrapped controls for that matter that do this stuff. So you just don't have to think about it. So for numerics, this, this one's pretty easy. For integers, there's already a helper function. And it even understands JavaScript events for you. So you can just go to this extreme. And now if I change this number, it's an integer. So you can see that street and state that that's, that's being maintained. For me, if you go look at the code of this, it's really simple, right? It just calls this ensure integer function that's got a closure and closure script version that just parses the thing back into an integer. And in JavaScript, you know, if you try to put letters in here, I'm trying to type ABC right now and nothing happened, right? So

and if I get back to nothing, I still get zero in my in stock field there. So so that's a reasonable thing to do. So then on the numeric This is a big decimal. So this presents a little more of a problem. And so I'm going to output that column. And you see if I output that as a string, I actually get the, the cognitive representation of that. And I could go and grab the underlying value. But I don't love that either. And, in fact, what I'm interested in is making this something editable. And you can already see that editing, this isn't going to be particularly great. So I just recommend that what you do is make something like this.

Call the stuff up and take it up to the top. And then this becomes

Yes. So let me talk about the pieces that I've got here for you. To helps if I require that. So I showed this in an earlier video, you may or may or may not have watched. So I'm pulling in a couple things here, I'm pulling in react number format, you can look that up in Google and look at it's just a react control that can format numbers nicely for you. And you can see it's doing a nice job here. And then big dot j s is an implementation of big decimal for the JavaScript VM. So I'm pulling both those libraries and to give myself some tools for dealing with these things in an isomorphic way. Now, closure and closure script. You know, if you've used them for a while you understand that there's almost no syntax, right? There's, there's very little in the way of syntax, and you can name functions, almost anything you'd like. So in fact, things like plus are just functions. So the next thing that I've done is I've created a math namespace, that's a clj. c file. So this is the same in both. And unfortunately, in closure and closure script, there are a few functions that just simply aren't, they don't work identically. And sometimes you need a cognitive version, like a transit version of a function, because there just isn't one on the JavaScript side, etc. So, so this is the basic idea. And I've pared down this namespace from what I actually use in the in the real project this came from so it wouldn't be too big, and wouldn't have too much stuff in it. And then I'm excluding from closure, plus, minus multiply equal less than, here's, here's through I guess I did leave them Nevermind. Then I'm going through and making some helper functions. So one of the things I need and this greater than deafen is part of ghost wheel, it's a thing that lets you write your specs for your incoming argument and return type. It can have your F spec right here in the function. ignore that for now just happened to be what we're using in the project that I took this from. So I didn't I didn't go back and edit it out. I guess I don't have Oh, I do, I do have that declared. So big decimal is declared as something that were this predicate, which I've defined in here returns to. So big just a string takes a big decimal and can return a string. And so this has a closure script and closure implementation. And that's if it's not nil, otherwise, you get back an empty string, the decimal question mark closure and closure script, etc, etc. So I even have in here functions for comparison. So equal less than less than or equal to I'm using a font here called I think Fira code that has like a little ligatures for these guys. So this is, this is actually two characters, but was there their jam together, it makes them look nice. So I'm defining these as functions for use. And then I've got subtraction, etc. And again, a closure, right? closure core minus works fine for big decimals on closure. But in closure script, I have to convert it to, from the JavaScript form into the transit form. And then or vice versa, actually, anyway, you get the basic idea, do the math, give it back. We've got quite a few tests around these things. And I chose div here because I like to use these with a namespace. It's not confusing. So see over here on the client I wanted to that's actually changed that m is what I usually go with for that. So in a closure repple. Alright, what did I do wrong? Oh, I might be already using that for mutations. Nevermind. So I'm just gonna open up a comment here. And same slash plus three m, three m, and run that, Oh, I'm not enough, sorry, I have to go to the math namespace for that, which is going to be less educational. Trust me to say that this works the same in closure and closure script. You can play with this on your own. I've also got that closure script repple here. And the point here is, I get back a tagged value of six for that. And I can use regular numbers with this, it'll mix them, it'll match them. The syntax of em is supported in closure script, but if you use it out by itself,

there we go, it comes back as three. So so that's where like the regular Plus, if I say plus two and three m enclosure script, I get back five, well, that's not what I want. I want math plus, to give me back a big decimal so that I can then further say, math times one point, I can use whatever I want here. 1.22 might be an inaccurate number, if I don't put it in a string, which I can do, right, these things just support coersion and, etc, isomorphic Li. So that's the basic idea. And then I have conversion functions to to go to and from strings reliably. So now, I'm ready to deal with the fact that an input here is going to give me a string. And I'm going to have a big decimal that I want to feed a string into that input. So I'm going to go down here and I made a UI editable money input here. And this is a def SC that does not have a query forgot to start model pointer thing. It has a net local state only this is a basically the placeholder for constructors on component classes. And so what I'm doing here is when you return a map here, this sets that in the component local state, I generally don't recommend people use component local state. But I'm going to talk more about managing form inputs more in later. Later videos. In this particular video, I'm just using this for convenience, because it's really fast to code. And this might even be the way you'd want to code it. So on double click, I'm going to set the state of editing to true, that's going to change this, you know, get state this Boolean will be true now. And then I can switch the display type of a react number format control between input and text mode. So over here, I can double click on this. And now it's now it's an input mode. Now what I'm interested in this, this UI number format deals in strings, like if you look at the documentation, it's got an on value change, that gives you back a V thing. And the V thing has a dot value, a dot float value, a dot formatted value, property. And so I'm using JavaScript interop. So let's actually look at that react. Number formats. If you're going to use react controls, you have to be careful that when you put in a callback, you're going to get JavaScript values, that's what you're going to get. There's no there's no glue in the interrupt helper to unwrap those because there's no place to plug it in. So Well, technically there is but it would be, it'd be a bit of a hassle. So you could do it. So I'm looking here, it says on value change, accepts values object, I click on that it tells me it's this, this is a JavaScript map. And so I'm looking for this string value, because that's what I care about. I can turn strings into big decimals very easily. This may not be an accurate number, right, it could end up with point 56000001, or some crazy thing like that. And of course, I've got the formatted value. That's the way the string was displayed in the control. So if I take that string value, then I can use my math library here to turn that into a big decimal, and then call an on change function that's being passed to me via props. Now, notice here I'm not using computed if you've watched other videos, or read in the book, if you don't have a query, and you don't have an ident, this control is not refreshable on its own, the parent will always be the thing that's refreshed when you use something like this, you will get should component update optimizations, like if the props don't change, it won't bother going in here. And like that's a react optimization. But you can use def sec to make these kind of pure components that are still quote, stateless in terms of fulcrums application database. So I'm saying I want to use this thing, and I should take the key functional third, because that doesn't make any Since for a stateless one either. So I'm basically saying, you know, this control can be used. But I could have just as as easily said this was a dead end of editable money input and then drop the factory. In fact, I think I'll do that because there's really no no I want local state, there is there is a reason to make that a component, I want component local state for playing with

it. There's my reasoning. So essentially, the trick here is make the value that's in your database, a string so that the input gets a string, because all the inputs want them as we'd like them as strings, and properly format a string, if you're making a date input, you're going to do a function that convert your instant or whatever you're storing in apps in your application database, into the string that the control wants to show. So So we've essentially moved, what was, you know forms on the server where you were generating the form, you were plugging in your courses from the database, putting in a string on the input, putting it on the web page, they were submitting it, it was coming back as a post where the call the crap was strings, you coerced it back from a string into that we've moved to the to the front end over time over the years. And then we had, you know, jQuery or whatever that was doing some of this wrapping for you. But a lot of the rest stuff is still this, let's shove a string across, let the server convert the string, I'm saying in full grow, switch your thinking around your thinking should be it's in the database in this format, I want to transmit it on the wire. So that ends up in the client database as that thing. And the only place I'm going to do any coercion is in this one little UI control that I build and reuse everywhere that deals with these type of fields. Right, so I write this UI editable money and put once I put it in a components library, now anytime I need one of these, double click on it, edit the money inputs, I can just use it. And I'm done. I'm done writing code. And all the coercion is tied up in this very nice tight, localized piece of code. So we can see this working. Now if I go over here, I've got tagged value, 10, blah, blah, right, I can edit this I can put in, you know, whatever I need, I can go way beyond the number of digits that JavaScript can handle normally. And I can basically, I've currently got this setting the value onto the server over and over again. Now I can reload this and I get back that exact value. So that's the basic idea in this video is, is the first layer of forums is realize their strings. Manage your database with the correct types.

