In this video, we're going to flesh out the rest of our demo here. And our full stack forms. We've got loading going, adding a little bit of additional, I've gone ahead and added a number of things. First, let me just show you a few of the fix ups that I've done just to make things a little cleaner, I removed some of the cruft code, I added a table cell field function, I mentioned something like this in the last video where you could just make a function that would take a lot of the boilerplate out of it. So that in my table, now I can see I've got a table sale cell field for item title with this validation message in this on change. And then all the you know, all this crap about validation just kind of evaporates. The drop down, didn't have validation. So I didn't bother integrating it because it needs a bit more in terms of options in order to be able to do it. But the the three major fields were easy to do that with and get essentially the exact same result that we already had. So then I went ahead and cleaned up a few other things. So in terms of when to mark these things complete, so validation, that's to show up, obviously, the onblur thing seems fine, and you see some reactions appearing out here. So, you know, once once I've got, you know, once I blurred on something, if it's invalid, that seems like a reasonable time to market valid. And I've blurred these Now, let me go to this one and make it negative, right. So you can see that that's negative, something else that somebody might do is they might press save. So there's, there's a sequence of things that has to happen here where you've got to figure out, you know, when and how to show these validation messages. Fortunately, it's declarative on on this side, all you have to do is basically say, you know, if the field is showing up invalid, render its validation message, that's just all there is to it. So there's no logic in the UI, so to speak, there's more logic in the processing as you move through the thing. So we did go ahead and put an on blur on here to mark complete, but let's just take that off. For the moment, let's just make it so that we're not marking fields complete as we go, which means we're not going to get validation errors. As we screw things up and blur from field to field. Which might be a way you'd like your form to appear. In this case, what we'd like to happen is when we attempt to save, we'd like to see those validation messages show up. So and here, the Save button is as disabled itself. Right. So that's, that's sort of how we typically like forms to behave. So again, this doesn't change in the rendering, we can take this blur out of here. And just not worry about the whole does focus work and out on the browser, etc. kinds of mess that typically, plagues, plagues, people writing browser based software. So the things that I'm going to add here, a couple of UI attributes. So again, these ui namespaced attributes are things that won't be sent to the server on a load. So if I go in, and reload this, and look at my full grow, Network tab, what got sent out four items, Id title, none of those UI things showed up in there. And you can actually extend what it would strip out. So for example, I might want to strip out things that are route queries like this, fortunately, path home tolerate these just fine and just returns, you know, something that's not going to hurt anything. So in this case, I'm not rewriting the middleware to, to fix that. Because I don't have to. So I'd like to know when the thing I'm creating is new, because that has different a different kind of code path, so to speak through through the logic of the forms than not. And I'd like to know when I'm saving, so that I can just show an indication to the user. So I'm going to purposely put a delay in my server side, save just to emulate some latency. So we can see that that happened. And from here, everything else is is as it was in the prior demos and talks, I'm using pre merge to get the form config. And I've just fixed up these table cells, I moved all of the mutations for the client side into the model item namespaces as a CL j s file. So these are the client side portions of the mutations. And so we have remove item is the item valid, etc. I did beef up the item validator just a little bit to catch exceptions, this greater than or equal to math operator if in stock was invalid string was throwing an exception. And in that case, it is invalid but I needed to put this try catch to make that that a little more stable. And then I've

Got some implementation for adding a new item. So there are a couple ways of doing Add Item. One is to actually write a mutation. And you could and in fact, I did in a prior version, if you go back and look at the other videos I have in here, where I just manually created this map associate into app state, I mean, it sort of looks like, you know, a soce. And at item, ID, ID, this map, and then etc, right? Like, do the steps. But we saw in prior videos, that merge component is really built to do this. But one problem we have here is I can't get to the component that I need, through a require because that would create a circular require. And I can't do that in closure script. Fortunately, full curl comes with a central database that components register with when they're used. And you can look up components classes by a keyword that exactly matches their namespace and name and get back the actual class. So I could make this add new item mutation, use this convenient merge component thing, use the append, to plop it onto the end of the list. The problem with this, I don't love this either, is that really, this is a thing that's known in the UI call site where I'm adding the new item. So is the ID, I could wrap this whole map thing in a function that that like, represents a new one. And this path is also a UI specific path. So it doesn't really like this is really a localized concern of the list. And that particular list like this mutation is not going to work anywhere else. So I don't really love that. So I'm going to do instead is in the client, instead of calling add, I'm going to use merge component directly. So instead of transacting that add new item, and then making it like hiding all the details, the details I'm hiding are the details that I only know right here. So I don't want to do that. And that's why merge component exists merge component is, yeah, I'm doing some merge of state that's really UI centric, where I want to throw this stuff in and append it to me at this field. Right. So this seems like a much more sane way of doing an Add Row.

Now, there's another thing that I'm doing here, and I am marking this new but I'm also doing something different here before I had random UID here. And full CRO supports temp IDs. And this is a huge topic in and of itself in a lot of my applications. I actually usually you IDs period. And that's because I'm using de Tomic and can have a UID identity field, you could use SQL and have a view ID based alternate primary key field or primary key field. And that allows me to do everything I want to do. But a lot of people have databases, they're in SQL, they've got an integer ID. And they need some way to distinguish between an ID, the client made up and an ID that needs to be associated with the database. So I'm going to show you this facility of Volker while we're at it. So when I add one of these new rows, I'm going to add something that has a folklore data type called temp ID and this is actually a def record. So if you go and look, you know, it's a def type. And there are transit handlers automatically installed in the middleware for the server, and the middleware for the client that can handle these. So it'll automatically transmit and receive over the network protocol without without a problem and maintain its type. It'll be a temp ID on the server side, too. So that's how we're going to add rows, we're just gonna use merge component. So add a row, I can look, go look in my database here. And if I look at item ID, I'll see I've now got a full grow temp ID with the various things. Okay, so now let's talk about the Save sequence. So well take that back, let's talk about the Undo sequence. So undo has a dependency upon whether or not I'm undoing a change to something like this. And whether I'm undoing an ad. And so let's go look at the undo button real quick. That's it's it's really straightforward. So undo says Well, if the things new, then use this remove item mutation, I don't want to do the bit twiddling here. So remove item is remove the ident from that list, and then dispose the thing from its table. That's really straightforward. And then reset form is part of form state. And all this does is it calls the mutation. Or it is a mutation reset form. And it just calls pristine to entity which you saw in a prior video. So those are the two things I can do to implement undo. So you can see it's very simple. The form states remembering the original pristine state so I can make all sorts of changes here and hit undo and everything goes back to the way it was. So really Really simple to implement that particular functionality, which is nice. Okay, so let's move on to our Savior. So there's several things we want to deal with when we're saving a new thing. So first of all validation. And so when I go to save this, that's when I want the validation happens. So let's let's look at our implementation of save. So save calls a mutation called try save item. Now, the reason I'm calling it Tracy vitam, is I'm not actually going to have this part do the the remote, I'm gonna have this part carry along a diff from dirty fields, which we saw in a prior video, this thing just gives us a calculation of what's dirty on the thing. And this accepts an options map at the end where you can tell it, it's new. And when you tell it, it's new, it includes all fields, no matter whether or not they match what you started with. So for example, we started with zero here, if we don't change that, if we didn't say new entities that in stock field wouldn't appear in the network transmission. So this, just make sure that that dirty fields diffing just thinks everything's dirty, basically. But it still grabs things recursively. Okay, so try and save it. Let's go look at that. So Tracy vitam, just tries to do some validation. So you can back up the video and and look at this, I'm going to go through it rather quickly. But I'm using that trick where I just mentioned a minute ago, I'm using the registry to find the item list item in state. I'm using Mark complete to go through and make sure all the fields on the entire form are marked complete. I'm pulling the normalized entity out of it's a table. So completed state, this is just going to be item title item, you know that that limited amount of stuff. And then I'm using DB to tree to denormalize it and turned into a tree. The reason I need that is my item validator works on a tree of props, and I'm in a normalized state. So that's why I had to grab this, this guy, I should reorder that. So it's more obvious, I need that class to get the query,

I could have passed to the query as a parameter that probably would have been cleaner, I wouldn't have had to deal with knowing what class I was dealing with here. But for the moment, let's just call this good enough. I can call mine a validator. And then I'm looking for it to be exactly valid. So if it's, it won't be unchecked here. Because I've marked everything complete, it's either going to be valid or invalid. So it's valid that I'm going to proceed on to issuing a transaction that will save the item. And otherwise, if it's not valid, I'm going to reset my entire application database to be this completed state. So basically, I'm just going to run Mark complete, I just didn't want to run it again. I mean, I could have said swap, you know, State Mark, complete yada yada, yada here, but this is just push completed state into the application, that will cause all the fields to be marked complete, which will cause the validation messages to show up. So if I go save here, save isn't actually going to do the network transmission, it's not going to do this transaction, instead, it's just going to save the completed state into the database. And that's going to cause the mark complete to change the state of the entire application, which will cause these renders to render their problems.

It's an arm ready. So let's say the thing does validate. If the thing does validate that I'm going to call the Save item transaction with the same parameters that I got here. And remember what I sent from the UI layer was the item ID, sins really, for convenience, it's actually included in the diff. And the diff. And remember, the diff is just like an ident based map, the keys are identical, the values are what changed. We'll see this on the network in just a moment. So save item. Let me let me mention this a second. As your project gets bigger, you want to be able to to navigate on these things. And so if you're deaf mutations, as shown in yellow, I've said this in prior videos, but I'll say it again, you want to grab this the light bulb menu and say resolve that as and then specify def mutation and find the one that's in focal plane mutations. This is the version two of these these are integrated into IntelliJ cursive, but I've not quite I've not gotten cursive the cursive project to integrate the new namespaces. So you can just pick this, it'll an index them. And then I've got a keyboard shortcut for navigate to the declaration lines command to be yours might be something different. And that'll jump me right to the mutation. Oops, helps if I'm on the right symbol. Right. So this lets me this is what's letting me go in here and say, Oh, I want to jump to remove item. Well, that's just data, but it looks to the Id like a function so it's indexed so I can jump to it. So as your as your Project grows, this is a really important facet of being able to deal with the code, you need to be able to navigate it understand it. There's also a Navigate back, which I have set to the, you know, the normal Mac OSX browser shortcut. So I can just pop back to where I was. Okay, so safe. So this is the client side of save. So I've got several sections here. The main action, this is the optimistic action, right, this is the thing that happens immediately, as soon as the transact starts processing this transaction. And what I'm going to do is I'm just going to set the UI saving field to true over in the client, if we look for saving, all I'm doing is on this button, semantic UI has a class you can add to a button a loading class that will make it look like a loading button. So I'm just saying while saving, add the loading class. So that's all I've got to do to make the UI change. So over here, update UI saving on the item, I'm good. Remote true says this is a full stack up. And since I'm not modifying the parameters or anything in this remote section, I'm just saying send it like it is I'll get the item ID and the diff in the server. The okay action error action, I think are new in this video series. I may have I may have mentioned them briefly and fullstack mutations, but the okay action will happen when the remote finishes with out an error. And the error action, obviously, when there is an error. Now, one of the things we have to define here is what is an error? Let's hold off on that for a second and continue through this this sequence of happy path. So if it succeeds, okay, then what I want to do is update the item in the database. Remember, we're normalized, so I'm going to a table entry. And I'm associating into that table entry, newest false. So making sure it's not marked as new still, and saving as false. So the spinner will stop on the button, then I'm copying the entities value into that pristine, state the form copy for that item, so that it won't look dirty at all, that row will just look clean. And again, the will not maybe again, the controls for save and undo are only visible when the things either new or it's dirty and dirty returns true if and only if there's a difference between the values in the entity and the value saved in the form config. And this one works independent of current state. So that's why, you know, I see, you know, as I change these, if I put the E back, take the easy way put the E back like it's it's detecting that, Oh, well, now, it has no reason to save it, right. There's no code I had to write for that. It's purely declarative. If the things dirty, show this stuff, if the thing is not dirty, don't show this stuff. And I've got a copy of it. So same thing here, I can completely modify this stuff. And that's also why I get the the Undo right, I can copy pristine back to the entity. Okay, so this one's new. So it doesn't matter what I do to this one, it's it's going to be showing these row actions until I either say undo to remove the row or save. Alright.

So if I do hit save, now I'm going to get remote true, it's going to do this okay, action, it's going to when it gets a return. So let's see the sequence on the client side. So again, on the server side, I've got a 500 millisecond delay, I'm going to go to the network, tab afoco. Here, hit save, you see that in the transactions, there was a try save. And then there was a save on the network, there was a save the Save got the diff that had all the stuff in it. Notice the temp IDs. And then the return value of this has the item ID that was assigned. And then this is a special key temp IDs. This tells folco that anything in the app database that has this value, this temp ID value should be remapped to that, that value. So this is part of folkers support for the temp IDs I was mentioning. So imagine you've got an SQL database, you send this new thing across. It can detect Oh, that's a temp ID. I'll go and insert that because it's new. And then I'll ask the database what Id assigned it and then I can tell the client what that number is. So let's do this again, and show the effect of that. So this is this is kind of an automatic thing you don't have to think about so I add a row it gets a temp ID I put data in the row. I save now watch during the Save.

I'm not sure why that went oh, this is a this is a full chrome inspect issue. It actually remapped the value and you see the thing now has value one folker inspect this tool down here at the bottom actually has to send values across a connection, basically, because they're different security areas of the browser. So the the, the inspect tool can't read the actual state database. So what we're doing is sending a Delta from app state to here to display this really approximation of the database. So the remapping happened, but unfortunately, the there's a little bug in inspect, I think. So we see over here, or rather,

yeah, we got we got the right thing it's got it for if I go and look on the server, and the item database, I'll see it got it for God assigned ID four. And and in the state. If I go look at the just to verify this the what we call route list override component by ID. This list, you knows the items are all correct, too. So item 1234. This was the one that had the temp ID. If I add another one, you see the temp ID in here. Yeah, hopefully, hopefully, we'll get a remapping that, that doesn't get corrupted by that transmission. And you see it remaps to five. So So these are just like, inspect little issues here, unfortunately. So that's how temp IDs work. So really, you've seen all of the client code at this point for save. There's a little bit of error handling here to set saving false but doesn't change new. And we'll talk about triggering that here in just a second. But let's let's go look at the server. So what the server needs to do for saving is it needs to look and see if the things new. So it looks at the ID that it received and figures out well if that's a temp ID than the things new. And so what I need to do is figure out what the next ID is going to be what you could do optimistically at the database level, or you could you could figure it out after the database insert, I'm doing it here, I'm doing anything in here. If there's a category ID coming in, we need to, we need to fix that up the item categories come across in the diff as a as an ident. So we need to pull that out as a category D. So if we find one, then we need to remap it. So it'll be in our correct database format. So I'm basically just munging data here to get it to match my pretend database format. And I've got asleep 500. And then if it's new, I'm associated into my database. If it's not new, I'm updating my database. And then I'm returning my Real ID all the time. And then if it was new, attempt it remap. That's really all there is to it. And of course, now I can reload this, and all of my rows should be there. And now of course, I can change these I can undo those.

Undo shouldn't be working there wasn't undo working. It was now it's not sorry, I've got I've got another issue. But live demos like this often. Go Ryan, in slight ways. So that's what that looks like. Now the other thing that I wanted to talk about in this video is what this sort of save might look like in SQL because I think a lot of people don't really think through how how cleanly this kind of thing can be how cleanly done this kind of thing can be. So I'm going to

for some reason, my my undo wasn't working there. So I'll maybe glance at that. But the the thing that I really want to show as the kind of tie up to this. Let me just stop my repple here and refresh my depths, make sure dev is checked. And if you look at my depths, what I've added here is an h2 database, which is a Java pure Java database that's SQL compatible. That can run in memory completely in memory, and the nice closure Java JDBC library, which lets me play with SQL databases in a nice easy way. So I'm going to restart my repple here and want to talk a little bit about this save just in terms of data.

Okay, so the way we can define a database in h2 and with closure JDBC is I can just say this is DB type h2 mem which close your JDBC supports. And the DB name is demo. Alright, so there's my database spec. And then I can do things like CREATE TABLE, create another table. So I'm creating a category table that has an integer ID, and var char name. Then I'm creating an item table that has an ID, that's an end title that's far char price, that's decimal. When you use decimal with h2, Java JDBC automatically knows to use big decimals to pull pull it in and push it out in stocks and head to false zero category IDs and and that references category ID, this is a very common naming convention, category underscore ID when you have a kind of one to one relation, you know, from from A to B. So I can insert a couple of categories in my database. And notice I can do this by map. I can just name the columns with keywords, values, the correct types, there's a second one, I can throw a wrench in here. And notice I do have to use underscores to match the underscores in SQL because I don't have hyphens. So we'll insert a wrench with category ID. One Oh, right. Yeah, see, I like force assign these an ID. So it didn't return me an ID, I did not a force assigned this an ID. So you see it returning me an ID, which I could have figured out as a as a temp ID remap, for example. And insert that so let's get on here run a query with a join. Write select, title, price ID, category ID name, left join. This, you can imagine, with just some very minor transforms can be turned into exactly what you'd need to return from item resolver. Right? You basically just need to merge these up and turn anything that snake case into hyphen case, or kebab case, I guess it's called and add item to the namespaces of the things that's really easy transform. And so hopefully, you can see that that, you know, query straightforward. Now, I've written a couple of functions, I've got this ID key to join column that can can take me from, you know, item category slash ID to Oh, well, that's item underscore category underscore ID or something like that. I've got something that can take me to snake case on a key. So if I had like in stock, or Qt y in stock, right, these are just letting me go from closure convention names. There's a library for this as well, but I just wrote them real quick. And so ultimately, this is what a diff looks like coming from this application we've just built. Right? So if I change the category, I might get a category name. If I'm associating an item with a category, I'll get an ident here. That's that's the kind of thing I'll get update in Java JDK in JDBC. Lets me say these things via maps as well. So I can do an update on this guy. unsaleable, that's an adjustable wrench and do a query. It's updated to adjustable wrench. I could see Oh, you know what its price is supposed to be 1199. Big decimal. And ask for it. Love 99. So, because this interaction the same thing with de Tomic, right, de Tomic lets you do these kinds of updates with just regular maps of data structures, if we have some function that can convert that to a sequence of arguments to updates. Right. So basically, what I what I need to do to actually affect these updates to my real database is say JDBC, update, bang, on the database, on some table, for example, item and then the changes, title, new title. Price 32 M. Well, that's exactly what I've got this function returning, right? These are my arguments to an update. So if I write a function like this, I can get something that then I can just do a do seek all over.

And then I can use closures apply on JDBC update. To do those updates. And nine, go up here and run By query, and I should see my updated fix. Oh, I should have seen my updated things. new name, new title. Oh 22 there is no 22 in this database.

Yeah, there we go. So you get the idea. So this is what I was talking about an earlier video in terms of what what dif hand you is pretty easy to transform. And just to just, you know, take the point a little further. This is the grand total of code that I wrote to generate something that can then be applied to quite a lot of, of depths. It doesn't quite work out for SQL for everything because you have in too many relations. You have reverse keys. So there's a little more work there to do. But hopefully that gives you a general impression of, of how little code you can write, to essentially get form safe all the way through your application.

