In this video, I'll be talking a little bit more about kind of advanced rendering techniques. This is a revisit of the rendering techniques that I, or the rendering discussion that we had in an earlier video in this series. And I just wanted to give a little more detail and some things that might look like rendering issues to you. And various ways to solve them. I also want to show you some additional techniques that I didn't show in that prior video. So the first thing I want to talk about is react inputs. We've been dealing with this form application in the last few videos. And there's an aspect of form inputs that I haven't mentioned, that I think is somewhat important, and it will show up looking like a rendering problem. So this word happens, let's say you pull in some JavaScript ecosystem input. And it's meant to act like an input, it's meant to show you an input, but it's got some additional stuff built into it. So react number format is an example of one of those, fortunately, does not exhibit bad behavior. In this particular case, form input from semantic UI react does, no, when I say bad behavior, that's not actually quite true. This is kind of well defined in react, how inputs are supposed to work. And if you go and read carefully, the React documentation on controlled inputs, they're always talking about controlled inputs with respect to component local state. Right? The idea is, either you're letting the DOM completely control the thing. Or if you take control of it, you're using component local state to keep track of it. And then at some point in the future, is when you might commit that to some more permanent store. With a library like full grow, we have a, quote, more permanent store. And that's what we'd like to be the system of record, not component local state, because that lets us reason about it more well, more globally as data, while also keeping it local to a particular database table. And that gives us all sorts of nice powers, like for example, being able to manipulate the values of these fields, externally. So for example, if I wanted to increment all of my items in stock that were on screen, it'd be nice to have some button that could do that, if these were all stored in component local state, somehow, that would just be a mess, right? I have to go find the instances of the components in react, etc, etc, etc. So let's not do that, or really what you do on react is you promote it to the parents component, local state, and then let the parent manipulate it. But again, you still have the thing kind of stuck in some mutable cell somewhere in your UI, it's not in your actual data model where you can read about it, or you can keep history of it where you can have tooling. Well, I mean, you can have some tooling, like react does let you like peek into those things via its tooling. But, but we really like having it in the database. So there's nothing wrong with using component local state, if you want to use it, it's not necessary. And I think you'll find a number of benefits. For example, the Global Forum handling stuff that we've been talking about this whole time, really relies on the stuff being in a place that the form system can access it. So it really does give you extra power. Let me show you them to be here. But the, quote, misbehavior that happens. So what I've done is I've pulled in this, this one that I know misbehaves or behaves the way react is designed to behave called form input, I've wrapped it in a regular react factory. And now I'm going to do is go down here and find the place where I've got a text input, and I'm going to say UI input, the value is going to be the title and on change, I'm gonna have to pull the title out, add on change, I'm just going to do this the same exact thing. So I can use either of these fields. So I can kind of see them changing in tandem. Alright, so if I go and start editing, that's kind of what I expect. Now, if I put my cursor in the middle of this word, and I'm just going to type A, you see what happened, my cursor jumped to the end, that doesn't happen over here, I'm going to type BBB. So you see this input, which is a regular folk road Dom slash input, which is just really, you'd think it's just doing a react create element underneath. But in fact, in order to make this work properly, because of how react works with these, there's a lot there's a there's a bit of extra code in there. So if you go and look, well, you can go and look in the source yourself. The fix to this, if this happens to you is just simply to use a react input factory react input factory uses the additional logic that folk row wraps around normal react inputs to fix this problem. So if you change that to a react input file, I don't know if that will remount the components, I'm going to reload the page just to make sure.

And I go in here and type A, you can see that now it's working properly. So that's that's just one aspect that you might or one thing that you might run into that might make you think something screwy with rendering, when in fact, it's just, it's just sort of an internal way react works, and some JavaScript ecosystem things work. So let's strip that back out. So it's not kind of cluttering up our, our example here. Okay, the next thing is I want to revisit derived data. So to do that, what I'm going to do is I'm just going to add to the footer down here, a total of the this in stock column. And I've already typed that up, so I don't have to. So I'm basically going to item list, I'm looking at all items, I'm running a reduce over those and adding up the end stocks, numbers, and then I'm going to change over to a rendering of the footer that shows items in stock 36. Now, I showed this problem in an earlier video about rendering, and I want to revisit it because there's several ways of solving this. So you can see, as I update this, this number in my my UI things aren't happening, right. And what I had here, sorry, this was

onchange.

Actually, I think that's what

so that's working. So the problem here is set integer, when you transact, which is what sets it up does an integer conforms or forces the the value to a real integer, then it calls set value. And all set value does is called transact. transact guarantees that it will queue changes for the component You're in for refresh, and we're using the iden, optimized render for for growth three. So that also means that focal three will will do an optimized scan for components that are on screen that should be refreshed, based on what they've asked for. So that's that's an important point to stress. Again, as well as remember that nothing is going to refresh if it doesn't query for the data that it's using to compute values in its UI. So if I were to compute this total by reaching into the app database, and not have all items in my query, then I wouldn't get refreshes here, I'd have to do something like override should component update. And, you know, previous props previous state, true, I just have to force it to let that guy update every time. That's not a good solution, because it gets rid of optimizations we want. So focus really is designed around the idea that you query for the thing that you're dependent upon. And then you only render things based on that data. And for the most part, foco, three, can figure out what to refresh. But in this case, you'll see that as I change these values, right, the items in stock and changed. And that's because this derived data can't directly be figured out. Right? You wrote it in code. So foco can't follow any sort of like graph of data and say, Oh, yeah, you're using in stock in what this function. Yeah, that's not a reasonable thing for for folks to even be able to do. So one thing you could do, and this is probably the easiest thing to do is you could change your optimized render to keyframe render. So if I do that, and you saw it update from the hot code reload, so that's not really an indicator, if I do that, I still have the problem. Oh, because I didn't restart the app, I do have to restart the app to re Enter to install that render. So now you can see that because it's rendering from route. And we saw this in the primary rendering video, if I were to list out the things that are being rendered here, the these individual line items, only the one I'm changing would actually have a DOM diff applied to it. So there's quite a bit of optimization still here. So that's one way of doing it. You can get your derived data renders just by saying, Oh, I give up I don't want to think about it. I'll let I'll let folker just render from route every time that guarantees your derive data, as long as you've used the query, the prop still have to go through guarantees that work. So that's it. Let's go back to idun, optimized render. And we should basically what you've got to do for this, you've got to tell, full grow where the transact happens that there is someplace in the UI, where derived, a derived calculation is being performed based on the data. And you do that based on the keywords that are queried for. So in this case, we've got item list all items. So for example, if I hit undo here, that should also change these things. So what I could do on these, these kind of line item buttons is I can add in just item, list all items, item, list all items to my transaction, and then indicates when I use either of these transactions, focus should go and find any components on the screen that query for all items, and refresh those two. Now my problem is, I'm using set string here, I'm not set string set integer here. And that doesn't give me any way to hand off one of these indicators that dependent data needs refreshed. Part of the reason for that is these these set functions aren't meant to be used in any way that isn't completely local to the component you're dealing with. So what you could do is, you could write your own mutation, updates, quantity, and then you can actually either put your own sorry, that's a different thing. I didn't mean to have that here yet. So let's let's do that.

So I can call up dates quantity, with my item ID and my item in stock to the new value. Do I want to do the coercion here, there.

I mean, one could argue that, that the coercion should happen here as well. And so there's the set integer function, you see, it uses a helper function call to ensure integer that's defined in that same namespace. So you know, so I could sort of do this mess, anger on my set integer, and then I could list the data dependency here of item, list all items. And now once I've done that, I get my appropriate update. Now, the thing you saw me erase here just a second ago, is I can also say, refresh in the mutation to indicate data dependencies that I know happened to be laying around. And it doesn't matter if those happen to be on screen like this is just a suggestion, this is go find anything on screen that queries for that, and update it, it's not gonna remove it from there. And I should have something that still works. Okay. Lots of trade offs here, there's one additional thing I could do. So this was a little bit of mess. And it's a little, it's a little sad. That said, an intro doesn't let you tack these in. Someday, I might decide that that's an okay thing to add into these functions, I really don't want you using these very often. Because what I'd rather see when you're doing something that has a more mutation effect is writing mutations so that you see it in a semantic way, as opposed to just some number changing some set editor flowing over your transaction in your tools. So if you get out here and into inspect, if you're using set editor in the transactions, you see, you just see set integer, you don't really know what what's happening here. Whereas here updates quantity for item two, four in stock, that's really obvious. So that's the point I'm trying to make. And, and that's the reason why these in principle, don't have a whole lot of features to them. But this is kind of ugly, too. And so there's another thing you can do. And that's that you can do an empty transaction that does nothing more than one of these follow on reads refreshes.

And so now you could use set editor, wipe out this mutation altogether. And this is sort of like your, your I'd like to I'd like to indicate that I've done a transaction that affects this value, even though you didn't run a real mutation in there. That is considered a supported thing. And that does work as well. So a variety of different ways to deal with things when it comes to indicating refreshes. By far, the simplest Oh, and we can also see that if I, if I do my undo now, my my quantity goes back here, right, because I have listed that down here on these. These undo features, you've got a variety of ways of dealing with derived data refresh in the UI, the easiest by far is to use the keyframe render, and let it render from root every time. My personal measurements are somewhere in the neighborhood of of, well, it's significant, the item optimized render is faster. And it's it's faster in a in a statistically significant sense, is what I mean by significant, not large, both the IDE and optimized rendering key for your render, and my measurements on my machine will do better than 60 frames a second easily. I think the overhead for the IDE and optimized render is maybe point six milliseconds, whereas the keyframe render is maybe up to two milliseconds, something like that. It's very, very small levels of overhead. But then how much work your react side has to do to walk from route, even with the should component updates, that's what can vary kind of widely. So if your UI is not very deep, in terms of layers down, the keyframe render will be plenty fast enough, and then you won't have to worry about this derived data stuff. If your UI is somewhat complex, or grows over time, which obviously will, either an optimized render is not a bad idea. But, you know, I can't really promise one way or the other, that it would, you know, the keyframe render wouldn't behave well enough. So you have options and you can also of course, define your own render optimizations and plug them in. Thanks for watching.

