I was I was discussing some of the differences between repayment and Volcker with someone and and we were talking about, you know, one of the existing still pending things that I haven't implemented in folco, because I don't really know exactly which way I would like it to go, is some sort of reducer mechanism, sociable some sort of reframe, like I've got derived data, I'd like to have something that computes that through a sequence of steps. And I generally don't personally use such a thing, nor do I have a great use for it. And a lot of the apps that I write, but I do see the advanced stuff. But I also see some of the challenges with you've got this disconnected system of things that that run calculations, and it's kind of hard to trace those. But I sat down and just tinkered with a little bit, what it might look like, for phulpur to support something like this. And it turns out would be rather easy extension for Volker that I will probably add at least this hook for so. So what I've done in this little branch, is I've created a, an extended option for full growth. So this is a def card out of workspaces. And so these are the options you send to the app. So pretend like Velcro had this option, which currently doesn't have the sort of released version. But all it took to add this was to go to the application namespace and add a T hooks, TX hook entry to the algorithms and add a TX hook entry to the list of options like that's, that's literally the, the change there. And then dropping it into TX processing in the thing that does this step by step through through the nodes. So basically, this is the thing that processes each node of a transaction. And so this is grabbing the state before running the processing of that node, right, optimistic updates, queuing network sends, sure reading results, seeing the state after all that stuff's happened. And then if there's a TX sock running it, that's all the changes I've made default grow here. It's, you know, roughly what is that three, four or five, seven lines of code. And so this gives us a way to hook into the transaction system, the transaction system is pluggable, you could redefine all of the logic for the transaction processing. But in this case, really all we all we care about is being able to know I did think about using the state atom and a watch on that, but watch on the state atom, it's to fine grained I'd rather see, you know, a whole bunch of like a unit of processing around like a mutation node is what triggers the transaction hook, as opposed to every little swap and bit twiddle that you do on on state, you know, makes you have to look at what's going on. So then I wrote this little demo app in a card, where I'm adding a transaction hook that I'm calling reducer dx hook just to play with what it might look like to implement such a thing. So I've got a top component here, where I'm querying for x, a sub list of children, and then this general fact I've namespaced into all known Sales Total. It's the idea of all known sales totals, this is going to be some fact in my in my database, that I'd like to come in on this query. And of course, I could make these route and and use it in, you know, Link queries to jump to the root fact. But for this demo, I thought, well, wouldn't it be interesting if you could just say, I want that, and something will resolve it for you. So then now it acts a bit like, you know, beginners sometimes think that the query in a different individual component knows how to get its data straight away without being like co located with something or in a tree. And so this, what I'm seeing here is, let's pretend like we could make some sort of Prop that's just auto resolved. For us, we don't actually, through our mutations, put that there, we just wanted to magically appear, we want to state our intention that we'd like to know the total of all known sales in this top component. Now, technically, I could, of course, walk the tree and calculate them all there in the children. But I'm just going to print it, I'm not going to do any such thing. I'm not going to do any derived You see, this is just a div paragraph, a couple of buttons, regular transact and set integer. Nothing special there. I'm gonna make a mutation for making a new sale. And all it's going to do is call this add sale helper that's just merging a new sale with a new ID and some random amount, which I'm generating here, number between zero and 10, basically. And it's going to append that to, in this particular case, child two's sales.

So that's, you know, straightforward for grow code. Again, notice I'm not doing anything about this all Sales Total. And then up here In this child, I'm going to ask for another, just like generated data. I'm not going to say anything in the UI in the parent, or here about this generated data thing. These guys are, of course, part of this initial state. And they passed down through the initial state of sale. And I'm just gonna show the generated data here, and the map of sales. So walk up the sale, query for sale and sale amount, just showing that I've got those sales entries. So that's actually the entire UI for this application, you can see I can go over here, and I've defined generated data to be 42, plus whatever's in the top components. exe. I'll show you how I did that in a minute. But as I bumped that, you see generated data is showing up in these Moreover, if I go to any one of these children, I can see that generated data is actually being reified on the state of each and every child as I go, and then if I sell something, you can see 29.5 of the total, I sell something that adds a nine, it's not 38.5, I sell something adds another 947, sell something to etc. So you can see the UI is working the way I would, I'd want it to in terms of the definitions I've made. So the definitions I've made are just, I want to register a reducer for generated data. And it's going to look at the after state of the database and had 42 to whatever's in component ID top x. And then all known Sales Total, is going to grab the entire sale by ID table and reduce over it pulling the amount out and adding them up. So by just registering these two reducers, I'm going to get these reified things plugged into my model for me. Now, it's interesting how this is actually implemented. And you can do all sorts of interesting things with this sort of system. But I did just want to like, just show you an idea of one way of going about this, of course, there's all sorts of dependency analysis, you could probably just pull the reframe whole signal grass graph mechanism out, and and use it in a similar way here. Remember, though, that this is a normalized database, we have components, we have queries, we have ways we we could, we could also like register data dependencies here and do dependency analysis is an optimization. There's all sorts of cool additions, we could add to this, but let's just show you one idea of how you could implement these. So they work the way I've shown where they really actually reify their values onto the components themselves, which is a form of caching rights. And if there's this whole UI renders for some other reason, I don't have to rerun the reducer system to recalculate those values. They could use some sort of dependency analysis mechanism to know they don't need to update the frame could rerender and the values are already in the appropriate places. So this is sort of the you know, the way folkert typically does it, right? It's it's a reified view in the database. So it's really quite straightforward with the built in internals of folco fulco keeps an index of for every prop you query. So generated data sale amount, sale ID, every one of those properties, there's an entry in the index is from that property name, for example, sales slash ID, to all of the classes, in this case sale, that query for it. Then there's another index that keeps track of which classes which class for Neal for a given class, what on screen react instances are there. So these are the live instances, it actually tracks the ones that mount and unmount as they add mount and unmount. So you have that index. So really, all you got to do is figure out some optimal way of calculated then generated data. And I've got a comment here about how you could optimize this in various ways. But for the moment, just proof of concept, I'm just doing a quick reduce, where I'm just associating the property of the generated data with the reducer for the generated data, the function call, so this goes through and gives me all my generated data. And then I walk these indexes, I look up all the classes that are affected by that given generated Prop, I'm going over all the keys of the generated data here, getting all the affected classes, and then for each affected class, I'm accumulating all of the components that are mounted instances of that class. And notice I'm reducing over the state map. So I have to return a new state map from this transaction, I'm sorry, I'm swapping on the state items. This function needs to return a new version of the state. So I'm doing a nested reduce on states.

So this reduce goes on to this reduce. I've got all the affected on screen components. I can ask each of those component for its ident con john to that The Prop, there's the path, I need to put the new value on Association derived state path, new generated value done. So, whole 38, what is it 38, roughly 68, roughly 30 lines of, of code, you know sans optimizations gives you this mechanism where a component that's on screen that's querying for derived data gets updated values, kind of automatically on transaction boundaries, or some other problems to work out, for example, on the first frame, we don't have a Sales Total, we don't have generated data, we have to actually bump something for the things to happen. Again, this is just a proof of concept demo, the actual changes needed for foco itself were just four lines, right, we just want to be able to add a transaction hook in terms of the implementation of any arbitrary hook. Well, this, if you think about it is now a function that gets called with the app and a delta. And it can do anything, it could submit a new transaction, it could swap on the state atom. Note, however, that it is in the middle of transaction processing and transaction processing is going to schedule a render after this thing runs. So if you do swap on the state, you're guaranteed that you'll get a scheduled render, well, I guess you're not guaranteed, because they could have run a transaction that asked for a targeted update. So it depends on your render, in general, you'll get a scheduled render. So you know, there's a bit more kind of fiddling around and experimenting to deal with this. But I think it's an interesting result. And and this might go a long way towards alleviating people's complaints about, you know, sometimes there's a value where I just don't want to put that my mutation, I don't want to keep track of it. I don't want to mess with it. I don't want to have to Okay, I said new sales. So now I have to, you know, tack in, you know, thread, an additional helper here that says, oh, update my sales total. Because I'm adding a new sale, I'd rather just have that be an orthogonal concern that sits somewhere else. And likes to date, I've not added a particular mechanism for that. I still haven't. But I think this is an interesting experiment. And in ways we go about adding such a thing, and having a be an effective addition that isn't your primary mechanism. I still think the reified graph, the introspection that you get from that, like a lot of the pieces that you get from initial state etc, are really useful and important, but I do recognize that this particular thing sometimes has a really valid use case and we should find some some good solution for it.

