Alright, in this video, we're going to talk about focos indexes. You don't use these often. But if you understand them, you'll understand everything there is to know about writing your own render for fulcrum. So there's, I guess there's two purposes for this video to kind of talk about the rendering of focal and how it works, how the different plugin optimized renders, work, and what they can leverage in order to do their optimizations. And some interesting things come out of this focal model of having co located queries, idents, and locals, you know, initial state and even component local state, haven't talked too much about component local state in really any videos to date, but I'm going to talk about it here. So what are folkers indexes? And how do they help with rendering optimizations? So this is talking about what they are. Focus indexes are nothing less than an index of every on screen component. That's one index. There's an index that tracks per keyword that's queried which classes query for it. So for example, I can ask an index, who queries for counter count? And it'll tell me Oh, well, the counter component does, I'll show you that in a minute. I can ask for all the on screen components that have a particular ident. So and those actually give me the React elements. So we saw in the last video when we're looking at the internals of the def, SC macro, and and what it actually does, let's pop back into that. These, you're probably just to jump to DEF sc and go to depth SC star, and then look at configure, component, and then we can see configure component does this whole mess of rewriting. And you'll remember that when we were looking at component did mount there was this wrapper function that was pulling out the definition of the index component, the indexes are actually a pluggable thing too. But I kind of just made everything pluggable and in full grow three, I can't even think of a reason why you'd well I can, I can think of reasons why you might want to change the implementation of this algorithm. But they're not. They're not very good reasons. But this this index component call happens every time a component mounts and this is done both in hooks based components, and non hook based components. So in folker, when you say use hooks, you don't just get a plain function, you actually do get an augmented function that registers effects and and state. Because there's another element that that we use this part of rendering optimization that has to do with these, these additional tweaks that we do to focal components. So focal components, even when using hooks, are not plain things. So if we go look at the Configure hooks components, you'll see and you saw this in the last video, that when we add the hook option to dad hook options is that where it's at. That's not worked at.

It's pretty easy to find, if we just do that, here's here's where it is. Yeah, sorry, there's a useful CRO effect that used by the hook. And you see it does this use state here, which creates kind of a foe component local state. Because there's some full CRO calls like set state that you still want to be able to use. You know, with these, I want to be able to use you'll see in a minute what what I mean. And there's also this use effect that index is the component drops the component as a hooks based side effect. So same thing, index component, and then the cleanup routine is drop component. And then the only thing that that causes this to change what its index is is if the components identity changes, and you'll see why that is in a minute as well. So this is the other element of things that are happening inside of a def se component. It's mainly just react rendering, and giving you some nice syntactic helps for building these. But there's this indexing thing that happens. There's and there's a couple of other things having to do with component local state that we actually play with to enable some some interesting optimizations. So let's look at what those are. So that's the basic idea of what we're looking at. Okay, so we've got a simple app here. I started out with this one yesterday and then didn't really even use it much but we've got four counters if you click on them, you know they each have their own instance if you go and look at them in full Kronstadt inspect that window is way too small to even see him in there. But they each have their their respective state and ID and of course when you click on the state changes, big surprise okay. So that's what we got as our simple app. And that's enough to show you pretty much everything I'm going to show you in the video. I've set up in it local state, so that there's a color. So this is component local state, this is application, initial database state. And with an IT local state, when this thing mounts, it's going to have color named positive. And in semantic UI, there's a positive, there's a negative, there's some other kinds of things that you can throw into a button to change its color based on the theme that you themed your CSS with. So if you say UI positive button, or UI button positive, you'll get a green button normally, or by default, like in the default layout, if you say negative, you'll get I think, a red button. And I'm just using the classes augment. And this is an augment that's built into focals dom macros, where you can list a vector of strings and little throw them into the class name along with these. And so yeah, if we go on, like inspect one of these guys, oops, not your page source, you'll see UI button, and then there's a little extra space there and, and positive. And you can actually throw nails into this. So you can put like a win and that sort of thing in here, and the nails will just be ignored. So this is, uh, you know, I could put in, big in here, and then we'd have UI, big positive buttons, etc. So anyway, it's just a way of doing things that are often kind of computed classes that you want to tack into the class name to co locate anyway, that's all they are. And I'm getting this from component local state. So I can play show you ways we can play with indexes and mess with component local state. So root queries for counters, the counters have IDs, the IDs of these, as you saw a minute ago, and as you could guess, based on on the ID parameter, the initial state of that guy will make that Id parameter the counters, ID, router, start will make the counters count start at that adds, let's go and reload this. And we'll see those numbers. They're great and wonderful. Okay. Let's play with indexes. So down in your comment block, I've already written some things. And so let's just look at these individual pieces here. So let's pop this guy out and just run it. So this function in the components namespace of full CRO, can take an ident and return all of the on screen components that currently have that ident. And so you see, I get a react component there in a set. So if I had more than one component on the screen there that say you have a list of people in a master detail view, and there's a person form, both the row one might have person ID one. And if you're editing person ID one, the form might have person ID one is its identity. So that's a set of things that you could find on screen. There's also this identity, I'll run the sub expression out of this. And you see that gives me back just a single one, it's not a set, it's a single one. This one is basically if if you're pretty sure you only have one on screen, that's kind of the quick and easy way of getting it as opposed to just saying first and that.

So let's grab that guy and see what he is. So I can call get ident on it. I can call props on it and see what the last props were passed to it. So if I go up here, and click, the guy can see Oh, what what is the are the props you got last Oh, I got it 105. Great. I can find out what the what his parent is and what the React type of his parent is, oh, it's route, right. So you can kind of explore the tree just by pulling these guys. And notice this is a data driven way to find things on the screen. So this is why it's useful for things like optimizations, if I want to do a targeted render rerender of something, being able to look it up by what it talks about is an interesting thing. So let's talk about the other important index. There's an index of Prop two classes and this one. Well, here, let me show you how they say I want to find what class queries for counter count that tells me counters great for that knows this is a keyword. And the reason for this has to do with hot code reload. The index is if the index is were to close over the actual classes, and then you hot code reloaded, you could actually have something in the index that was stale and didn't match the thing. So we actually use the registry, which does get updated on hot code reload, to look those up. So if I were to look up the classes that have given prop queries, I didn't have to run them through a map of registry to class to get the real live in code. component class that's that's currently being used for that thing. And then if I know what class I'm looking for, I can find all the on screen instances. And notice here I'm using the actual class that would be the return value of this guy. I can find all of the on screen components that implement that class. So let's say what you're trying to do is I want to let's say, you know, maybe you've got other components in the system. That query for things. So I'm gonna put counter count down here, even though route isn't the counter, I'm going to force reload that, because I think the route index doesn't get updated on hot code reload. kind of mistake, fine. All the classes and icy route is in that index. So those of you who've been around folk row for a while, remember the ident, optimized render, and that in transaction jossa, had to do what were called follow on reads where you would come up in your transaction, and you'd say, Oh, you know what, I want you to update everything that queries for counter count. That was actually a built in thing that we inherited from an arm next idea. In our necks, the idea was, well, we don't want to render from root necessarily all the time, because that might be expensive. What we'd rather do is have you tell us via data, what data you changed, or what kind of data you changed, and we'll go and look up all the things on the screen that use that data and refresh it. And over time, I was analyzing the performance of these various ways of doing these optimizations. And not only was this very error prone, I mean, I eventually moved into enfocado. To, you could say, refresh at the, at this level, right at the mutation itself, because this is where you're changing things. You say, Oh, well, I changed. I changed the counter count. And I changed whatever else you changed right? Here, we're only changing counter count. And so you could list it here. And that would be sort of an instruction to the optimized renders folco to only had one way of doing render, because it was kind of fixed. And so I kept trying to find ways of making it easier, so that you didn't have to say, Oh, well call increment, which is supposed to be some abstract mutation, that you just happen to know oh, I also need you to know that you should rerender things the query for that. I mean, the default and both on next and early versions of folker, was that it would always rerender, the thing you transacted from. So if you were just modifying things that were local to you, well, you didn't have to say this, this only came up when, oh, well, I know you're going to rerender. Me, but my parent has a sum of all accounts,

which is a totally legal thing for it to do. So reduce over plus

something like that. Okay, so 187 is the total. And in other versions of folco, you'd click on this and this number wouldn't have changed. Because it's it's the parent. And depending on which renderer you use in full grow three, that can still be the case. And so the fix was to say, Oh, well, I want you to also rerender things that query for counters. And the way this was implemented was with the indexes, right? The transaction system, the underlying foco system would see Oh, are you want to run that mutation? Oh, and it also looks like you want me to add this to the list of things to refresh counter. So I'll go and I'll run this. Prop the classes on on counters. that'll tell me route, I'll go look up route in the registry and find the actual class, then I'll go and pass that class into this thing. And that'll tell me all the instances. And I'll figure out what props to pass to that guy and refresh him. Now, note, there's an interesting catch here in order to refresh something out of a relational context. If you remember, back in the first couple of videos in this series, we talked about how queries in a component are relational, right, this counter ID and counter count, whose counter ID whose counter count? Well, the parent supplies that right, the parent says render this one than that one than the other one, and passes a map. So this query is no kind of absolute query. So how would I go about refreshing this specific counter? Well, I can only do that if it has an ident. Because if it has an ident, I can ask the component. So let's go back here and regrab counter one. More for that matter. Let's grab this guy. And we're going to find this fails because root has no identity. Right? So Oh, sorry. Right, we want to find all the things that are of type root. And let's just get the first one. And this is going to give me nil because root doesn't have an ID before a counter. I'm going to find one that actually has an ident right and I know there are four of those. Right so how do I get The props for that counter. Well, I know it's class. And if I, and I know it's instance, right, so let's say I grab one of them, I want to refresh counter, one, there, see, I can get as ident, I can get him, I can get his class type, right? Because I can say whatever the React type of See, I can ask for the current query. And this actually requires at runtime, the current state map, I can ask for the query of that guy. Well, if I know his ident, and I know his query, well, I can wrap it on a map and make the query. And if I can make that query, I can run DB tree on it. Which we saw in earlier videos, etc. I can get its props. Now the problem is, how do I get the props to it? Right, because the props are normally passed by the parent, right root normally gets the props, pulls them apart, and passes them through react, props. Okay, this is a little bit of a problem, how do we get it to it. And so the method that was invented, the original method was very similar to what I'm still doing. I call it props tunneling. So with props tunneling, what I do is I leverage the fact actually the original, I think the original on next implementation was a force rerender, where you gave that thing props. But then the React docs sort of said, You really shouldn't do that, like, there's a whole mess. So if you look at setstate, setstate, takes a react component, it takes this Well, I have that I indexed it. And I can pass things to that. So I could say set state on C and make it negative, right, I just changed the component, local state of that particular thing. So there's first interesting use of having these in the index, I can find component with an ID, or he can I just did that guy, he there's real react instance out of the index, and I can change his state. Well, now think about state. That's a closure script map. You saw in the last video.

Well, props are a JavaScript thing. So it's state state's a JavaScript object. That means I'm doing the same trick to state that I'm doing to props, I'm sort of putting full CRO specific things on state to trap the closure script thing. And a low level state is actually a JavaScript object. And because it's a JavaScript object, all the other keys on it are hidden for normal uses, right? When you say, give me the state for color, if you go and look at this, this actually gets the low level JavaScript object and look for focus state on it. So any other keys I want to put on here I can put on here and they're sort of hidden to the focal components kind of high level use. Which means I can put other things on there, like alternate props. So here's the idea. This is kind of fun. This is a kind of a Frankenstein creation, but it works really well. So I've just shown you that I can I can index the things by hacking into the component lifecycle, whether it be hooks or not hooks, and capture these things into an index, I can then look them up by data path. Now notice, that's a focus specific thing I'm not aware of. I mean, maybe Apollo has this, but I don't think it does. I don't know of any other library that's doing this that has a data centric index to on screen things I want to find person form with ident Bly, you can find that with the indexes, and it's the actual on screen element that you can then call set state on and send it state it actually knows about, or you can tinker with a lower level react state that's there and do other interesting things. And so that's what we do. So this is the tunnel props function. This is a public function, you can call it although you need to understand what's going on to to really use it properly. So if you look at the D structured props for anything in focus, so I'm just going to do a js, console dot log of props here, and then we'll see up in the console. The props pop out, make this a little bigger. Okay, counting count. But if we look at I'm hoping this is right, it should be

Windows to small.

There we go. The metadata on the props has this special thing on it called denormalize. Time. And this is the trick, this is the trick to making this work, right. So this denormalized time is actually added by DB to tree. If so, you know, if you don't know DB to tree, go back and review the earlier videos, this is in the fogo de normalize namespace, let's make sure we got that on the class path or on that require path here. We already did.

And if you go look at dB to tree it calls denormalize. And then it says with time and if you look inside of denormalize, as it does it's recursive kind of, of processing of the query. And the the state it's always adding this metadata at each level at each join. At each join, it adds a time. So what is this time? This time is very much like if you've used a Tomic, it's very much like the transaction time, right, each transaction is sort of reified. And in full grow in dev mode, especially in dev mode, there is actually history of all the states that have happened, that it's limited, right? It gets pruned, for inspect to use. So when you're in here and inspect, and you see this revision number, right here, this is the this is you know what revision of the database it's currently seeing. And if you click quickly, you see it, it sticks and it tells you what revision we're waiting on. And the revisions here actually, how many swaps have happened against the state atom because inspect watches the state atom, Volker does not Volker itself does not watch the state atom. It uses the transaction subsisting to decide when to rerender but, but inspect, because it wants to show you anything you might have done to the database, it watches the atom so it can catch anything you do to the database. And so it's actually waiting for it to catch up since this number is not the same number. And there's a function you can call info to find out what what the app's concept of this time currently is its basis T. and So currently, the transactional time in in the folk rap right now is 48, even though the number of swaps that have happened against the atom have been 86. Okay, so this basis time is what we end up throwing on the props. So if you go and see this was 48. If I go back to the console, log and look at the recent renderings, you'll see you normalize time 48. Okay, so when props come from the route, and are passed down through the tree, that means they were generated by DB to tree with some particular time. And every time a transaction happens, this time gets updated. So if I click here, right, and I can go and look at the denormalized time, or now we went through two things happened. And so 50 is now the number. Okay, so what I'm doing behind the scenes, is, if I want to update just this button, if that button has an ident, and I and I'm running a renderer, that has an optimization that says I want to just update the things that changed, I don't want to do the whole from route. What I can do is I can do this function called tunnel props. Now what is tunnel props, it's really quite simple. tunnel props, takes some props. And you have to associated with not associated normalized time with that just yet. And it tries to send those props to the given component. So I'm going to make sure this var is up to date, so that that C is actually that on screen component, I'm going to try to send the number 91. And counter ID one to counter one. And you see nothing happens. And nothing happens is because props could come to this guy from the parent. Or they could come from tunneling. And once they've come from both at least one time, that component is going to have in its component local state some idea of what the tunneled props were along with their time, and it might see props from the parent. Well, what if the parent was locally refreshed? First, and should component update kept the child from refreshing Well, now the parents time is newer. And then I tunnel some props, right? You can get these situations where the different times that that things have been seen cause confusion. So for me, I'll show you exactly like like right here. If I send it something that has no time Well, no time is not newer than the time it's seen from the parent and so it thinks The parents props that are being passed in are better, and it should use them. So it's actually comparing these, if you go and look at the, that's part of what that whole rendering destructuring thing is doing in the components namespace. If you look at the actual render implementation, my would take me a minute to find it, actually, because it's, it's several steps. But I bet if we look for for time,

well, I'll let you play with it. I don't want to waste our time, like scanning for the code, you can just believe me that essentially what I'm doing, Oh, I know where it is. Well, we're there rotten newest props. So this is looking at the props focal value, and the state focal value. And then it's calling newer props that say which of those has the bigger time on it. And so if you look at newer props, it just pulls the de normalization time of each one and figures out which one's newer, and then returns the right set, right? It looks for nil. Right? If A is nil, then you must have been on B if b is nailed, and you must want a if you've got both you want the newer one. Right. So So there are two sources for quote, props on a component, props that came from the parent, and props that could be tunneled from a customized pluggable render, so that it can choose to refresh just the things on screen at once to refresh. Let me pop back to the app here. Okay, so let me go back to what the said that said with time 50. Well, I know the current time in the app to make sure hot code reload didn't clear it did cleared my I'm gonna move this outside of the comments. So C's always set on hot reloads. So sees there, I look at the basis time in the app, it's 52, I tried to send it with 15, it says no. But if I send this with 53. When I get it, if I sent this with 63. Here, let me change the number. Right, I get 98. Now the prop that's actually in state right now remember, counter one, if we go and look at that, it's actually 100. And now I've put this time of 63 on there, and I know the app time is really 53. So I'm gonna have to click on this button 1234567. Notice the totals going up eight 910 11. Right before it refreshes, because it thought it's stateful props, it's tunneled props, were newer than everything that was coming from the parent. And like I said, that can happen when say you're updating the parent and the parents. Time is refreshing. And it might actually have a newer time. But then the prompts that since two, you have an older timestamp on it because they didn't change. And so you can still figure out which things are right for your particular, like rendering, it gets it gets a little hairy to think about but it's the time thing pretty much straightens it out as long as you put the right time in here. So this should really always be you know, when you tunnel props, it should always be the basis time. So that you're, you know, you're getting something correct. Now, of course, if I'm sending data, that's not true, if that's not actually what's in the app state, then I'm kind of screwing up. So really, right, this should be a get in on the app current state

of counter ID one, run through DB to tree. Right. That's, that's really what you should be doing here. But I just wanted you to understand, that's all the magic there is to it. That when I want to make something on screen that's normally getting props from the database look different than it currently looks. And just refresh that one. There's no root re rendering here, right there. See if I, if I put a log statement here.

Right, I do a Save. And look at the console. I will see there was a route render that happened there. And if I if I click on these buttons, normally, with the render, I've got installed, there's a route render, the default render in full CRO for ease of use. And it turns out for actual optimization, most apps, trying to figure out what the refresh ends up taking as much time as it does for react just to diff the DOM. So it's kind of a kind of waste of complexity and time, just a bother in most cases. And so I learned this over much, much algorithm writing and refining that the root render is often the win. Or as it's, it's even if it's not a win, it's so close, that it's just not worth the effort. But anyway, so these are renders but if I go down here, and I say hey, change that to 64 You'll see that no render, shoot, I wish I had that where you could have seen it live. Let's clear that because I had those mixed approved renders in there, change this to 67. Call that I'm only refreshing that one component on screen. And that's super, super efficient and fast. So if you had a particular structure to your app, and hopefully lightbulbs are going on for all sorts of people watching this video, hey, well, why why don't I just look through the tables? And right, okay, I could keep the prior app state, the current app state, everything's in tables, I can walk each table and if the table itself is identical, that's a non equal. That's a reference compare, right? If that one's not equal to that one, then I'll look for stuff in it. But if it if not equal returns? I'm sorry, equally identical. Sorry, sorry, if I look at it and say the old one, is it identical to the new one? And the answer is true. That's a reference compare. It'll be really fast when you scan all the tables. And then as soon as I find a table, I can do the same thing for the table entries. And I'm done. I can find the six idents that need refreshed on screen, get their props and pepper the refreshes out to the components. And that, in fact, is exactly what ident optimized render does. It tries to look at the diffs in the database to figure out by ident, which things have changed. Now the problem is the which things that changed is a little tough when you've got discount, right, this total, oops, sorry, I've got Actually I have an ultrawide monitor and the videos shrunk on I double clicked by accident. This total right here, that's that's being updated is only refreshing because I'm doing a render. If I switched to an IDE and optimized render that automatic refresh of total would not be happening. And that's why I no longer have IDE and optimized renders, the default is it makes it more complex to write your apps, you have to say whenever you do this total sort of thing. All right, well, I did the counter. But when I want to change the counter, I've got to see refresh counters, or total or whatever, right? The thing that queries for counters and say Actually, this would have been updating, right, because I then optimized render, uses this to look through the indexes to find this guy to then re render it. But then you're doing a root render. So in this particular case, it's kind of pointless you spend all that time figuring out what to update, and then found out you had to update everything anyway. Okay. Did I miss anything here? I think that's largely it. I mean, I could show you really quickly, the ident optimized render, just to give you the idea

of like, the extra complexity that this adds. So when render gets called this thing first checks for ops options. It basically says, Well, did the root crops change? The root props changed? I've got to re render root and I might as well just do a keyframe root render? Or did you ask me to force a root render, in which case I'm just going to do a render? If you didn't ask me to do that, then I'm going to render only the stale components. And if that throws an exception, I'll render from root kind of these, these back outs, and the render stale components does kind of what I just mentioned. Where does it I forget where it stores the last version of state? It stores in the runtime? Adam? There's a runtime out of info that you can just throw namespaced keys into anytime you want, right here. The runtime Adam, that's the app root. But anyway, you can you could store an old version of the app. So when we say render steel components, it goes and looks up. To know what the props, the components, is that the index? Yeah, that's the index. So this there's this guy has a limited refresh option option where you can say, only refresh, right? You probably have seen that option. If you've if you've sent the only refresh option that says Well, don't even bother figuring it out. Just do this stuff I said. And so this goes and tries to figure out which, you know, components gets the ident and then calls this render component and render component does the DB tree figures out the computed from the prior render. So this kind of helps explain computed Actually, that's that's the other topic that I should touch here. That let me back up. When I pass something as a computed,

let's just say, x one.

The reason you have to do this computed thing is this tunneled props. That's exactly why it's because the tunnel props won't know what the parent Route sent to the component when it rendered it. And so the the trick with the computed is it marks this thing as something that needs to be recent as part of the props, whenever they get tunneled. So this is sort of a way of separating the two out, right? The plain old props, this factory doesn't know what you might have thrown in the map and what might have come, you know, through the props just as part of query, because this, this factory is disconnected from the query, and it and only the component knows that. So this is a way of asking you, the programmer to mark the extra prompt, that you want to pass to this component as, quote, extra props that didn't come in as part of the query, because this tunnel props this DB tree that I was suggesting here. Right, that's how you would compute the props to tunnel to that component, this isn't gonna get the computed stuff, this is gonna get your callbacks or your whatever's that the parents sent the first time through. And so when you do that targeted refresh, those are missing. And we didn't use computed in here, right computed to this, this kind of third map. Here, we can just show

the computer props. Why am I not getting my nice render on on those? Right? x one, if I did those as a Sosa's instead, right if I wanted to so so on the props. x one. Here, let's say props. And computed props.

Right, I got

How can props be no. old computer props is No. Oh, right. Because there are I'm not passing computer right now. So it's telling me there are no computed. But if you look inside of the actual props, x one is there. Right? So you can pass them that way. And it works just fine. I get the x. It's on these tunnel refreshes. Right? So if I say Oh, 767. Do I have my repple? Still? Oh, sorry. I see. Since 67. Do I still have the basis time?

Am I messing up here? Did I not get See? Oh, I didn't get to see.

Okay, I've got see now. That's why that's not getting set.

There we go. Now it updated. But when it updated, and I got a props. Shoot, the hot code reload here kind of messes with us there 66. If I look at those actual props, I don't get x one. Because I didn't send x one. And I didn't notice index one. But if I do it is computed. Then folker internally is written to kind of to kind of carry those along. So we just refresh that make sure we got it. Okay, so right when I click on this, I get both the computer props and the props. And now if I come down here after I still have my See, I don't know why that's not refreshing for me. Oh, I know, when I'm doing the depth here on the first on the first mount. The index isn't built until this mount completes, and so starts getting called but this render hasn't happened to the index hasn't been built. So seasoning up nil. That explains it. Okay, so let's now tunnel things. And you see when I tunnel things the computer prop still came through. So that's what computers is about, if you want to kind of the core understanding of computer that has to do with this tunneling props, which has to do with optimized render, which requires these indexes. So now you kind of see the full kind of blown picture of how all this all the secret sauce of of optimizing render. So we go back to the optimized render now and see that's why we're doing this. We're saying look the component up in the index. Once we have the component Then get its prior computed, right, because that's, that's actually stored on the React component, we actually cache it there. So that when we build the tree, we can reassociate that data tree with the prior computed so that when we tunnel, these props, we get both the computed and the tree. Kind of cool way. So really, this render component is a reasonable function. This is an optimized render that does all the steps that I told you need to be done, the query needs to be pulled via the state map. And that's because dynamic queries, once you're running, get query with just the component gives you the static query of the component, get creative, the component with the state map can give you the dynamic runtime query of it, if it's been changed. We build a query, we run DB to tree, we add the computer back end, we toggle the props. That's literally how you render an individual component in the focal system. And so with it, unoptimized, render, we're just doing some various, you know, find all the dirty tables, find things that are dependent upon an ident. So these are the things that query for, say, the identity join. That's the thing you can do in a query. So over here in route, we could actually say, in any of these, right, I could actually say on this component, I want to query for as a join, counter ID for counter count, so that all the counters no counter ID fours count. Like you can literally asked for that. Oops, I wrote that query. I can't get that racket out of place. Right. So you can use that as a join anywhere in the application. As long as the query reaches that component, right? As long as it's it's the graph is connected, these link based queries and ident based queries only get evaluated if the data graph reaches the component in question. So if when you're doing DB to tree were cut short, there's no edge between route and the counter. Well, I don't know if that edge is to one or too many, or what it is. So I can't continue with the query DB to tree can't continue parsing the query and filling things in. Because again, this is this is relative. And even when it's a non relative sub component of the query, the whole query is treated as relative. So if you don't reach this relative location, this guy won't resolve. But that's a perfectly legal thing to do, I could ask for all of the counters at route. That's what the linq query is. Right? So I could find all the counters, and then I could put the count total on the button of all the buttons, whatever. So anyway, if I embed these, this is this component now on the index is is known as a dependent on the counter of route. If I go and say we're in my indexes, save that make sure the think the indexes will get rebuilt that and I say, find all the things that depend on I might have to hot code reload does not rebuild the root. indexes, I need that guy. Prop the classes counter.

Oh, counters.

I don't think it rebuilds Oh, it does rebuild hot code reload does rebuild. So you see now that this index now includes, well, the counters themselves, query for counters, because they've reached back to root and done it. So see, you got some interesting side things here. So if you looked at it and optimize render, it's actually fairly complicated to figure things out, because you have to go through everything and figure out okay, well, who queries directly for an ident? And who, who reaches back to the root, and etc. In order to figure out what's actually stale on screen, and then you really haven't even gotten the parents, right, you didn't figure out that Oh, that parent just happens to us. That was the example here. Where we were competing this total, it's perfectly legal for me to use the things that I queried for and compute something from them. This is very common with checkboxes, right? If these four things are have checkboxes on them, and I want to know, I want to check all button and the parent, that check all button is the basic, basically the it's lit up, if all of its children are checked, right? You don't want to keep that as a separate state. Check all is really a statement of your children, not a statement of yourself. And so this is a very common thing to run into in a react base or any kind of UI based thing where a parent has to know something about their children. Are you checked, what's your current total, that kind of thing and the IDE and optimize render Well, it technically can be faster. It creates these complexities of when do I have to tell full grow how to Refresh things etc. And because there's so much logic in here to compute the difference and figure out what's actually stale, dirty table entries, etc. I mean, this is a study and you know how much trouble you can go to to not win. That's the optimizer under so this guy is what folk are two uses, you can turn it on as your gender and folklore three and measure it and see if it wins. In general, I found that the keyframe render makes it really trivial to write. And react does a fast enough job once you put it in production mode and, and compile with advanced capitulation options that it just doesn't matter. Don't Don't go Cause yourself the headache. But if you wanted to be a power user and write your own optimized render and tune it up, here's one of the tools you'll be using pilcrow indexes and tunneling props. So hope you enjoyed the video. And hope it didn't bend your mind too much hope you're you're all jazzed about understanding how how these things work. And I hope you find some fun creative uses for for, especially Canada, this setstate thing is probably the most interesting little bit being able to reach into components kind of by their, their known identity, and sort of give them some instructions through this, the set state mechanism, not necessarily the tunnel props, tunnel props, you could really confuse yourself because of this basis time comparison. It really is meant for rendering optimizations, but this set state you're perfectly allowed to call that as much as you want from anywhere. It doesn't have to be from within the component itself. So this is an interesting way to sort of like look things up by their identity and talk to each other. So you could you could create all sorts of fun event based kind of systems and they're not. I'm not a huge fan of those for most purposes, but sometimes they're really quite useful and and this is a kind of a nice way to to build

