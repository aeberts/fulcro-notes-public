In this video, I'm just going to talk over the final solution to the state machine that was developed in the prior video. So there wasn't much left, really to do. So what ended up being necessary, or at least in my opinion, desirable, was to add another state for bad credentials instead of trying to keep track of some particular flag. This is a this is a case where the state of the state machine really does track that particular piece better. So I factored these two events out since they were doing the same thing. So on a log out, we routed a login screen and send the remote logout mutation, fix the user and on login, we call handle login, which is the same thing every time, right try to run the login mutation and get the the current user back. But then I split the checking existing session and checking credentials out this, this was a shared thing before and I just realized these things really do need to do two different things. And I got an extra feature out of this actually. So when I'm checking the existing session, which comes in from this, this initial handler, right, we load the existing session, we're checking the session, if we get an okay, well, then if we're not logged in, we go to log in. Otherwise, we go to the idle state. That's straightforward. And if it fails, we go to the server failed state. All good. The difference for the checking credential state, which is is we push into that on login events. So we have a login event we handle login, a login always sends us to check in credentials, this that we've got a couple of interesting concerns. On Okay, it could be that logged in is false. And in that case, the state should that we should go to his bad credentials. Otherwise, we go to the idle state because we logged in. But the other thing we're interested in is what if the user had tried going to something like the settings screen on on their HTML routing path. And we found out they weren't logged in? Well, then we want to redirect them to log in. But what you'd like to have is then the ability to once they're logged in, send the back to where they wanted to go. Right, that's a desirable feature. And the state machines made this trivial to do. So what I needed to do was be able to store my intended desired path. So in the begin over on the client, we can actually pass in the an extra map. And this extra map is the event data for this initial event. So I just pass in desired path. And then I just looked at the window location to find the slash settings portion of that, which is the path name attribute. And sent that in. And then in the state machine, when you get that event data, it only comes to the handler once, right? So you have to capture it. But there's this local store. It's actually just part of the state machine storage, right? It's called local storage, where I can put key value pairs. So I said under the config key, store the event data where the event data is just this desired path. Right. So I save that for later routing, I went ahead and did the the load of the session, and then went to checking existing session. So So once that's stored as long as the state machine doesn't get restarted or exited. And in this particular case, I've set the state machine up to just always be running while the application is running, then that information will be there. Of course, I'm only going to use it once. But so then the trick, well, actually, I might now that I think about it, my login logic probably needs to reset that piece of, of data. Because now if I log out and login, it's going to take me to Settings no matter what. But that's okay, that's easy to fix. So this, this gave me the power to store that. And then when I saw that the credentials were finally good. I'm logged in and the desired path, then I could route there. And so it gave me this nice permanent storage location for that while I'm dealing with a did they type in the right password that they type in the wrong password. And you can see now if I try logging in, there's a bad password, I get the right thing. And if the server was down, I'd get the the different error. So over on the client side and the login form. By the way, the mystery refreshes, I just needed to reload the app, the queries weren't refreshing properly from hot code reload. So once I reloaded it all the refresh and started working, right, so in login form, now I can just get the active state, I can check that's checking credentials, that means I'm busy. If I'm in bad credentials, that means there's bad credentials and right so then I can see the form has an error class when one of those is a problem. And then these will only show up if the form has the error class. So then I can say If it's bad credentials keep,

show that and if it's a server error show, show that. So again, very declarative, and now I'm only dealing with the state of one thing, the state machine, as opposed to a bunch of totally individual values that I've got to keep track of myself and reset back to original values, etc. So, you know, I find this to be a much cleaner solution, if you think about like trying to implement that, okay, go to this route afterwards, kind of behavior. The fact that that integrates very nicely in there with the state machine just shows you that there's, there's quite a bit of flexibility here. And hopefully, you can also see that the state machine really isn't tied to the UI in any way, shape, or form. Right. The act of abstraction gives me a way to, you know, use use data from app state, or set data and app state without having to actually know what UI components I'm tied to, which then lets me reuse the state machine later. When I decide I want other UI components to be involved. Maybe in a different application, right, I can just literally pick this up, copy the code to a different application that has different, you know, UI design characteristics and the state machine will still work for it.

