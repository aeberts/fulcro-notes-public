This video covers an introduction to getting going and Velcro. And it's meant for beginning users who typically don't have a whole lot of exposure to focal or closure or closure script. But hopefully you'll find tidbits in here, even if you're an experienced user. So the first thing we want to do is just set up the bare minimum project. Now, I recommend using shadow clgs as the compiler, it avoids the clgs gs ecosystem. It's a really nice compiler to use. And it uses the NPM ecosystem directly and makes it a lot easier to use quite a few of the the React resources that are available to you when working with front end. So you're going to start off with just a package JSON file, just like you would in any other NPM based JavaScript project. And the only things we need here are react, React DOM and shadow clgs. The version of react folkert three should work with everything from react 15 forward. As you see here, I'm using 69 for this demo. Once you've got NPM set up, of course, you're going to do an npm install and get those those things into your node modules directory. You're also going to want to set up closure dependencies. The Shadow clgs compiler is actually a closure program that runs in the Java Virtual Machine. So you're gonna have to have Java installed JDK 1.8, or one dot 1110 doesn't work particularly well, but either either eight or 11. I think I'm currently I'm using 11 here in the demo. And the way I like to configure closure projects these days is you using depths even if you're using homebrew, you can do a brew install closure to get the COI tools for dealing with Depp's and the the items that you need here, the only hard dependency you need is full CRO. At the time of this recording. I'm on beta 13. And the three oh release. And the alias section lets you add just some additional aliases, we can add additional things to your class path, additional source directories, etc. And because closure script compiles to JavaScript, well, then at runtime, I don't actually need the closure script language, the shadow clgs compiler, or the development tools that these are development tools for Chrome that let you do source level debugging, oh, no, I'm sorry, Billy, you see closure data structures in such in Chrome, the source maps that you do the source level debugging, that's come out of the compilers. So I usually configure things like this, just you know, latest versions, then of course, you're going to need, if we look at the tree we started with here, you're going to need an HTML file. So the convention is to use a resources public directory. And so you know, I just made a very simple index file here. You see, I've got a UTF eight marker that helps with some, you know, potential encoding issues down the line, a div with an ID, I typically use AP as the ID. And then you're going to call as you're going to need to load the compiled JavaScript. And I'm just going to choose to name it j s slash main slash main dot j s, which is going to be relative to index, which means it's going to be in this resources public directory as well once it's generated. So that's all the HTML I need for the entire project is just that that placeholder that has a div and a way to load the JavaScript that will be the thing you compile. Now, of course, we need some code. And that's pretty simple as well. And I've just made a very simple namespace here in the source app client clgs file view requires a sample component definition of the app, and an init function that can be used to to start up our application, which is basically just mounts the app, the root component, and the name of the div to go find and put it on. So that's going to be the the entire set of source that we need. Oh, wait one more file, the shadow clgs compiler config. I'm actually going to edit that because I realized on the last recording of this video that I don't need that particular bit.

So here, what I've done is I've said I'm using depths to find the dependencies. And I wanted to include the dev alias, so it gets the CL you know, the closure script compiler and the stuff that's like compile time only. I'm telling it to set up a well known Port 9000 for me to be able to connect to the repple so I can use a closure script repple easily for my development environment. I'm telling it to start a development HTTP server on port 8000, serving out of resources public. So this will let me work with my compiled code in the browser on port 8000, while I'm running the compiler, and then you just need to list a sequence of builds. And this is just a map where the name of the build is the key. And then the configuration is the value which is yet a nested map. And here, you want to target the browser, instead of say node, we want to tell it the output directory for the JavaScript. And remember, I said I was going to have a j s main relative to index and indexes and resources public. So I'm going to output the resources public JS main. And then we're going to tell the compiler as well that from indexes perspective, slash GS slash main is where the any other compiled assets should go. So this is relative to the index file as well, basically, then you have to configure one or more modules for the build. And I'm just going to name this top level module main as well, it sounds a little repetitive but and then the function to call to initialize the app, and shadow clgs can actually figure out from this, what all sources needed, it finds that function that looks the requires, it pulls all those requires, and it looks at their requires, etc, etc, just like a spider going out. And of course, Shadow was able to use Google closure for advanced builds to the dead code, eliminate anything that's not actually used. Then during development, we're going to tell it, anytime we load, we want to recall in it, and that will actually cause it to force refresh the UI for us. And then we're gonna do some pre loads. And the only preload that I'm going to do here is built into full CRO. And it's this namespace. And what this does is this injects the code that tells Velcro, your application, it should connect to the Google, the Google to the to the Google Chrome extension, that is the development tool for, for dealing with folder applications. So those are the configuration files we need set up. And that's pretty much all you need for a base closure script project. Now, let's actually show you how to how to get going. Now if you're an experienced closure, closure script user, and you use spacemacs, great if you use vim fireplace great. I personally prefer IntelliJ I work in teams and source formatting and incompatibilities etc, etc. Just it's easy to teach anybody to use that tool, they don't have to learn a bunch of new key sequences just to work. It has nice JVM integration, you can do you know debug source level, source a little debug. On the closure side, even if you're jumping into Java code, you can catch uncaught exceptions, you do all sorts of interesting things. So I really do recommend that people use IntelliJ. It's got a Community Edition for if you're just doing you know your own personal non commercial projects. And you know, the things that you'll want to configure here, when you first get it up. As you want to go to plugins, go to the marketplace, and search recursive. and install that you can see I've already got it installed here. And that'll let you work with with Klitschko. And then you just want to import a project. And if you've already got this opening, you don't see this window, there might be a menu up here where you can choose File Open dot. Either way, it should work. And then I'm just gonna go to my home directory here into the demo project. And you're going to choose the depths Eden File, Open that use auto import. That's just a convenience option. So if you edit the depth, it'll automatically, you know, refresh itself when it sees the depth file change. And then I think I may have, yeah. Okay, so you see this sinking. Now, this tab over here may or may not be in exactly this place on your your version. But the closure depth tab lets you go in here in a and enable or disable the various aliases that you have in the project and defining your system. So the system once I have defined in a global config file, so I want to make sure I could care less whether I've got test one enabled, but I want to enable the dev one. And hit hit the refresh button here to tell it to go ahead and I'm done editing. And then we'll just make sure that all my source paths and things are are on there. And all of my dependencies are listed here subtlety a bunch of yellow in some of my source code.

Now if you haven't used IntelliJ before, just a couple of quick tips. One is this fine to action command. I've got it currently set to command shift command as the little squiggly thing on Max, a. This basically will let you execute any contextual action that makes sense in the entire development environment. So you know, Command Shift, a poll like that would be a git poll or You know, commit files, that sort of thing. And you can see when you do that the command line, you know, the keyboard shortcut, I guess that's to command K, which I think is the default for the OS X. keyboard shortcuts. So then I'll know over hit command K, it'll come up and tell me Oh, are you've changed this file? What do you want to say about it? You know, etc. Okay, now I have the terminal extension installed in IntelliJ, as well. So I can have a little shell terminal there. But I think I'll just use a regular command line here. So if you have NPM, and node and NPM, all installed correctly, should be able to type in PS shadow clgs. Start. And that should start up everything that shadow clgs has been configured to start. So it'll start the the compiler server, which will let you have a web interface to start and stop builds. It'll also start your development. Web server. Right, so we can see that's, that's our HTML that we had before. And then 9630 is the default port that it throws the build server on. And so we can just say, start compiling. shrink that one down to there, and this one down to there. And the first build takes a little bit, the incremental builds are, you'll get quite a bit fast. And then once the JVM is warmed up, a lot of times your incremental compiles will be just, you know, milliseconds. This function usually takes 10 or 20, or something like that. Okay, so you can see if I go over here, and I didn't mean to have these in here already. It's just clean this up a little bit.

All right. Sir, our base thing, so if we go over here, and reload, we should see to do. Okay, so we've got it running. So I ran through that kind of quick, the, the compiler, if you have multiple builds configured, you can turn them on and off here. This is a well known location, it usually reports it to the console when you start it. And then this, again, is the dev HTTP server that I configured to run my builds. Now, there's a nice, intelligent other nice thing, double shift, lets you just search for it, everything. So like, for example, I could see client clgs. Now notice, some of these files are coming from the shadow clgs build directory, they're like cache files and such. And this happens in in projects. So I usually use that command, shift a, you know, do something, you'll find one of the actions in the ID, you can go through and Mark directories, that shouldn't be included. So for example, this compiled stuff in here, I can mark as excluded. And now if I go looking for client dot clgs, I will get all that noise. So that's just kind of a useful tip. You know, if I'm looking for index HTML, you can well imagine that, you know, if other like cache directories or whatever in there had copies of that, I just get like four and five hits, and then I'd go to the wrong one. Okay. Now, so let's get you connected to a rebel. So once the browser is running here, the next thing you need to know how to do is how to interact with this app. So the process is shadow clgs gives you this web interface, but it's really running in a Java VM via this terminal window. And when you save your source code, it converts this to JavaScript, and it ships it over to this running tab. Now, if I don't have this tab open, let me go up here. This is the next bit up here in the ID, there's an add configuration. And I can add a closure, remote repple. And I can say localhost. And remember, in that shadow clgs file, I said I wanted a well known repple At 9000, we can apply that I can go to it, I can run it, I'm going to edit the name of it so that I keep track of which one it is because I might want one for closure as well. You can drag this to other places to you know, put the repple in a more convenient location. Now technically, this is you're connected to the compiler itself, which is running in the JVM. So I can run like Java things here. But I don't want to run Java things here. And in fact, the repple is telling me it's a closure. repple so but this is shadows repple And it recognizes, you can select some particular build. So let's go look at that shadow file again, right, so here's the repple port I just mentioned, that we just connected to, here's a build name. So I'm saying, Give me the repple, for me, and it's gonna tell me that selected. But if I try to do anything in this repple, it's going to tell me I'm not connected to a JavaScript environment, right, because I closed my tab over here. So I open this tab up, I can run that it actually runs. And just to prove it to yourself that it's, it's there. You could, for example, say j s console, log high, or JS alert, I. And you can see you're talking to that, that actual browser. And just drive drive the point home a little little more, that this this code, this closure script code is ending up over here as JavaScript namespaces get flattened into the JavaScript environment, well not flattened so much as, as just, you know, app client, it is a function that I can call over here. And so if I define something, and the carrot export means don't rename it when you minify the code. But if I had some, you know, f of x over here, and I said, Make that x squared, I wait hot code reload, I should now be able to do an F of three and get nine. So that was, that's what the compiler is doing. Now, very often, you'll want to actually run code that you're playing with, from your editor. And that's particularly handy thing to do, while using any Lisp. And so I might want to, say, send some sub expression that I'm working on

to the repple. So you see it, I press the keyboard shortcut there, and it appeared in the bottom. And what I'm actually doing here, if you look in the it's command, comma, on Mac, to get to preferences into the key map, you can just search for send form. And so there's send top form to the repple and send form before carrot to the repple. I have a lot of my closure key keyboard shortcuts set to Ctrl C followed by a different control sequences control C for closure, and then F for top level forum and ever expression before the the carrot and such I just made them up. So they were dramatically easier for me to remember. So these two things are, it's a good idea for you to set those to something useful, because you'll use them quite a bit. So what I'm hitting here is the one that sends the expression before my carrot. So a form range is anything surrounded by parentheses, it's any structured thing, I could send the number two, I could send this addition. Or I could go to the end of the function and send the entire function to the repple that defined the function. Now if I'm in the middle of some nested scope here, that's what the other ones for. If I send a top form to repple that basically says walk up to here and then send the whole thing and then if you're in a comment, block, send top four means say I'm in the middle here, you look down here you see it sent the whole def a, and it ignored the fact that I was in the comment block. So those are all useful things to know you know how to select to build notice in forms to rebel, you know how to get that browser connection. And you know how to get your your project up and going. In the next video we'll talk about actually doing some some stuff with folk

