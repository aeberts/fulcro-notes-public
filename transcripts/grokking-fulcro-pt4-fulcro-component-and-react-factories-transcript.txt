So let's talk about factories. And how full crew kind of renders and hooks things together. So we saw in the last last few videos, and if you've been using full go for a while, did some stuff up, I was kind of tinkering. How you know how we can post components, we have the CO located query the ident, how we end up with initial state. With that, I've got a quick little demo app here to get us started on just talking about things I mean, an app, I've got an increment mutation is action, updates a counter by IDs count by incrementing. It, I've got a counter that has an ID and account, initial state of ID and count with incoming parameters of ID and start. The button itself can transact the increment, mutation, and route composes it all together. And you can see here in initial state, I'm initializing too many. And remember, this is a magical thing. If I have fn of params. Here, I would actually write get initial state around each one of these maps with the class counter, but because the query already has the information that the child is counter, this, the macro can look at this and say, Oh, well, you mean to call get initial state with these brands, and these brands and these brands and these brands, and plug it in. As you can see, if I load this app, and I go look at full grown SPECT, I am the four counters, their their IDs, their their initial counts, I've already clicked on that one once is why it's different than the initial state that's listed here. Okay, so we talked about how that happens, we didn't quite go into great detail about the specific normalization process, but I did sort of show you that your initial state comes out like a tree. And that folklore has, it has a function inside that can take the query and a tree, turn it into your normalized database for you. And then of course, rendering does the opposite. It pulls the query uses down on the database to pull it back into a tree shape, sends that through you D structure the resulting tree, pass it down through your various tree of components, and voila, rendering habits. Okay, so a few little comments here. quick reminders, what have you that a mutation. This really is a macro that emits a deaf method, multi method. And this just makes it much easier to you know, navigate your code by being able to jump to a symbol. And a mutation encompasses both local and remote kind of behaviors. And I'm only doing a local here, we'll talk remotes later. And then of course, calling a mutation does nothing more than admit, Oh, hold on, let me switch to shadow rebel app, I can evaluate

in the right namespace. Oh, Id isn't there. Let's put some number in there. I'm trying to evaluate this increment, counter blah. And you see that what it emits is a list with the symbol demo app increment, and the map of data. So this is that well documented in the book, I just wanted to remind you that you used to an older folk grow versions, quote these and then have to unquote, them whenever used a variable in order to get kind of the same thing out. And in folk or three, we actually Thomas Heller, Shadow clgs suggested this cool idea, why don't we just make that thing that we admit, act like a function that when you call, it just emits itself? So you don't have to do the quoting, funnel suggestion anyway, how does transact work? That's that's sort of at the core of what we're going to be talking about today. I'm trying to talk about factories and how things compose. But really full grow is here to do a lot of things for you. Not a whole lot really just state management, and interaction with networks in a structured way. That's really the main core piece of poker, right? Get your data into the client database, lets you pull it out and render it lets you update it optimistically. So you can have really fast user interactions with information. But then let that interaction that abstract interaction, possibly also talk to a server about that same abstract interaction. For example, I can make this this particular operation. Go over that work simply by doing that, that's all I have to do. We already know that the operation is increment, we already know what the parameters are. So I can build a network protocol request out of that, get the response, the response can send back a tree of data that I can merge, etc. There's all sorts of pieces. That's really what full groes secret sauce slash power is, is this combination of query and ident, in particular, gives you the same unified story across everything, no matter what it is, whether it's your client side database, UI, local data, concerns, remotes, it all integrates, and works the same. So but how does transect work, you pass it this will, this is like, it's a reference to the React instance, that's running in the DOM, or that's, that's been stuck onto the DOM, right? It's really a tracking nodes that react creates, and associates with the DOM. And so why or how does transact, use quote this, in order to operate with the Volker application, I mean, obviously, it's got to be able to get the application from this somehow, right, you create app up here. That's the full crap. This is the thing that has the glue. It has the database, it has the the networking remotes, it has all of the pieces, the transaction log logic, which is actually a plugin, you can just override if you want, all that's in the app, and transact needs to use it. So if we go look at transact, man was gonna jump straight to the function. And look what it does. The first thing it does is it says, Oh, well make sure I can get the app off of the component. All right, well, how do we do that? Well, we get the app off the component by looking to see first of all, well, what you passed is already an app. And we're done. Right? That's, that's just good enough. But if what you passed is a component react instance, you know, the thing that that the factory created, that words, this that react keeps around, then get raw react prop is just a wrapper function around ISO get in, which is just basically

a thing that works both in closure and closure script to pull things off of what might be a JavaScript map. So this just uses Google object get by keys. This is just a way of making sure that I can pull things off a JavaScript map just as easily as I can off of a regular closure or closure script map. And remember, I'm working with react here. So what I get from what I have, when I have this is a JavaScript object. So I'm saying from the JavaScript object, get the full crap. So there's the trick, that you really need to understand to understand what fulcrum factories are doing. They're not just react create element, they've got to do just a little more. So things like transact can work. So basically, the core idea here is that when we render one of these components, which actually react renders, right, we ask react to render the DOM and hand it the root component. And then it goes through and, and calls everything. And then of course, we're calling these these things. But at the end of the day, something has to emit a react, create element for this component class or hooks function in order to get a react element that react can use to render. Remember, we're interacting with the JS world. So somehow, the app needs to get on this. How did that happen? Well, there's a bunch of different ways you could do it. Right. So let's say, let's just go to a very, very simple, let's say we had, and I'm just going to use my this is just a wrapper that directly calls create elements, this is just a low level JavaScript called create element. I'm going to pass it sample thing. We're past the maps, I'm going to be here, I'm going to make a component, a focal component.

And I'm going to ignore props because what I'm going to do here Next, I think I just have div.

Right? In normal react, you pull props out of this. And then whatever's on props is what you can say render. So let's say I want to pass a message to sample and have it render that message. So that's my little component. And here, I'm not going to create a factory for ground here. And I'm just going to say create element of sample with j s. Message of Hello, and I comment out this, this bit here. And I'm going to get an error. The reason I'm going to get an error. So I'm asking for a phone call component to render and the focal components basically going to say, Oh, it's seeing all sorts of things here. See if I can get a cleaner starting error cannot find app on component. I mean, that's that's at the core of the problem here. And that's because the component itself assumes it's going to be working in a full context where Sample this guy that I might call transact on it. And there's some other things that def SC does, it actually keeps an index of components which is stored on the app, etc. So a full core component cannot work at all, unless it knows what app it has Now, remember, full CRO, was originally built and designed to react 15 there was no such thing as react context, then, here one day, I may refactor fo CRO to use react context, because that would make this problem a little easier. But there's, there's some other things that we we would need to do as well, to do that. But for now, what we could do to fix this is just passed the Velcro app as parameter. So this is exactly what I do behind the scenes. And you see, it's rendering Now, in order to give this thing enough context to be able to work with, you know, now being able to put like an onClick handler on this div that could run a transact. So that's what the interrupt would look like, if you wanted to just use, you know, sample was a kind of plain thing. Now, we don't really want to deal with JavaScript Maps up here, we don't have to do this JavaScript D structuring, we get all confused about this whenever shadows in that shadow closure script, I mean, shadows, just a build tool closure script goes to compile this in advanced mode. And if it doesn't know whether or not this is a thing you built in closure script or a thing you built in JavaScript, it might rename props and message to a compressed symbol name, which because this is react wouldn't play well. And so this is the point of have this kind of mutation where you can say, Oh, yeah, I really know that this thing is a JavaScript ism, and that you really shouldn't rename these things. But then down here, I can get into trouble because this one will get renamed. So then I would have to quote it. Like there's all sorts of things you get into trouble with your if you try to just manage this by yourself with dead code elimination, and the advanced compiler should renames. So what we'd rather work with is full grow. And actually do actually internally, actually, the keywords end up being strings. So that's actually okay. So what I do as well is on the JavaScript props.

I store the closure script, things that you might want to send in on this special full curl value of the JavaScript things. And the factory, I can pick that apart and pass them as props here. And so now you get the nice, D structuring. And all good. So that's basically what a focal factory is doing. When you say def give me a UI sample factory, I want a comp factory for sample is it's realizing Oh, yeah, you're gonna need to know what the app is in there. And that's technically going to be passed on render from folker itself, right. So folker calls render, and it goes ahead and makes a dynamic var that binds app so that the app can be placed on this as each factory hits it. I'll show you this in a minute. But that's, that's essentially what this guy is doing. So now I can come down here and do something much simpler. And say, UI sample, and use regular closure script props, I don't have to say anything about the app. And I don't have to use some special weird key to work around the fact that there's a JavaScript map underneath. And so now I'm rendering. Okay. So let's look at an actual factory, or the actual factory function and talk about some elements here, I've got gotten you the basic idea of what's going on. And hopefully, understanding this will really help you when you're trying to interact with react, and you're trying to understand what's going on. Because when you're calling a react component, you have to pass plain JavaScript props. And then when you want a react component to use something you wrote, as if it were written in plain react well, then you probably aren't going to use def SC for that, that component. Or if you are, you're going to have to wrap it in such a way as you can, you can set these things so that the focal component can operate properly. By the way, if you want just like a cross reference for for what that looks like, you can look in the Developer's Guide under floating routes, because that's one of the ways you can you can implement a thing that can eventually just act like a plain react kind of thing you could use, while also having full access to Focus Features of feeding the tree from the central database. We're not gonna cover that in this video, but I just wanted to mention it. So let's look at factory let's let's talk about what all we do here because there's quite a bit here. And I don't want you to be too intimidated by it because it's really at the core not that bad, a lot of lines of code, but a lot of them are, are really straightforward. So fulcrum supports props middleware, where you can actually have an individual components props modified as you render the tree. I don't personally use this feature, it was a feature that sounded like a good idea when we added it some time ago, I don't know if people are using it. But that's, it's there, you could use it, I personally have never used it. The whole key and ref thing is just lower level interrupt with react itself, right, you need to be able to set a key on things that are in a in an array. When you call factory, right, you're just creating a function that ultimately calls create element. Right, that's really all you want to do is you want to call create element on your class, but you want to have it work right with velcro in the full context. So let's look at what all we have here. Really, the main thing to look at is props is a JavaScript map. There's a special one I told you about the character props. This has to do with dynamic queries. So the queries on a component can be changed at runtime. And the query that you set is actually normalized and put into the normal database. So that as you move from state to state, you're actually tracking the query with the rest of the app state. So this makes it possible. Technically, the time travel to an exact point in time in the history of your app state, and get everything including the dynamic queries set, right. That was some somewhat complicated yet working right, but, but you'd have to look in the book on dynamic queries to learn what these query IDs are about the app I just told you about. We also track two additional things, the parent, and you knows we're using dynamic bars here. But we're also putting these on what will eventually be this. The reason for the dynamic bars has to do with who's in control at what point in time. fulcrum is in control. In some of these cases, where a dynamic bar can be set, and again, context didn't exist back when when folklore was built, it would probably be the better implementation for this. Now, I just don't want to muck with these internals and potentially break everything. So let's not worry about that.

These dynamic bars are set by focus context. But then when react goes to work on things, it often does things asynchronously. For example, event handling, somebody clicks on a button in this app, right here we have a perfect example, when you go to click on this react is running this function from an event handler, dynamic version, no longer set from when folco did its render. So you can't trust the dynamic bars, you actually have to copy the stuff you care about on to this. So in one phase, we have the dynamic bars, and so we can use them to make sure we can we can put things on here. And then another phase where react has kind of taken over and is doing event handling and things. We need to have copied these on to the elements that react plugged into the tree so that we have access to them. So it's a little hairy to follow when you think about it, because there's this asynchrony going on behind the scenes that you have to you just have to deal with it's JavaScript land underneath. And so while we can like make it look nice and clean and note and do not call Baqi, etc. At the programming abstraction layer, the fact is, it's still JavaScript, there's still a synchrony, there's still this kind of mess under the hood. So we're taking care of that mess for you. So kind of kind of ignore the props middleware. So that's a lot of us, you can ignore the key and ref. Because that's just standard react stuff. And then this big block is just dev time warnings. It's it's me trying to find, you know, tell you common things that you might be doing wrong, that that don't look right, like one of them here is, you know, this this error of, hey, you rendered this outside of apparent context, because I couldn't find this dynamic far. Right? That's, that's just a warning slash error to help you get things right when things don't seem to be functioning, right, find those things. And then it calls great on the last little bit of this, this with meta, so we're adding metadata to this function has to do with the dynamic queries, as well. There's one more piece we put in here, which the class which I think is also dynamic queries, I think all three of the elements have to do with being able to set dynamic queries on a component at runtime, to change the thing. In fact, dynamic routers are named that because they've dynamically changed their query over time to to not over query your client database when rendering some very small portion of your app. So dynamic queries are actually pretty important. But again, not talking about him this time so you can see really the only thing you've got to do to make this work absolutely, right are these two folk revalue, folk rap and create element these other two, the focal parent, this allows you to ask who's my parent, we use this and there's a localized Dom support in the CSS library, Guardian CSS library. And we use this to determine, you know what to put on the, basically, you define a CSS class and it becomes localized to the component. And the way we localize it is by looking at parents and saying, What is parent? Okay, give me a fully qualified name of the parent, I'll tack that into the class name. And that's your local class. depth is used to be used and still is used, I think it's still used by certain rendering optimizations, if you turn them on, but I don't recommend turning them on. So right now, the ident, optimized render, I think uses this. And depth is one of those things where you can, if you're going to cue up a rerender of sub portions of of your react tree. If you find that one component is a parent of another, and they're both in the list of things to refresh, you can kind of throw away the deeper one, right? The one that's that's depth below the, the other. So the depth just has to do with with being able to sort things so that, that your rendering can be optimized. But like I said, the current renders that I recommend, don't really even use it. So you could get away with being a factory that really just set value and app. If you're going to change the query of the component, you also need to have the query ID on there. I'm not suggesting that you write your own factories, most cases, I mean, I, I never need to, for my own development purposes. But I know that some people do a lot more react and Rob than I do, and sometimes hit up against this. And so understanding what's going on here, you look at this big blob of code don't understand well, now you grok it, there's, there's how you get props in, there's how you make it interrupt with transact properly. Here's how you support query IDs. The other two are nice to haves and are easy enough to set. But that's the factory now. Think about what react does when I go and mount this tree.

Let's actually just go look at Mount. Mount does a number of things. And the interesting ones really are remember what the root is. That one's interesting. Setting the app ID recently the mount point shared props. Most people don't use those remembering things. So really it's mountain goes through, looks up the elements you told it to mount the application on, makes a factory for the route, you told it to mount records things in its runtime location, right, which thing you mounting on? What's the factor, I need to render route with? What is the route class, it updates, shared props of use shared props, that's just an extra thing. It indexes things. So indexing is a really interesting thing that most people don't know about enfagrow. And I'll talk about it in some later video. But But the idea of indexing is remembering by query element, which things on screen use those query elements. And remembering as things mount, what the ident is for the thing that melted on screen. And this can be used for targeted refresh and rendering optimizations. So the indexing has to do with finding things at runtime. And so all of the components in folklore are rendered pairs are indexed by a number of things. So really, a lot of this, these pieces have to do with other features of photo and then just render. And if we go look at render, render, finds the optimized render. it updates the shares again. It does some render listener pinging A lot of people don't that's there. And then just call the optimized render to refresh the frame. So that's, that's basically there's also a render route in here somewhere. So new mount. Was that melt? Oh, no, that's render sorry.

All right. And if it's already mounted, we do the optimized render if it's not already mounted. Then where is the actual? Oh, it's right there. Yeah, it's right there. Render. Okay, so why did I want to trickiness of the render, sorry, there was an issue, additional thing that I really did want to show you here. And that's that this binding. So when we go to do the render, we bind these dynamic bars. Right, we started zero out there at our depth out there, we start shared props out to whatever the shared props currently are. And then, and then basically do the render. Okay, now there's one more element to this. That's, that's interesting. And it's probably the more complicated of all of the three elements. So we have this dynamic four thing, we get the factories that are morphing the JavaScript mess into closure script, so we can think about it more easily. And the next thing that gets sort of hooked on to bifulco is the component itself. Now, this depends on whether or not you're using hooks, or class based components. So you can actually turn this into hooks based just by doing that, and that basically has this emit a function instead of a class based thing. And then it hangs the extra fulcrum stuff on the function, because functions in JavaScript are just objects, you can plug extra things on to. And use hooks mode also switches over to using hooks based use state and use effect to add any extra stuff that Volker wants to have on there. So let me show you that real quick. So if we go look at the macro, the macro does a whole bunch of error checking and morphing and looking at what you did, and making sure everything looks right. It defines the actual symbol you want to find enter a def once, and hooks up a render function to it. Now the interesting thing about all this mess, I know there's quite a bit of it here is as you go down through here, either. See now, so we have a cond hooks. So this is you said use hooks, or its closure script. And so we should use a class based or its closure. And we should admit something that, you know, works in the closure side, mainly for server side rendering, because these components themselves don't have a full implementation of react on the server side. Unless somebody chooses to write it, there's nothing that would keep you from doing it. But in terms of rendering, it's just like render to a string, right? There's no dynamic transact support, etc. Again, all that stuff works in closure, it's that the components themselves aren't necessarily hooked up to do rendering route. There's a guy that's actually playing with a JVM based closure, rendering for Velcro. So it's doable, I just have no interest personally. So what goes on here, let's look at the hooks one, that's probably the easiest one to render just because there's less like object oriented cruft around it. So you see here that the hooks thing basically takes the I got this useful CRO ad hoc option, let's just go look at that. So the actual ad hooks options takes the render function and the component options that came from the macro, it extends the render function. So this is where it actually plugs, the component options in as a prop on the function, right. So like the render function, dot dash, or dot neofolk, or dollar sign options, gets the map of things that you're putting, just see this. Right, let's kind of put x one in that map. And now if I go to the repple Ls, I can go to the repple. Let's just go here to the plain old JavaScript thing and say demo dot app dot sample dot, full grow options. There's our persistent array map with two things in it. And one of them is x one, right render gets added because it's the body of the thing. So that's, that's literally what this thing's doing is it's sort of it's picking these options up and throwing them on the function. It's doing a little bit of glue logic. in between.

It's adding like, you know, things that the closure script print system can use to print things nicely when you print a component. It's remembering the registry key, all of all of the components go into a central registry, this is literally just like swap ASOS on a global, right so that you can look up components by their fully qualified keyword. And then this returns the render function so and remember in a hooks base component, that's all you have is the is the function itself. And so a hook based focal component is just a function It has these extra props on it. And the factory does a lot of the extra work around it. Now the render function. That's the other thing that's, that has a little bit of interesting stuff to it. So the sim here, the render function, right rates with component options, this is just a function that can pull that dot Volker dollar options off of the function symbol, right, that's all that's doing. So render is render. And then this useful thing is an effect handler, that does the extra stuff that a falkor based component needs in order to work properly in the entire full grow ecosystem. So you see here, because we just have a function, we're doing a react use state, where we're dealing with things like the depth and tumble props is off a whole nother topic, setting some of these additional things. And

use effect, which is doing component based indexing. I'm waffling now and whether or not I should have shown you the Configure component, which might actually be easier for other people to understand than the hooks based thing. So configure component. This is the closure script one or the closure is kind of it's kind of big. So configure component is when I'm making a class based thing registers the component. And it does a whole bunch of lifecycle stuff, because you can define, you can set keywords that are supposed to then make a lifecycle method that's JavaScript compatible. So all of these rappers are going through and trying to make each lifecycle method closure, script D, right. So when you get the props, you're getting folkers, props, not the low level JavaScript, e props, that sort of thing. So this was said, it's kind of big, it's mostly has to do with this, fix all the the JavaScript functions, so that you can use them as if you're using closure script functions. So you don't have to like de structure things in a in a crazy way. That's, that's a lot of the body of this thing. The other thing that it's doing, though, is when it's wrapping, component, will mount and maybe component did mount, I don't remember where it's at now. I mean, historically, these things were. Anyway, that's what these wrappers are up here, I just wanted to show you that for where's the index drop component, so there's indexing. So basically, when a component mounts component did mount, we find the index, we find the indexer, and add it to the index. So now we know this component with this ident exists on the screen as that element, so you can actually go look that up. So you can do fun things. Like if you wanted to put an overlay over a live Volker component, based on its ident, or the vocal components based on the right hand, right, you could have a person on screen that's rendered in three different places. And if you wanted to find those three components, look them up in the index, and then do bounding boxes around them or whatever, like you do all sorts of fun things with the indexing. So this looks a little intimidating, because there's a lot here, a lot of code here, but really, we're wrapping component did mount making it easy for you. To get something in component did mount that makes sense. We're indexing the component and dropping the index of the component. So you can do fun, you know, animation, or, or interesting things with on screen components based on their identity. That's something you can't do in plain react, right? You can keep track of the references to the instances, but you don't really have a well known identity for them. And folker You do? You've got an idea. You could say, Tell me person ID three, where is it on screen? Oh, it's over there. I'll go highlight that and show them right. You could do tour based overlays or whatever with this kind of thing. So that's the other piece of, of how things go. But at the at the when you get down to it, the base render, the render code that you write, does get wrapped This is there's another layer of potential plug in here. Grab piece render.

I thought I'd look at this code very often. So it takes me a minute. When I glanced at an enclosure script, we bind the stuff we call render. Yeah, that's it. So basically, it's just rebinding these during render because again, react Can, can do this in an asynchronous way. And so in order to make sure that transact that are going to use this inside of, of render have access to the dynamic bars. But the vis that we got coming in should have already had them applied by the factory. So the factory got them from the dynamic cars, put them on this. And then we're rebinding, the dynamic bars from what we find on this in order to reestablish that context. So it's it's a little area internally. And primarily, it's just due to the fact that we're trying to make it transparent, that that you can use things like transact when you need the app. Without having to make the app global, right, you should be able to mount more than one full application on a DOM page and not have them conflict with each other. So making just one global app and saying you have to make it global, and you have to call it this, that that doesn't really work. I mean, we could say you have to define the app and transact you call on the app. But one of the features of folk grow is that when you call transact on a component, you know which component you call it on, and that's in this, so then you'd have to pass the app and this and so it just starts getting a little ugly. Again, at some point in the future, we could simplify this, anybody interested in contributing, could try to do that just by using react context and see if we could just set the context behind the scenes at the root, and then just use the context throughout. And that would handle this kind of asynchrony mess. Because focals have not pocos react context, I believe, I haven't looked at it in the context of all these different places that we use it but I believe react context, in the lifecycle methods and in the render body works properly, in terms of keeping track of the thing you told it to keep track of. Whereas dynamic bars because they're, they're meant to act like a threaded nestable thing in closure and closure script, they were great at react 15 when we didn't have a better option, but just haven't got around to fixing that particular complication internally. So I hope that helped you understand how the factories are working in full CRO and how they differ from create element. And some of the additional little pieces that are there, that have to do with with getting these things to render, right? That, you know, those parallel complications of the dynamic queries, the dynamic queries are really powerful. And they really are the key to keeping your UI fast, not over querying everything in your UI. Because if you've reified your entire UI tree, and it's all connected, and you have a query that's all connected, then every frame, if you were doing a query that got everything that gets slower and slower, the bigger your app gets. And so when you use def router out of the dynamic router namespace, the way those work is they switch your query to point to just the part that you're going to render. And so that keeps your your query overhead kind of constant no matter how big your app gets. Okay, well, that's what we've got for this one. Hope to see you at the next one.

