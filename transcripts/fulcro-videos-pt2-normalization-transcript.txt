In this video, we're going to talk a little bit about how full CRO works from just a state management perspective. So this video is not intended to show you how you would actually write full applications. But to get you more familiar with the concepts that you need to understand really well, to be able to work with focus, they're not terribly difficult concepts. But if you don't start here, you'll be confused. So dive right into it. So foco, Deaf se makes react components. These components are the class based components, they have lifecycle support. And they pass their their data through from parent to child as props and your traditional react ecosystem. When you've got some subtree, where you're trying to deal with full stack data, you do something like you deal with in lifecycle methods, or you create a higher order component and have the higher order component manage that that state and feed it to that subtree falkor takes a different approach. It is it does allow you to manage things as a sub tree. But it doesn't want you to have to deal with the complexities of the higher order components, or having data potentially duplicated in multiple caches. All the chaos that kind of ensues when you don't have a solid data management model. But let's just start with with the idea of how folkers working. So you create an application that application holds on to a state database. And you'll notice the requires up your RAM grabbing different namespaces from and I've got this thing attached in the repple. Let's, let's verify that. So if I try to run an expression here, I get one plus 100. Alright, let me restart that. I had reloaded. And I was concerned that maybe that was the case. Okay, so talking to the browser. Alright, so now if I go over here, and I tell the the repple to switch to this namespace, and I put my single page application, the single page application is just a map. And you shouldn't necessarily assume you know, what's in this map, there are some things that are considered sort of publicly accessible, etc. But if you just look at, say, the keys and this map, there's Oh, that should be Why am I Oh, I hadn't loaded the namespace. All right, there we go. How about we use the right variable name? There we go. Okay. So it has several top level keys. And you see one of them there is the app prefixed state, Adam. And let me read that, and D refet. So you see, when I first start up, there's nothing in there. And I could do something along the lines of make a div here and say, show the string of props. And then I could do something fun. Like if I reset the app. I'm sorry, let me unthread this. I could reset that to something along those lines. You can see that there. And then I can ask for a rerender. And you'll see that data just pop up as a string in the browser because I'm directly rendering it. So that's the first thing to understand about full crew is full CRO, essentially takes data from this top level state atom and sends it through props. Now it does something a bit more advanced to to this database before turning it into props. But right now, we haven't told it how to do that. So at the moment, all it will do is just pass the entire database as it as it were, into this top level component as just a raw map. So let's say that I created some tree of things. Let's say I was working with some some root of a tree that's going to go with sample let's call it sample and then sample maybe has a child

that's a single person. So I couldn't define, you know, a person component with a person ID and a person. Name and I'm gonna drop these bits for the moment. And I could come in here.

So when you define a component that's exactly like a react class. And so you need to be able to create elements. And this factory thing gives you back a function that will create react react elements out of that class. And this key function is for setting the React key when there are adjacent ones in a list, which is a requirement of react. So that's just basic react kinds of things here. So if we reset our, our state schedule render, we'll see that that data come out in there. And so we could pull the sample props out there, which is a person and then say, UI, person. Sample. And we could schedule a render of that the hot code reload, look did that for me. And you saw the UI update. So as I as I save this, I'm racing shadow clgs, for building hot code reload. So I don't actually have to go into that schedule render, when I'm making that sort of change. So you see, at the moment, I can just, you know, further nest these things, and make some subtree. And very often, this is exactly what you do in some subtree of react, you create some sub tree, and then you're manipulating a sub tree. So maybe this person has some cars. And so there's a car with an ID of 22, that has a model. And then of course, I can continue up this tree.

Again, I'm gonna leave that bit blank for the moment. And now I've got a car factory. And so now I can say that this person has some cars

will melt that way.

And then of course, I need to actually put that in state schedule a render, and now I've got that sub tree. So I'm literally just building as you can see, in parallel, a tree of UI with a tree of data. And one of the primary things that Volker was trying to help you with is dealing with this tree. And so what it what it wants to do is define a database that you can use on the client, to have a few features that are really critical for dealing with data. And when you think about a database, and you think about kind of a right sized database, for UI work, you at least want a few features. So if I've got various UI concerns spread all over my screen, two of those different concerns, two subtrees of my UI, might be trying to display some aspects of the same thing. At the same time, for example, I might have a person list item that shows just the name of a person in some list. And when you click on that one to the right, a form shows up, that's the person form that lets you edit all of their details, those pieces of information are on the screen simultaneously. And I really don't want there to be caching concerns over those I would like I would like those to really be the same thing in the same database. So normalization is number one. There are a number of other concerns, I would like these things to be indexed in some way, shape, or form. And normalization, kind of ends up giving us that for free. And of course, I want to be able to pull from that database, what I actually want into the UI. And I'd also like some leverage in terms of creating graph queries for the server. And having my UI components be able to declaratively say, here's what data use, so that when I go to pull data for that component into the UI, I can pull just what it needs. So that's one of the advantages of a graph based system, you know, with a graph qL came up with and falcor from Netflix, like this is the the idea is let the let the UI ask for what it needs. And then will will satisfy those queries from the server which you can do very elegantly with path home. We'll talk about that in a later video. So I've got this data. It's structured in a tree. And what I'd like to do is normalize that. And so the first thing I need to do is decide, well, if I'm using closure data structures, because well, they're immutable, they're fast, they're already here, they don't have additional dependencies. What format Could I use to stand for this. And so what fulcrum does is it says, the database should be flat, we should identify entities. So for example, this person entity, we need two things to identify a particular entity. For it to be relatively well indexed. One is the name of a table to put it in. And the other is an identity for that particular instance. To put it down, and when I say table, I really mean map. In this particular case, that's what we have, we have either vectors or maps, and maps are indexed by key, which is a really nice property. So if I come up here, and tell folco a query First of all, here are the attributes that I care about, for this particular component. And I'm not going to while I'm going to deal with the subject here in just a second, let's just deal with these two attributes to start with person name, and person ID. And I can also declare an ident. Now this ident parameter in this map, query an ID and both have alternate interpretations, you can specify the multiple ways, the easiest way to specify an ident. And the recommended way is to specify it as a keyword, which is the name of the ID field of your entity. So so I'm going to use person slash ideas that table name. And I'm also telling folks through here that I wanted to use person, person ID, the keyword to look up the ID of some incoming entity to figure out where it goes in that table, some kind of doing double duty. If I've defined that, and it's gonna complain at me, because I told that I wanted cars D structured, but I didn't query for it. This is trying to help me not make a mistake there. So let's comment elbow, some bits of this. Okay, so full group comes with a function called merge component. And this can take an app or anything can get you to an app app is the easiest one, your wants the name of a component that represents the shape and identity of the data, you're about to hand it. And then you simply hand it the data

that represents one of those components. So if I've told it, to merge a person into my database, and a person has an ID and Name. And so first off, let's let's just clear the database. So the database is empty, if I render, there's nothing in there. If I merge this component, and then I look at

the current state of the app, I can see that what I get is a table named person ID, it's a top level entry, which is a map keyed by the IDs of the entities in it. So you can see that one is the ID, and then there's the sub map that is the entity. If I this is a cumulative. So if I merge another person. Now I've got two people on the table, if I merge another person, etc.

Okay, so that's step one, I can take a particular entity and I can put it in the database at a particular point. The next thing I need, of course, in order to build a graph of any kind, or tree, is an edge. And so edges are represented as the as a vector of the table, and the ID, which gets me to any one of these entities. So for example, the ident of person one is a vector, person ID one. And that would get me to this particular map just via a get in on the state atom. So that's how I make an edge. Now I can draw any graph that I want, based on that. Now, we had said in our Well, we haven't said yet. So our root component needs to be able to grab some edge, and perhaps some properties of its own. And by the way, the root component corresponds to the root of the database. So it's the only one that's not normalized, so it does not get an ident. That's a common mistake is to give that an ID do not do that. No identity for for root does need to query and the query will typically start off with something Like a join, join two representatives maps with a key and a value. So a join on Route slash person. And then a sub query. So here I would say like person slash ID, etc. What I really want is to know what person itself the UI component wants to know. Oops, what did I screw up with? This is it trying to help me not mess up? Okay, so the Git query function literally goes to that class and pulls its query. So you can see I can run git query straight on a person that will give me the query of that. The other thing that Git query does, though, and this is a really important thing, is it adds some metadata. So if I look at the metadata of this query, I'll see that the metadata of that query knows which component it came from, and some extra advanced information we're not going to talk about yet. This is the important trick. When I've got the, the query, which is what this function grabs from this component, it can look at the query in any any nested way and figure out which piece of the data goes with which part of the query and from the part of the query can ask which component, and from the component, we can ask to get an ident based on some props. So that's kind of the, the chain of events there. So I'm going to merge a component. And so let's say, let's say I say I want to merge the sample component, or the sample component should look like there's a root person, because that's what the sample component says it, it queries for and then under that there should be a person. So let me clear the app database again, see that it's empty. run that. Look at the current state again, oops, Oh, I can't use merge component auto route. Sorry, that's, that's a no no. Merge component wants to find the identity of this top level map, there's, there's a different way of doing route merge. So let's, let's stick with what we had here. We can we can go, we can chain it down a different way. Okay, so I have this, this one person that I'm merging, let's let's go back and add car back in. That will, that will do us a better job. So here, I'm going to do the same thing, I'm going to join person cars to get query of car. And the car, I'm going to say has an ident of car ID, and query but needs to at least include the car ID. And it looks like I'm asking for the car model out here as well. So I should should grab those pieces. And then I should restructure cars up there. So I've got it flowing through. So now, and again, we don't actually need any of this UI for any of this to work, we can actually just clean this up a little bit. For the purposes of demonstration, I can look at the the state of my app, I can clear it can look at it again, I can merge a person with a subtree.

And we'll normalize both entities into their correct tables and create an edge. And notice this is a to many edge. It's a vector of idents. And that was detected automatically because I put a vector of entities in the thing I was merging folder doesn't have schema for these. So if you were to put a single car in there, even though it's named cars, it's not it's not interpreting your English if I were to merge that, then what I would see is a single edge to one edge. So you getting it right is, is well up to you. So if you intend for that to be too many edge, you need to make it out to the edge. All right, so that's the normal the basics of normalization. Oh, I was going to show you, right, get ident of a car. If I give it an empty map of props. I'll get an error. Oops. Oh wait. I have to prefix that with actually shouldn't get an error. Actually, if I give it an empty map was giving an error because I was using a function that didn't know about. But given an empty map, it goes looking for the car ID in this empty map finds a nil and makes me Bad idea, right? So if you ever see a warning or an error in the console over here, about there being a nil second element in your identity, it basically means you pass some empty props through, while folker was trying to calculate an ident, and it couldn't calculate one that it thought was seen. So if this had a car ID of one, I'd get bad if it had a car ID of two, I'd get that, etc. And of course, the rest of the props that are in this map, just don't matter, I'm making an ident. So the normalization, really that simple. Walk the map, while simultaneously walking the query, looking at the metadata on the query to find which component is responsible for normalizing that particular aspect of the data tree, and then normalize it. And so what you end up with is this, this nicely normalized database, and now doing things like modifying the data of a particular entity. So let's say we go back up here, and, and we just hit undo for a bit and what it put the UI code back, we'll keep the query stuff in here.

All right, so notice, there's nothing in the UI here. And part of the problem is our root doesn't have an edge from route person to the actual person who have a person in the database, but no edge. And merge component actually supports an additional parameter that lets you target the particular thing, top level thing that got merged to a particular edge in your database. So in this particular case, I could put that person at route person. And now when I merge that you see it immediately shows up in the UI. If I look at the current state, you see, there's now an edge at the root of the database. This isn't a table now, these are tables, this one's not. That's one slightly confusing thing about foco is the tables exists in the root node of the graph, as well as root edges. Now, if I wanted to, for example, merge a car,

let's go with another Ford. That's going to put a wrong idea. I've already got 22, let's do 42. That would have overwritten, the other one would have changed the name. But that's not what I wanted to show you. Here, I'm adding a new entry to the car table. But if I just did that, let's go ahead and do that it's not hurting anything. Alright, well, now I have that second car in the table. But it's not joined into the graph anywhere. What if I wanted to join it into the graph here. And so this is the next realization you should have. Since this is a flat database, it's tables, IDs, entity, and then any join is an ident. That takes you back to the top. Hooking any sub tree, anywhere into the entire graph is just a matter of a three, Part Three segment coordinate, the table name, the ID of the thing and which field you want to mess with. So let's say the supports and append, I want to go to person ID three. Add that car to their cars. Now if I look at the state, you see the UI already updated. I can now see that I've added another edge to the graph. Now this applies for load. This applies for server pushes. This applies for data entering into folco in any way shape or form, you can always say, I've got this data, it's represented by this sub tree of the UI, merged in. And that'll put it in tables, and then connect it to the graph and the following places. And so the functions that let you connect the graph, or the thing you just loaded into multiple places, it accepts multiple arguments. So that makes it very flexible. Also, if you think about refactoring when you go to move some UI tree from one place to another, the higher order component thing is nice in that you pick up the higher order component, you move it to a different location and Okay, now you've taken the kind of the data stuff with it. It's not nice in that if you want to, if you want to pull some sub tree under that higher order component that's managing the data off and put it someplace else. Well, you've now disconnected it from its data model. In folco, the disconnecting it from the data model is as simple to heal as tacking in a new edge and your database graph. So you pick up something from one place in the UI, put it someplace else in the UI, you know, correcting the data model, even if the data was loaded somewhere else in a disconnected way. You can you can heal this data graph very, very easily usually, of course, sometimes life cycle and things mess with you, just as it would in any other system. So how does the data get here? When does it get here, those kinds of things, timing issues are still timing issues. But in terms of compositional issues, the data is composed in this very nice, easy to deal with normalized form. That's fast. It's fast query, it's fast update. If I want to change a person's particular attributes, it's just a, again, another thing we put person's age in here in the query.

Right, so I've just specified a new thing that I might want from a server that I might get from a server push that I might want to manually put into the database. In just one declarative step, I already know where it's going to normalize. And in fact, if I want to go look at it in the database, I can go look for that particular entry in the table and and see what's there. So let's go back down here. And let's do a little more magic. Now. Again, this is not how you write full graph specifically, but I just want to show you that it's, it's very simple data underneath. So if I run swap on an atom, I can modify what's in that atom. So I can see a sose in person ID three, person slash age 22. And so now I've modified the database and go look at the current state. It echoed it back me. Oops. helps if I put the associated out there. Okay, so that looks better. So the personnel now has an age. Oh, and I crashed the rendering with that snafu.

I had to reload the browser. Now, I don't have anything in my app state.

Oh, I didn't want to pin that there, though. I wanted to replace route person. Alright, so there we go. Now we got our age in there. And you can see it's rendering properly, our states proper. And the point I was trying to make is that now I can do things like update person's age and bump it by one. And since I'm not going to get a good hot code, reload, it'll rerender. Should rerender their person aged, I put it on the right place no. Person ID, oh, wrong person, person to incremented a couple of times. Look at the state, save let it hot code reload. There we go. Now we see there, the number updating. So statement emulations, are always very, very simple operations, because the data is always in a table at some ID, and then some field. And the manipulating these edges, there are helper functions to let you integrate an identity into an edge, remove an identity from an edge, etc. So I guess in summary, foco lets you materialize your views as both data queries and structure all together and materialize those into a normalized database that's very easy to work with. In future videos, you'll see how we actually use these things to write a full blown application. But this should get you through kind of the hardest part of understanding how the magic of normalization really isn't that magical. How you end up with a database like this, and then how you can work with it. Well, obviously, you're not going to use reset swap. You will use swap but you'll use it in a more controlled environment. So till the next video

