So I was chatting with the slack user, and they were asking me about potentially using Fulcro inside of a reframe app. And, you know, I've been sort of pondering and musing around that for some time. I know that reframe uses, and more of an event slash subscriptions slash reducers style of, of UI control. And you know, like the hiccup syntax of the UI, although you can get that by just using soblono with Fulcro. But it got me to thinking whether or not and how easy it would be to use reframe, now, disclaimers, I'm not actually a reframe user, I have not written an application of any size with it. And I'm not even sure that the things I've written here that I'm going to show you are well reasoned and insightful. They seem to work, I think it's an interesting avenue to go down. Particularly, it makes it much easier to introduce folklore and its concepts into an environment, perhaps, where you're already using reframe, and you'd like to get the advantages of the full stack graph support that Fulcro has, well Fulcro was written to actually run the headless so you can let something else control the UI and let Fulcro just control the database. Now that's, that's the main aspect that I'm not sure how looked at reframes internal architecture enough to know whether or not it's truly happy with what I'm doing, but it's tolerating what I'm doing. So let me walk through the project here. So my intention is to show you that Fulcro full stack abilities can be used with reframe, doing the rendering, and you get a lot of leverage out of that a lot of the namespaces and Fulcro will work just fine. On nothing but the database, you don't have to have full control of the UI, now you do lose some things. Of course, Fulcro gives you just kind of a different model of doing a few things, you're not going to be released things like the dynamic router, you probably wouldn't be able to use things like you would be able to use things like UI state machines, I'm guessing, forum state, for doing minimum form, diffs, etc. So you can get a lot of mileage out of the full stack support and Fulcro, while not using all the Fulcro. So let's play with this. So we're doing a full stack example here. So I've put together kind of a minimum template, I've got a user name space where I've got to start a stop and restart that will reload namespace. So I get at least some, you know, server side, code reloading, and I'm using mount as the thing to control state. So you see the server here is pretty simple. I'm using Fulcro, config mechanisms to load config files, it's really simple. It just lets you define a default EDN file with things you'd like as defaults. And then a dev or production or whatever EDN file. When you load an alternate config file, you name which config you want to load, it basically deep merges the target file overtop of defaults, that we don't have to specify everything. So I can debug, or I'm sorry, dev mode, I want to debug logging. But by default, my logging levels, info, that sort of thing. So that's all that is. There's middleware, the middleware is pretty straightforward, I generate the Index page using hiccup. I've got a little wrap API function here, that's a Fulcro ism, this adds a little bit of middle glue to talk Fulcro back and forth. And then a little check to see if we're doing route or index to respond with the index, otherwise respond with the rest of the stack. And the stack is just wrapped default, such as the normal ring defaults, wrap this HTML routes. Deal with transit, we use transit for Fulcro's back and forth. Wrap API, there's where we do the handle request that hooks into it. And then not found if nothing knows how to handle the request. So standard middleware, and then the parser or rather, the Fulcro  system uses a Pathom parser to give you EQL parsing, right because that's what Fulcro speaks in. And so if you go look at the Python parser here, pretty standard fare, I just build a parser set up the mutate function, give it the readers placeholder, various plugins, register my resolvers, etc. So just standard Pathom stuff. I do have an `all-resolvers` var here that's holding all of the resolvers I've defined. And if we go and look, I've got some, I've got a mock database here, which is just a quick Datascript database. So it's like Datomic where you can just specify the very minimal schema where you specify your refs and identities and then we can transact some data. So you can see I've I've made a database with the schema and then I've transacted in four people. All happy,

some have children, right. So person 4 has children 1 and 2, which is, you know, Amy and Sam, etc. And everyone's got an email address. And then some people have addresses. So person address here is address six. So there's address six Broadway in Miami. So that's the database. And then in terms of the model, I've defined just some simple resolvers. So to get the details of an address, you supply an address ID and then this will give back the street and city. And this just does a plain de Tomic style pole query and get rid of the logging there. person has a few more it has a top level resolver where it requires no inputs, it will just output all the people in the database by their ID. And then there's a person resolver that can take that ID and join it to the details of the person and address ID and person ID and of course, then the other resolvers like this one in the address resolver can fill any additional details, path homeworks all that up. So all these resolvers get placed into a vector. Again, this is just standard eql path home parser stuff, they go in here. And so now if I stand up this, the server which I can do in the username space, so this is just a, essentially a repple. And I've already started shadow clgs here, so I just did a yarn for the client side, show clgs watch main, I can go here to Port 9630. And I can see the the build progress, whenever I change something, we'll see that in a minute. And then all I've got running here is repple, which is just that basically, I just have a running inside of IntelliJ. So I can send things to it. Alright, so I'm going to restart, it runs the thing on port 3000. And so now if I've got in the Chrome Store, there is a full chrome inspect dev tool. And already in this Volker inspect of tool, I actually have to Sorry, I have to load the app. So I'm running on port 3000. So I can load the app, go to the folkert inspect tool. And already, I can jump to the query tab. This button asks it to load indexes, you see it ran a transaction over there. And so now it'll give me autocomplete. So I can say, Okay, I need to join on all people, and I want person dress. And then I get a result that says I need to widen that out a little bit for you to be able to see the details. Here's all people to the people do not have addresses and two other people do and their addresses 101 a one. And something I can see Oh, well, I need to obviously join on that. So I'll say person address, and then maybe I'll get it up, see the autocomplete Street and address city on that. Okay, there's those people live, oh, well, it might be nice to know who these people are. So let's ask for their email address.

I want to get a new line here without autocomplete. And I can see those. So you can see we've already got the graph API for pulling things from the network. And the server is responding as as. So nothing special there. That's just standard path home. And the full curl tool, this this query tab and the index explorer and such are available in path on this, which is a standalone standalone tool for Python. So you could still use it that way. It's nice to see what you've got this integration work working, you can just use this. So now to the integration. So let's talk about the client side. So there's really light in the application, I just made this quick little helper function. And so here's my approach, I'm generating a standard folco app, I'm turning off all rendering, so I'm basically telling it to render a route, you do nothing to hydrate, you do nothing. And to do an optimized render, you do nothing. Folk rose fine being headless. But it will call these render functions, we need to make sure that they're not going to fight over the UI. And then the other thing I'm doing is a bit of a non standard thing. folkert doesn't really care. It generates an atom for its state database, but it doesn't really care if you set when you'd rather use and so I'm setting reframes dB, to be full gross data. So now, both reframe and the full grow app are using the same our Adam as the database. And so then I can say def one, some folk or reframe app, and then just give it the standard folk or options. And here I'm setting it up with an HTTP remote to whatever host I loaded from add slash API, so that just matches my middleware. It's not I've got a single page app that is a full curl reframe, combined app. So that's really all I had to do to set So let's see how to actually use it and what we get out of this. So really only one namespace left. So I'll go hide that. And that and let's look at this. So setup wise, I defined a render function and then a refreshing and and deaths over here my shadow clgs. file I said, main. To start this application you call the init function and during development after a load call the refresh function. So it does a headless setup for full curl. This is a standard function, focus support server side rendering, so the idea that it will be running without a DOM is known to it. So it has this function for saying, alright, I'm starting you up, here's your root component, which can just be a dummy component that queries for everything and has nothing. And whether or not you want to initialize the state or not depends upon whether or not you make root actually have something interesting in it. So you could do initialisation, like folker does initialisation or just ignore it, right, set this to false and just let it run. This normally happens on Mount but because we're not going to actually mount the folk route, this tells it to connect to the fulcrum inspect chrome tool. So if you want the tooling, you can do that. And then of course, render does the reframe render function onto the app div. So that's the setup there. From here, we can write standard, re reframe stuff, and we can make some pokhrel stuff. You see we're doing data fetch loads here. We're doing transacts here. But we're doing subscriptions here in here. So let's look at how those work. So first of all, the folker database, you'll end up with a UID in here that folks inspect uses, because you can run multiple folker apps on a single page. So each one gets assigned EU ID, so you can choose amongst them. Okay, so let's kind of run through some of the pieces here, I've used def SC, which is a full crow ism, so that I can define normalized queries and idents. So I want to normalize database. And this is just standard full crow fair, I actually don't need my my live template and IntelliJ generated those bits for me, all it really needs the query in the identity. So the query is what props, I want to query from the database, the ident, really just think of it as the key in the query that stands for the things unique key. And person, same thing, so person ID is this guy's identity. And then it also has an address whose query comes from address and an email and whether or not they're happy. And then a recursive query to itself that says it's children are also persons. So that's what the dot dot dot the quotes there, because otherwise, that is a symbol, and you'll get a compiler. So that just make sure that the dot dot does recognize as a plane symbol.

Alright, so we have a way to query for people and recursively, even, and addresses. That's kind of nice. So now we need a way, well, first of all, we can we can show you just very simply. And maybe I will take the UI out of it for the moment just to emphasize the point. So the apps got nothing on it. So something like this load. In folco, you can give it the app, the key that you want to start the query at. And then the component that has the sub query, the reason you give these components is because you've got a sub tree. So it can use this component to figure out the ident to figure out how to normalize it. So when I run this load, we watch the database on the left, have to be in a closure script repple sorry, start a closure script repple, which is just an N repple. So we'll connect to this that browser window.

Right, just to show you where we're actually running in the browser. So if you watch the database there, I run the load it says load all people. So all people points to person 432 and one, and then person 123 and 4.2, address 101 and 100. And their children point to person one and two, and person three. So we have a completely normalized database that has all the people and their addresses. And then of course, up here in the address table, we have address 100 and address one a one with our normalized data. So so that that simple setup gives you this nice normalized query, put it in my database, and I'm ready to go. Ready to render. Now since this is actually the our atom that reframe is using Well, now it's really simple to define queries to run against that. Now, of course, when you're going back to the UI, you probably want to turn this back into a tree, right? It's normalized, that makes it really easy to update on the fly. But typically, your UI is going to be a tree. So you're going to render a person, tree, etc, etc. So let's look at what those those queries look like. So I wrote several different versions here just to show different ways of pulling things out. But this is the primary function in full core that you can use to go from the database into a tree format, and it just takes an SQL query, you could write this by hand. And then it takes a starting entity, which if you're starting from a root key, you can just use the database itself. And then the database for looking up refs, which is, of course, the database itself. So this is you'll often see this twice, but you'll see down here, it's different. So for this one, the idea is we'll pass a root key, and a component will use get query to get the components query, join that to root vn eql, join, and then run DB two, three on that eql to get back a result, and then we'll call get on that resulting tree to pull the root out because we probably don't want the root, we probably want the sub thing that we were going for. And then a couple of alternatives running SQL is a function that given eql, just flat out runs the eql on the database, and then we've got ready qL entity This is if you wanted to, say get a specific person, say you could give the identity of the person and the sub query that you want to pull for that person. And then this could use the AQL starting at that person. And of course, the DB his last argument there. So these are just, you know, three different uses of dB to try to get a tree back out of this database. So we can define a get person as and this is just a raw raw one. So run DB to tree using person's query, starting at person with that Id similar thing, so that I can just go through and register you know, queue as the base Run Query eql eql, entity get person. And then I can use those. So I made a little function here for rendering an address that just shows the street and city basic person, email and happy. And then a UI person down here is non recursive. So it just shows the person and lets you alter their mood. We'll talk about that in a minute. And, of course, you could also use reframe events, your dispatches to modify the database. But if you're wanting them to be full stack, and in this case, this one is full stack, it alters the mood both in the database and on the server, then you can use focus facilities. And then UI person tree is a recursive one that tries to show you all the details. It says Alright, we've got a person will show the basic details, then let you alter their mood. When there's an address, well, we'll show a UI address for that address. And when there's a sequence of children, we'll make an unordered list of those children using a recursive call, right, so that should all work out. So then here, we can see these various things working. So person subscribed to eql entity where I use this ident. So an ident really is the combination of which key is the ID and an actual ID in a vector. And then here, I can use manual AQL. Right. So I could have I could have also put joins in here, right? Person address, address, Street, you know what have you. And that will give me back a person. And you can see I've already because I already ran the load. Let's start with a fresh app here where nothing is loaded.

So if I load a single person, that's this button, it's going to load person three, and to the person. So I get Sally at nowhere, who is currently happy. I could alter her mood to sad. Reload the page loader. Oh, she should be sad. Why is she not sad? Often, we'll address that in a minute when we see the full stack support that should be working. But for some reason maybe I didn't register the mutation. So there's a subscription to St eql. This one is subscribing to the all people key that gets low added by this guy. So that little bit the all people key and of course, it's this normalized thing. But you can see that the, the subscription, de normalized it into this tree. And notice that for example, Sam are rather lets you know who else, Amy's in here multiple times. And if I modify Amy's mood, you see Amy's mood changing everywhere. Oh, we had Sam, the first time that we modified the sad you see these these, Sam is still sad. Or maybe we just missed the missed up the ID. I'm not sure which but but everybody starts out happy in the database. So clearly that one got modified. So you can see the normalized database makes it really easy. If we look at at person here, because we're modifying a normalized database. Of course, clicking any one of these is just modifying a flag, but because of the D normalization happening at the UI, the UI updates properly. So these are just a couple of different variants of you know how you could do it, you could do it with oops, you could deal with raw eql and get the same result. You could use the get person. query, why am I not getting the Oh right. So here, notice, I've only I've only subscribed to person ID in person email. So that's all I'm getting. Sad is showing, or this is showing sad just because I'm getting a nil value there. So my renderer should be a little little more careful about that.

If I change the eql there, then that should, that should fix the ones that are actually happy. So you can see this is a little bit tedious to have to go through and spell the qL every time. Whereas, you know, using focal components to just define the queries gives you a much cleaner way to say I want that whole subtree of these things. And then of course, defining specific queries where you've hand coded them in reframe gives you a similar kind of result, I want person three. Okay, let's go back to the ones that were completely.

Right, so then the mutations. So if you've not seen full curl before, I mean, loads are pretty straightforward. Understand, I'm starting at this key, and then loading However, many people match up this person query. So in fact, if I, if I go over here to full grow, I can look at the transactions that are local, and the remote. And I can see that when I load a single person, the transaction that runs is a load transaction, which ends up giving a network request. And then I can even see the network result that I got as a tree. And of course, I can even send that over to the query tab, the query tab does not support the recursion. So if I remove that, then I can run that query and see, see that running myself, you know, change to a different person. So this is really, really helpful to be able to see exactly what your application is doing in those those ways to load people. The I've got something going wrong with my mutation, but easy enough to debug the DB Explorer, and I just lost my database. Occasionally, the database gets out of sync, and you have to reload the app for the tool to regain at sanity. This is the DB Explorer is a little easier to navigate and normalized, the normalized database once it gets bigger, this this can get you know, these tables can get rather large. So here you can see I want to go to the person table, okay, there's I want to see person to I want to navigate to person three, oh, they have an address, like you can just kind of walk and then there's a back button. Like gives you some nice, different navigation. So the mutation. So this is the primary mechanism whereby fulcrum makes changes to the system. And you write, well, what sort of looks like a function, but it's a function with multi multiple sections. Let me jump to it. So that's the other nice thing about folkers is because we use something that looks like a function, we can make the mutations navigable, so you can just jump to them. So even though this doesn't actually call a function, it actually submits something to folco to run separately, it's still a navigable thing. Same thing with the queries like just jumped to them to see the queries that sort of thing keeps you from when you get your source base gets large, this kind of stuff is really important. So ultramoon mutations and full CRO can have an optimistic side. So this is what to do to the real database. And here, we're doing a swap on the state doing an associate on the person table at the ID, we're past and change in person happy to whatever, they passed us person happy. And then we're also indicating this should be a full stack operation. If that wasn't there, then this wouldn't attempt to go over the network. So I'll go back and we see how we're using this alter mood person ID person happy not happy. Could be a refresh rendering kind of issue. Were happy as backwards. Not sure. When we can see here in the database for our people pay me. Yeah, that's modifying the right. the right person. As far as this database goes, we can look at the network and see all right, we're modifying person one happy then on the network. We're doing ultramoon. person one, happy. So Amy, at the moment, should currently be happy. Now she shouldn't be sad. Now if we reload the people, Amy is still sad. Okay. I guess I guess I'm just seeing things weirdly, there could be some refresh issue here with with how things are working, but I can't think of why it would be. So that's kind of the lowdown. You can see, it seems to work pretty easily. There wasn't really that much to do to hook it up. Those of you with more reframing experience, perhaps you can indicate whether or not what I'm doing here is saying, but I thought I'd share the idea and perhaps let people access a larger pre written set of eql tools for their applications, even if they're not using full core for the actual rendering.

