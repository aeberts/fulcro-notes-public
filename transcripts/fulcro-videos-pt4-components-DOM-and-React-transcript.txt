In this video, we're going to talk about some more details about def SC components and rendering in general. So we'll start off with the basics first, a lot of people like a more compact notation for their Dom because it gets rather noisy. So that's, you know, that's easy enough to, to get by just doing a little, a little referring in your, in your header there. And then, you know, just get rid of the prefixing. And now this is a lot more compact. And then you know, when you use some other element, just pull that out. So let's go through here and, and just dress that up and see if that doesn't really change our rendering any of the other thing we're going to do make sure I got my compile running here. I do. The other thing I'm going to do is, I'm going to go ahead and go to our index HTML. And I'm going to add a style sheet. And I'm going to add semantic UI, CSS to our page, just so we can see some CSS in action. And if you've not used semantic UI before, there's a, you know, a nice website tells you about all the you know, elements, dropdowns, labels, dimmers, loaders, etc. And there's also some react wrappers that I've written for fulco that you can use with them. And I'm just pulling that in. So we can show how how you use an existing CSS library, or your own CSS library with velcro DOM elements. So once you've referred those, there is an optional, you know, on any given map here, so let's go to the name here. And we could give it an options map just like you can and react to this would be the equivalent to the attributes on the on the tag. So I could, for example, say, style, color red, right, something like you do in, in just a normal kind of HTML ish sort of way. And of course, that applies right to the dog. Of course, you might also want to see, let's see, we were trying to make this and look more more like an actual forum, we'd probably put a label, tag around that one up here and add, label. And then maybe this would be a forum. So this is the next little notation that I wanted to show you is, and I can actually just pop over here and inspect in the browser and show you what what outputs. So this is taken from the pattern that hiccup uses on closure based DOM elements. So I might say, in hiccup, div.ui dot form, right, so in Velcro, you'd call this div function slash macro, this is actually both the system figures out which to use based on the context of choosing for example, if you use it as a function that acts as a function of use it more like this, it'll act as a macro. So for example, if I were to map over div you know, with some some parameters, then, you know, I get multiple Dibs out of that this is being treated as a function. Now, the difference between a macro and functions macros are evaluated at compile time. And because of this folker was able to get you essentially the exact JavaScript you to hand to generate or JSX would would generate for you in terms of performance, under certain circumstances. So this keyword is just a shorthand for saying class name, UI form. And in here, now, we should be able to say that this is a field and some semantic UI should format that age section a little bit a little bit differently. And of course, if this was an input, we'd see it look even more. So we have this.ui, dot form, dot however many classes you want to put on there, we have an optional options map, and we have the children. You'll get the best performance out of this, if you always include the options map. So you see I'm kind of dropping it for convenience in a lot of these places, just to make things a little, a little tighter. And when

when you drop the options map, the macro essentially can't necessarily tell if the next thing is a call to write without source analysis, which we're not going to program into the macro. It can't tell whether or not this function you're calling is supposed to be returning the props For the div, or is supposed to be returning a child for rendering. And remember, this is at compile time. So we're in a closure environment, a JVM, we're not even on the browser. So we can't really ask is that thing that now in terms of what that means in real performance, without the options map, it's about as third, third as fast as with the option map, but we're still talking, you know, typically, microseconds of performance difference. So, you know, for your convenience and reading ease, you can get really good performance, without bothering to worry about the options map. But if, for example, you had some extremely large UI, and you were noticing some lag in a particular environment, that's a way you could very easily reduce the React overhead, to a third of what what it would be otherwise. Okay, so we've got our CSS shorthand in place, we can mark, start making, you know, our things look a lot prettier on the screen now. Oops, you definitely have to have the dots in there, tells you tells you Those aren't classes. And then of course, we could do things like put a UI segment around that which give it a really nice little border, and dial it up. Okay, so no fun CSS, and the speed of the macro functions. So the next thing we want to talk about, once you've got the idea that you can, you can format these things and label them up with with CSS classes very easily. Let's talk a little bit more about these option maps. So the component options is, for the most part, an open, extensible map, it's literally not, you know, not purely a syntactic convenience of def SC, query identity, initial state have a special interpretation where the macro does try to give you some help. And one of the earlier videos, we talked about how initial state really needs to be a function, but the shorthand gets rid of a lot of the boilerplate for you and get you some more error checking, like, for example, it telling you, you're trying to initialize something called person, but that's not in your query, right. So it's kind of obvious to it that you stuck some stuff in here that you didn't mean to stick some stuff, you can always put these in lambdas. Same thing with query query actually has to be a function due to dynamic query support. You know, this get query could be called at runtime and actually return a different query at live runtime than was set up initially statically on the component. But for the most part, you don't need to do anything manually inside of this lambda. So you know, the macro can can deal with the fact that that you're not giving that anything else you ever see in this component options map is literal. So I could I could put, you know, data 42 in here, and focus perfectly fine for me to do that. And I go down here to my comment block, and I can see comp component options on person. And I can see that that's actually there. And you can also see the query is a function, identify function, initial state turned into a function or render got added render is this body, right? So so what you end up with is the component really is mostly represented by this component options map that gets things thrown in it either by the user directly as data or via these three special ones. And, of course, you can add react lifecycle here. So the React lifecycle methods, they're a little special in that in that they have a meaning to react. But they're not special in terms of def se doing anything, particularly are syntactically at least, interesting. So one of the things that's always defined for you in, in full CRO, and not in react raw react is a should component update function. And this is a function that takes this lets you know should component update props and state. And this function returns true or false to say whether or not the props and state have changed in a way that would change how the component renders the pre supplied version of this and folco should be perfect for your needs. It basically checks to see if the props state or children have changed

for the component, and if they have, it says yes, and if they haven't, it says no. And so you kind of automatically get this nice pure component short circuiting of the virtual Dom diffing. If the data for some subtree of a component that's updating hasn't actually changed. So if you know if you're coming from person and the person's name changed, but none of the cars did, then you'd like this UI car thing to short circuit for every single car. And that's in fact, what will happen by default in folco. Another component lifecycle method, very commonly used, component did mount and this is a function that received this. And this function is not in the context of the argument list up here, it wasn't full grow to it is no longer in full growth three, this is just a pure lambda. That means if you need to see the props,

you have to you have to pull them off of a component instance, here we can just

so for reload this, look at the console, we see the person mounted, and there's the prompts. I guess we could have made that a little more obvious by I can hit the right keys on my keyboard here.

Okay, so that's how you spy, you know, React lifecycle methods. This is documented in the doc string of def sec, which is a, you know, a rather long docstring, talking about all the different things that you can throw in here that, that folker understands, oh, I misspoke there. There, there are a couple more extras in here that that at least have? Well, I mean, libraries can extend this too. So there's all sorts of things you might at some point want to place in this component options map. But I did want you to understand that it is an open map. If you're writing a library that that adds things to this map, then of course, you probably want to namespace your keywords. So you don't accidentally collide with other people's ideas about what to throw into this options map. Another react one that that people often ask about because this is useful for things that need to perform as fast as possible. This is a little little question when my mind in most cases. But this is essentially the constructor placeholder for the React instance. So instead of being able to run a constructor on here, you're right and it local state. And this does two things, it gives you this props as arguments. And then anything you return here will go into the React component local state, if you don't know what react component local state is go and read the React docs, this is not a full curl feature. Other than it local state is a way of naming a function that you run at component construction time and initialize the component local state. And the component local state is essentially something you can access via get state. So phi. And this is not what's in the app database. So this is not part of props. So if I reload this, it'll construct and now you see the state is starting out to this closure script map a two. So if you need to do something, you know, at construction time, the thing I very commonly use and that local state for his callback functions, because the should component update of have children or have elements etc. Very often you put some sort of function, some sort of lambda on an attribute of a DOM element and on click or a form submissions sort of thing. And every time you generate a lambda, so if I if I said, you know, my on click is some function of the event, dot, dot, dot, every time this renders, this is a brand new function. So it's going to change a number every time which means this value changes which means if it was a value being passed to a component, the components props are changing every time which circumvents should component updates optimizations. So what you can do is you can write a function that takes an event up here, does its thing, put it in component local state, that's a very good use for this. This particular feature of react and then you can ask for

that out of the component local state. final

days, put it on the label name. Oh, I think I have to reload because it local state only happens. Now you can see I can click on the name and I get my click events. and the value of on click here won't be changing at every render, because it local state only gets called when the component is first created. The on screen instance is first created. So that's the most common use for it local state that I recommend. focal three is really fast at pulling data from the database, we're going to talk about that in a later video. And so typically, the overhead of of keeping the stuff in the centralized state atom and going through the query system isn't big enough to justify trying to use component local state as an optimization. Because it's nice to be able to track your state, and history etc, be able to view it and inspect, you know, get all sorts of all sorts of interesting useful features, by actually tracking most of your real state in the real app database. Look for things like this, we have an event handler, whatever component local state can be a great place to put it, just to keep it out of your way. Okay, so that's the component options map. I did want to mention one more thing, and that's identity. So it's not uncommon for us to have components that don't have a server identity, but for which we do want an identity in our local app database. So let's say we had a person list. This is going to be maybe person list people have, let's say, in this particular case, oops, I found

this particular case, we don't want multiple lists, there's just going to be one listener application. And it's not going to have an ID, obviously, using this key as the table name, and the ID isn't the right thing to do. So there's a couple of different ways you can specify an ident in the component options map. And so this is pretty, pretty important point right here. One is you can specify the table, and then the key of how to get the ID, right. So for example, up here and in person, we could have written this as the table name is people, person ID. And here, let me comment these two things out from the moment, oh, I have a total typo. So that's not gonna work. We can just dump that. If I reload this and look at my app database, I'll now see there's a people table with my person in it. Right. Now, the reason we use the ID key, as the table name has to do with Python, and some conveniences we get out of that when we use it that way. But traditionally, you know, years years back in terms of full CRO, we were we were less specific on what you should or shouldn't name your tables. And today, we have a definitive recommendation based on experience and other libraries. And that's that, it should just be the same thing. And that's why in Volker three, we have the shorthand that let you just say, they're the same thing, the table name. And the way to get the ID is one thing, when we get to a singleton component, where there's only going to be one representation in the database, the ID part of the identity is constant. And so we don't actually want it computed at all. And so that's where we typically just make these for these. Nothing. So the ident will get the arguments this and props. And you can compute it here. So right person, Id get the person ID from props will be the boilerplate a way of doing the person ident up above. And in this case, we're just going to make a constant one, we're going to say, there's going to be some components that have IDs and we're just going to make this one person list. If you're not used to the colon colon notation in closure yet, you should get used to it because it's really important. This basically just prefixes this keyword this is this is exactly identical to me typing app client slash person list since I'm in the app client namespace. So that's a way of giving a keyword a localized namespace so that you don't accidentally collide with other things. So I can say Alright, you know what, I'm just gonna put my arbitrary components that are in my system that that are Singleton's into one database table component. Id call that person list. And then you know, I'm going to add some initial state here where there's a person list. Keep doing that. People on, I'm going to start that off with an empty set of people. Now, if I turn this into a join, then it knows these people are coming from that person table. And remember the shorthand we talked about in an earlier video where this is actually going to get the initial state from a person because it's easier to join to person. So this will actually fill a person into this into this list here, we can walk on up here and complete this. So let's change this kita to people. And then let's get the query of person list. And then let's not give any arguments, Oh, whoops, our person does need an ID and Name. So let's, we could actually put more than one person in here. Forgot we we gave that right, we gave these parameters to the person, initial state. So we can actually make more than one person there. And so here, we can then say map over UI person. People can maybe do our H three people, and then we've got something mismatched here, line 57. Yes, route people, we should probably give it that it does not need any parameters. And then this is no longer person. This is people. And this is now UI person list. And then if we reload that, hopefully, we see two people now, each with their own segment. Of course, with the same exact sub data, because we we didn't do anything creative down there.

Okay, so this is how you assign Singleton ident to a component. And so that's a very, very important thing to know how to do. And you can see down here now I've got a component ID table. And if I open that up, I see there's a AP person list that has people and then edges going from there. Now remember, in the earlier videos, we talked about when you merge things adding edges in and and you see how now I've just done the same kind of refactoring that I was talking about. Sample used to be the thing that was pointing at person, I didn't have to touch anything about person or car, to move them to a different place in the UI, I just put something in the middle, and the layer above it now to point to the new thing I was sticking in and the new thing had to point to the things below it. So I just inserted this thing right in the middle, set up my initial state to be correct. And it just kind of self healed on on reload of the application to the new graph that I needed for that UI. So kind of an important demonstration of multiple things we talked about earlier to kind of remind you what that looks like. Okay, so those are ident forms, talked about the coded options being extensible. That everything else is literal. And that it's probably a good idea. If you add things to this options map, you know, my idea of stuff should be namespaced. And that way, if you're if at least, if you're making a library, and you're publishing it, people can use the library without colliding with potentially other libraries that had similar ideas and came up with similar names. Okay, so the last topic of this video is going to be using the React ecosystem itself. So let's say we want to use something like this react a number format control from the normal react ecosystem. This is a JavaScript control. It's written in JavaScript, it's published in NPM. And it does this kind of nice input format II thing for us where it'll, you know, throw commas in a monetary unit. And, you know, you can format things like credit cards, whatever, whatever you need to do. So convenient little control. And so we can go to our package JSON. So this is how you would do it in the regular JS ecosystem. And IntelliJ has some nice support here, where if we, if we start sort of typing out what we want, it adds in the comma here you know, what adds a comment in here. And then it you know, kind of found the version number for me I just like, hit, you know, basically command to complete here. And it said fortios, latest fine. And I'll pop down here I'm doing npm install, that'll put into my node modules, and now shadows ready to work with it. So I don't have to restart shadow clgs or anything. It's, it's, it's going to be all ready to go. So then to interact with something like this, I just need to go and read it's its page. So it says our I've got two. If I go to pull it in, I pull it down with one of these mechanisms. Yes, five, yes, six. And if you look at the shadow clgs documentation, you can translate this to basically react number formats or like you would in the require there. And that should give me my number format. Class. Now that's a that's a class and is yellow here intelligent, slash cursive doesn't yet understand this shadow clgs convention, nor can I think it can't really just go and look in the JavaScript to figure it out. So it just tells you about sorry. So that's, that's an unfortunate thing that I don't personally know a fix. If you do, Leave it, leave in the comments, I'd love to know how to get around that. So now the issue is we need to call essentially, React create element on this, because that's what JSX does. So for writing, we go when we look at a JSX example, like this JSX converts this, if you go and look at the React documentation, and I'm going to write sort of JavaScript here, it would be like react dot create element. And then the class, you know, number format, etc. So that's what we need to do here. And so I've created some react interrupt helper functions that will do that for you. So you don't have to, Oops, wrong one.

Don't have to manually do this every time this interrupt namespace currently has at the time of this recording, helper function for making these factories. So that you can use them like your your DOM elements in regular photo. And it also includes a higher order component helper, the Developer's Guide talks about using both of these in detail. So I'm going to say UI number format is an interrupt, react, React factory on number format. And this react factor, if you go and look at the code, it basically just calls create element for you, passes the class, it converts closure script, props to JavaScript, because remember, this is a JavaScript thing. So it's expecting to see JavaScript stuff, and then passes into new children, it's really quite simple to do, it's just kind of handy to have the thing laying around. So now if I go and look at one of these examples, I should be able to just pop in here and say, Oh, well, let's make a field for you know, a monetary amount, which is going to be a UI number format, with some parameters. And let's see, now they say 1000s, separator.

True. Add prefix, $1 sign. And you do have to do a little bit of JavaScript conversion here. So in JSX, curly braces have been throw some code in there. So we don't need to do that because we're in code. And then single quotes, in JavaScript, create strings as do double quotes. Whereas in closure script, it's always going to be quotes. So there's little bit of, of stuff you've got to do there. But now we see an amount. And we can start typing in our our number get the prefix, but it did not get the 1000 separator because they're probably misspelled. Yeah, I sure did. 1000 separator. So you get down I mean, this react control. It is a

you know, it is a component that works a lot like normal Dom inputs. This is a side note that I should put everywhere. Please remember that Dom inputs in HTML, always, always, always take strings as inputs. And always give you strings back is output even things like time inputs, data inputs, they're always dealing in strings. And if you need those to be in a numeric type of your own, then you typically want to wrap them in some sort of logic to do that. I may cover that in a later video. But for the time being, this is this is what I wanted to cover. So that's the basic, you know, using react library, you saw how easy that was to pull that in for via shadow clgs really no headache at all.

