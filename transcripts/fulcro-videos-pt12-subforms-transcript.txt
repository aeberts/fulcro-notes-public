In this video, I'm going to be talking mainly about some forms state, I'm going to be extending from the last discussion, our kind of forum setup in terms of data modeling, you see I've got a little UI on the screen. And I'm going to be talking about the fact that I've got this little sub form here of selecting a category, that's really something else entirely normalized into the database. That's the sort of thing that you often need to handle. And you need to understand what full CRO will do for you here and what it requires you to do. And I hope you don't take away from this particular one, there's a lot of complexity in this in this area. But the complexities inherent to the problem, it's not inherent to the solution. There's there's a lot of different options here. And I'm going to kind of walk through the pieces and categories are pretty simple. And because categories, typically, you've got some other place where you edit those, you create them, and then you can associate them with things. But a parent child relationship can take on two forms, right, you can have a parent child relationship where this, this thing that's a child is either owned by or just referenced by the parent thing. So in this case, items are in categories, they probably just referenced the category. But if this was a person, and the second thing was a phone number, maybe a person has multiple phone numbers. And so that has to be a to many relation, you put it in a separate entity or a table or whatever in your database. In that case, if the person gets deleted, you probably delete their phone number records from the database as well. So in that, in that particular case you're interested in, for example, in a form here, if this were phone numbers, I would probably let you edit the text of the phone numbers right here and not choose a different phone number, it would be something you'd actually want to change the numbers of as opposed to just pick, you know, some alternative version. So that that's one of the central elements of complexity that that gets us into trouble when dealing with forms. And there's a lot of little pieces that come along with with that, how do I get the data for this, this relationship or whatever, into my application? How do I manage it? How do I tell the server that I've updated it, etc. So I want to talk through all these different pieces, I'm mostly going to avoid the UI. Again, we're not quite to the point of understanding the data model well enough to work with you, I highly recommend I mean, people very often they'll start with trying to make the UI pretty, that's the first thing they'll go with, I want to I want this year and that there and wrong thing to do. That's, that's great. If you're trying to impress your CEO, or your manager, it's the last thing to do if you're trying to impress someone technical, think about what you're actually doing in terms of data modeling. And the UI will flow from that. You do have to know how the UI stuff works and what what your limitations are and constraints. So so there's a lot to learn and a lot to know. But in in focus, since the UI is pure rendering, right? More than probably any other library out there. You really can declare your UI to be a pure function of the data model. And have pretty much a single function run, convert this graph database into a graph of UI data and render it. And the state of that at any given second is exactly what you'll see. So there are caveats to that. But that's really what we're shooting for. And so I really want you to understand the data model, and how simple this stuff is, this stuff's really, really simple. And people make it super complicated by thinking up here first, where they've got all this complexity of CSS, and layout and nesting and all that crap, when in fact, reasoning about it in a simplified normalized database, turns out to usually be much, much, much easier. And then once you understand the data model, it's it's then so much easier to deal with your UI. So, so try to try to take this sort of approach and realize that that all of the closure functions will work in closure and closure script, you can actually play with most of this stuff at a closure repple. You don't have to start up shadow clgs you would have to make them clj. c files to do that. But

this is the sort of like pure data modeling stuff we can do to figure things out. So off my soapbox, here's what I got set up. Just to make this quick and easy. I did add to the depths a semantic UI wrapper library that I support for full CRO, this wraps the semantic UI react controls and gives you a docstrings form. It's really straightforward, simple stuff. You know, if you jump to one of these in the library, you'll see it's basically a def with a doc string. That's been pulled straight from the online documentation. And then just a, this is an Iraq factory that converts the props. And then it's got the proper required to pull in exactly just the component that you're interested in from semantic UI is NPM library. That's it, that's all these wrappers are links that I made them so that you could you could do something, you know, like, hit your docstring thing and actually read, okay, here's all the props without having to jump to Chrome and look it up and all that mess. So anyway. So we had you I dropped down just takes options, which is a vector of maps that have a text and a value. Right. So that's, that's how this works. And you can say they're searchable, so that, you know, somebody can start typing a name in here, and it'll match, match things. etc, it's got lots of options, it's really nice control, semantic UI typically has a good number of those. And then I've just set it up to the on change log something, and that the value is whatever the current category is. And I have gone ahead and added some model that I'm going to show you in a minute to actually load these lessons in category two, this one's in category one. But that's not really the name of these categories. And you can see if I try to select something here, it doesn't change, because I've got this as a controlled input. And I'm not actually applying the change anywhere. But you do see, it logs out the thing it got and this is a big JavaScript object. So remember, this is a semantic, this is a JavaScript control I'm using. And so when I get this, I'm going to get, you know, a bunch of gobbledygook in the event that arrives. So I have to go look at the documentation to figure out exactly what to pull out of there. But it looks like we've got target. Well, doesn't look like Target has anything. So we'll look at that in a minute. I'm less concerned about how the control works for this video than how the data works. So for this particular scenario, where the the row owns the child, there, there are number of different ways of modeling this. So let's talk about the forms themselves just in terms of data modeling. So let's start ignoring the UI. And look what we've got here. So I've created a couple of different sample category. def STS, most of them not UI based. This one would be an example of how you might build a category option things you could use this kind of text value query to pull category options from the database, and then normalize them a new category option table, right. So if I go to my category namespace here, I've extended our model here. So we've got categories here, the two categories, I've got a resolver, using this stuff in prior videos where I can have a category ID, and it'll give me back the category, I've got one, that'll give me the top level all of them. And then I added a resolver. And this is a great example of how you can use path on leverage path on to pull something down into the UI the way you'd like to see it. So if I go over here, and go to the query, tab, and filter, inspect, and load the indexes, I can query for a join of all categories. And then I can just put splat in here to give me everything. So category one, two, tools and food. Okay, that's fine. What about if I look forward category, category options? Well, that's the same data but with different key value pairs. This is just a way for me to be able to compose that into a query and just have it work. And remember these top level things, the things that they're not really top level, the things that don't have any sort of requirement data input requirement, when I look at these, right, this one requires a category ID, this one doesn't require any input. These can be used anywhere. So I could say, Alright, I want category options. And at each category option, I want category all categories splat, and this will make a nested mess. But this means I can ask for the categories at the component level. So if I go back to the item, right, and look at this, this item query here, I can I can go to the remember these, these items are loaded at the beginning of the application. So if I go down here, and look at my, my initial load, right, load all items, so I'm going to load all items with this query.

And I'm asking for item category. And notice item category, the way I've coded that one is it only asked for the category ID and then the forum stuff. Because in this case, all I care about for an item is the ID of the thing that it's currently pointing to that's what the actually editable on item. That's the piece of data that item owns it owns the pointer to the category it does not own the category. So I wouldn't want to indicate to for example, my data diffing that Oh yeah, well, they might change To the name and I want to send that name change now, that would change the category name for everyone. So, so this is what it would look like to just get the category ID that's currently selected for an item. And you can see the drop downs are saying, you know, two is selected here, and one is selected here. So, so that's working. But that item category is being resolved from the item resolver. Right here. And of course, I, you know, I'm faking the database here in a real database, you might have the literal one or two here, and you'd have to, you know, do a little manipulation in the resolver to get the right output. But I'm cheating a little bit and just specifying what the correct output should be for these. So that's, that's a thing that I want for the forum support. But here are some options I can I can do for filling out the drop down. So So this first part is not as much about the form support itself as about some of the complexity that comes with this particular concern. I've got a sub form, what am I doing? Am I pointing to something? Am I making something that I own that I'm editing, etc. So one thing I could do is I could say, Oh, well give me the category options. And I can tell it not to normalize those into the database. So remember, this category, category options query I just showed you in the query tab, I can nest these things however I want. And this particular one,

right, we'll just return me exactly what the semantic UI dropped down once, right? So so I could put that query in there, I can reload this, go to the database. And then you can see at the network layer, I ran that query, and for each item that came back, it had category options, right? So this is a little heavy on the network. But I can do this, this, this, this lets me, you know, pull the data they need into the context of the UI component. And then I can very easily say, Okay, well, now I've got category keys, I've got my options. And so instead of making fake options down here in the control, I can just say, Alright, there's my options. Oops, did I fix the query? category, category options category? Oh, category options.

And videos, right. So now I've got the the appropriate things in here. But if I go and look at my database, what I've done also, at the item level, is I've left these denormalized. So I've just kind of spread categories all over my database. And this gets me back into the mess that I was in to begin with, that that made me want full grown to begin with was, I don't want this data duplicated every world what if somebody goes to the category editor and edits food and says combustibles or something? Now everything's wrong, right? It's just spread all over the database. So this is where I could take the next step I could see Well, alright, you know, we'll make a category option component. So we can at least normalize the options. Okay, well, let's, that's easy enough. So let's, let's do the same sort of join. But But here, let's use component to force normalization. Okay, let's reload. Alright, comes in, things look fine. If I go look at an item already had them up. Sure enough, it's the category options category, option ID two category, option ID one, if I go look at the category option, Id table. Okay, so now these are normalized. So well, this still isn't great, right? Because these category options are duplications of the actual categories. Right? So I have these already normalized into state. So what's another option? Well, another option as well don't query for them at all. Don't don't ask for them here. need to take this guy out. And, of course, this is wrong. Instead, what I could do is say, all right, well, category options.

I can pull the current state database this way. Now the downside of doing this is if Pull this here. There's no data dependency listing for full crud to understand. And so your UI won't refresh. So that's what this this option comment here is. So you can access these, this map directly. And I can see all right, well, category options is let's thread the state map through a get in. Now just a get of category ID. Right? So I've got the category ID, table, that's going to be all these, these maps in the category ID table. And then I can say, Okay, well, that's, let's get the vowels, vowels, vowels. And then, let's take those and put them into

category ID would be the value we want category. name would be the text that we want. So let's rename the keys of those things. And then we could say, well, we got the vowels. Let's sort by category name. Before we we do that. Okay, so crash, I thought that was going out on a limb there a little bit to type that much code. category name is not ic keable. Oh, right thread. Now, that's not going to work for my good.

Okay, so reload that. Now, as I, you notice one of the issues here, right, is they don't show up until I saw this was talked about, there's no data dependency. So folcroft doesn't know that the fact that a category came into being should update this particular control, so the loading order can screw me up. Now, I can sort of fix that by going down here. It turns out that I had a load here for all categories, already going, I put the all categories load first. and reload. And then it'll at least come in looking right. So you can see this is a little finicky. So the The advantage of this particular approach by dynamically calculating it in the UI the advantages, well, it's completely denormalized in my real database, and I don't have any problems with if something changes, this UI isn't right. But this isn't great. Because I've got two things. I'm doing one, I'm pre I'm recalculating this every time I render a row, which is expensive, could be expensive. So you see, you've got 10,000 categories, this, this would become impossibly slow, horrible idea. So it's got the advantage of of my data is not duplicated all over the place. So that I've got this, this, you know, kind of nice property of my database. But things aren't working out too well, for me in the performance category, maybe. Okay, so what's the next possible step? So I'm trying to show these options, some of these are actually perfectly appropriate. for particular situations like this one might be an okay thing. For some situations, I just want you to see the pros and cons. I'm not trying to say, this one's perfect for all situations, or this one's imperfect. For all situations, I'm trying to show you the, the potential for flexibility here that you will need in various different situations. Okay, so what if, instead of calculating this for every row, I calculated this at some well known points, now, that's relatively easy to reason about, right? If I load categories, I know that I probably need to re re up the category options. If I come to a particular screen, I might, I might know, you know, I need to re up this this options list. So I'd like some caching strategy. So that's, that's the next potential thing we could do during the load. And I've already got this written out here. I'm gonna put this load back after the the item list load. And so this is just using that top level category, all categories. So this is getting the categories in the state and normalizing them, you can ask load to do a post mutation. And you do this by symbol. So that's why there's a back tick here. So create category option, something when you load all categories, go and run this mutation that does that thing that you just saw me do live in the UI, make a top level key and app state called category options. That's exactly the that list of categories and I'm By being a little, right, I've got the vowels, I didn't do the sort by here.

So if you do that, then in my database, I end up with category options. Being a thing at the top level, you see this is actually category options is actually a vector of maps, there's, there's no additional normalization going on, there's just a root level piece of data. Now folk rock comes with a query mechanism for for grabbing this root level piece of data on it's, I think I've already shown it to you before in other videos, or maybe even here, but it's this notation, you can say, a root level of key, and then a quoted underscore to indicate I don't, I'm not looking for something in a table. So this looks like an identity, right? So for example, you could say I want to query for category, Id two, you can do that in the UI just as well as you can in path. That's a perfectly legal thing. But it's very rare to see these any UI component because you don't know which one you want to pick it. So that's, that's just a very rare thing to do. Here. However, it's perfectly valid to say, I want the entire table of categories here. Right? That that would prevent me from having to do kind of normalization joins, I can just pull the table in. And then I now I have a data dependency. So this is actually just a different way of doing this. I could say pull the category ID table in here. And then instead of going from the component state map, I've actually created a full core data dependency here. This is really the better way of doing this. I could say get from props. I've got to be careful category ID that I'm not conflicting with with real other things that I want here.

And you see that the even though my loads in the wrong order, now it gets it right, because folk row sees, oh, you depend on the values in this table. And if those values change, it'll refresh the things that that have queried for them. So that fix our data dependency problem, and is probably the way I should have shown, you know, dynamically calculating these from the table, just query for the entire table, transform it, you got it. But if you decide you want to cache it, well, then the option is to use this post mutation that I've just shown you. Right, run the post mutation, have that create a denormalized cache of the thing that you want. And then that mutations reusable, right? Anytime you feel like, Oh, you know what I want to I want to update the drop down options, you can transact and call that mutation and have it re up the definition of those options. So caching always has that problem, right. As soon as you start caching things for efficiency, you have to figure out when you should update it, well, this gives you a very clear way of updating it that you can then just pepper around on the places where you know, it needs updating. So, so when you need that efficiency, you can do it this way. So lots of different options. And let me go ahead and show you this one, this one working. So if I say category options, then down here, I can just say get from props, category, options, and it'll be there. And again, you see the UI he'll. So this is probably the most common way I do these is I'll put them in a in a cached location off of a well known namespaced route key. So that I can just join to them from route whenever I need them, and drop them into the UI and then manage that cache of category options as needed. So for example, if I had UI routing going on, on the entry to this particular route, I would update my category options, I would just run that mutation, I might even run the load with the post mutation, right? I might take dude, give me the Give me the update from the server. And that's typically what you want anyway. So those are all the possible options. I'm going to stick with this one from the moment because like I said, it's it's kind of my my preferred way of doing it. And so now I've got my my category options loaded. Okay, so that's enough about Well, almost enough. Let me say this, you've got the drop down. That's just a plain component. The various ways of normalizing them and again, I'm I'm not currently using these this this would be a way of me. normalizing the And actually, I think I used it a little bit ago. But I'm going to remove these from the code. So the when I checked them into the tag, they're there. Well, I might leave them. I'm not sure whether these will be confusing or not, but I'll leave them. Okay, let's get back to forum stuff, that was a big digression to just talk about how to get options in. Okay, so let's go down here and take a look. Now, if you look at my item, I've changed it. So that item category is now one of my form fields. And I've done a join between item category. And the item category class. And I showed you this a little bit ago. All I'm querying for here is the form config, because I want this to act like an editable thing. And this remember, is a not isn't his non owned reference, what I really want to edit is the fact that items pointing to a particular category. So what I've listed here is that the category ID is editable. And this is an artifact of how the the diffing works, when I go to look in state. What I want to get back in my diff is well, which ID is that pointing to So I do want the user to be able to edit, which ID it's pointing to. But in the UI, remember, this is denormalized. state. So when I go and look at the the nested props of this form, this says I'm pointing at category, whichever This was one or two. And this one says I'm pointing at the other one. So what this drop down is editing is the ID, it really is changing the ID on the item category. So even though this is a nested component, so that I can get the appropriate nesting in the in the tree, realize that that I'm not actually changing the ID of category, I'm changing the ID that an item is holding, that happens to point at a category. So this is this is kind of the, again, the complexity.

So if I've added these two things, I've added form config here. And form config here. I've listed the form fields, item category here and category ID here. Notice that item category, in the form fields corresponds to a join in the query, this is a very important point. And this is how sub forms work. So let's go and configure this and see what we end up with. So if I get the query for, oops, in the wrong repple. If I get the query for that item, not connected. Let's just stop and restart it, clear it.

All right, good. Let namespace load the file, run the query. Okay, I've got the regular item stuff, I've got the item category, and its category ID. And then the rest of this stuff is the query for the form configs, so that it can get denormalized into the props, as we work as you saw in the last video, so that we can have validation, and pristine checking and etc, etc. If I asked for the form fields, on item list item, there we go. Sorry, I hit up weird key. So but then I see just a flat set. But if I go back and look at the Oh, no, I don't have state. Yeah. But if I go back and look at the query, realize that item category is known as a joint. Right? So item category here is in the form field, it's known as a joint this is this is very important point. I know I keep stressing it. So let's say I merge a component with let's take an empty state. This is we were doing this before. So S is going to stand for what's at each step. So it starts out is our state that's the empty map, we're going to merge something and get back a new state, which then we're going to merge something else get a new state, etc. So everything else is commented out. So I'm just going to start by what does it look like? If I just merge an item category? By just merge an item category just adds a table entry. That's exactly what you would expect. What happens if I merge another item category? All right, well, now I've got two things in the table. All right, that's fine. What if I merge a component with, you know, this state category ID, you know, one here, just as I would have gotten it from the server, and this case, notice I don't have the category name. But if I run that and merge it, you see I get the item table, I get the proper ident pointing to category one. And category one still has its name from my prior insert here. So that doesn't overwrite the entire map. It's a smart merge. Okay, so now the question is, if I add form config, what does that actually do? And this is where it gets fun. So the forum state follows the query across what things are declared as form fields. So item category is is declared as a form field, it knows, it should walk that and add config to the category as well. So those both the item and category one, not category two, just category one, because that was the one that was reachable from item 22. Right, it was pointing to category one. So it walked to category one, and it said, okay, you need forum config, as well. And notice it normalized both item 20, tos config, and category ones config in here. Now also notice that the fields listed for the category are just the ID names not in here, pristine state has the ID names not in here. Okay. The next tool, and you almost very rarely use this, but I want you to see it. Internally, form state has a function called update forms, it's very much like update, but it's it's sort of a mix between update and closure walk, right? It walks the forms via the declared form fields, and joins on those form fields to two sub forms. And so you see right now, you know, I've got category item two configs. And so if I say update forms, and I handed the entire state map, look at the doc string here, a transform function and an entity ident to start on. So I'm going to start on IDT, which is my item, it will walk to each entity in the database, pass you that entity as the first argument of the function and pass you that entities form config as the second argument. And then you have to return a pair. So that's why I'm returning a vector that has the new entity you want in state and the new config you want state. And so I'm just like throwing some touched flags on here. So you see that my, my result here would be right touched true on that guy. And then I go down to item 22. And touched drew on that guy. And then I look in the forum config. And sure enough, there's a touched and touched on each of those. So this function is actually the thing that is that is used to accomplish a lot of the tasks in forum state, and you can write your own, as well. So if you want to write something that walks the forums and does some complicated, whatever, this is a useful way to do it. And you can also use it to change the configs. Remember, the config has the pristine state, it has the list of things that are complete, etc.

Okay, so we add form config, it uses update forms internally to walk through an add config to everything. That's that's the whole kind of story there. Actually, I don't remember if that's, that's what it does or not, but some of the other things do it that way. Okay, so let's talk about what we get now, in our diff. So remember that if we render this, so this is equivalent to rendering it. So let's get the tree of data that we would see in our props for our item. And so our props for item would get passed the item stuff. And then the item category, the item category stuff, the item category would get passed, gets config. And of course, the item itself would get past its form config. Okay, so if we go and do something like let's modify the title of item 22. Well, then we see that the title is updated. And the pristine is still the old one. Right? So these operations, you should really play with these play with what what can I change all the items in? And stock should be 11. All right, well, it's 11 now, but it was 22, etc. So to show that we're not actually Well, I mean, we can actually change the name of a category. So let's say we change category one. Well, we're not seeing the whole state then when we take it out of dv two tree. So I can see in this table, I have actually changed the name of a category. So I'm not changing the fact that i i can modify my normalized database tables, right? I might have a category editor. That's not something I'm limiting here. What I'm interested in is, once I get the props in a component, well, that's what I have to work with. What will dirty fields returned to me? If I ask it, what's changed in this form? Right now I don't have any changes. So it wouldn't say nothing. So if I were to change, for example, the item in stock 211, then I'd see Oh, well, item ID 22. changed, it's in stock 211. If I then changed also, its title to, you know, other than I'd see that in the diff. If I change in app state, item 20, twos item category to a different ident. Now notice, when we started this out, we were pointing at category one. So if I change it to two, then my diff would say, oh, adding item category now points to category ID two. If I change category, twos name, and I asked for a diff, notice, I don't get a diff on category two, because category name isn't considered a form field, it's not something that I can edit via this particular form config, right, I'm getting the props of an item list item, it didn't say it edits the title. Now, if I were to go up here, and simply change, for example, let's see it did own it. And so I went to item category, and said, well, that's item named item owned category, right, I changed this or it had category name, as the form field. Instead of category ID, right. So here, I'm not changing which one it points to I'm, I'm wanting to change the name of it. So if I change this to item, owned, cat category, reloaded my UI, see, I've got the same basic behavior here. But in terms of my state, now, if I rerun this thing at the bottom,

oh, category two didn't have config. There's, there's another topic that I need to talk about there. But we'll talk about it shortly. I need to add,

category two wasn't in my, my form set. So let me pull this stuff out of out of line here for a second. So we didn't have form config set up. So I want to make sure that that both of these have form config. So now if I do that, pull out the props. Ask what's dirty, you see that? You should see that?

I don't I don't category to category. two's name. What are my props look like?

category has, oh, we didn't get a proper pristine state, I use the wrong I use the wrong class here.

There we go. So you see, this is a great way to debug when your things are not working. Right. So my category name had changed, but there was no pristine state to defer to because the fields weren't correct. Scroll back here, you can see that my fields in that guy were ID, right, I was still using the class that said Id was the thing, you're going to add it not name. And so diff said, I don't have to talk about that. That's not a form field. So now if I could do this, remember, false just means I wanted in the non Delta format. I could say true here and get the before and after picture. So notice here, what you've got as a result is it's telling me Alright, here's what changed in item. And here's what changed in category. And oh, by the way, item category is now pointing to two, whereas we knew before it was pointing to one, so that's an actual diff. If instead, of course, I had changed category ones name and did not change which category we pointed to, then my diff would say, Oh, my item, these two things changed. And then the category, this thing changed. So I get a very accurate diff of exactly what I want out of the sub forms. So I know that was a lot of, of complexity and moving around, and you'll probably have to watch this video a few times to get all of that. But at the end of the day, hopefully you see this this this gives you a very simple result of being able to declare what you want to track, add in the form config and we'll talk about making this more convenient in the next video of these these steps, there's there's a bit more twiddle Enos to go on. But once you have the thing set up simply having mutations change the data leads to your your validation your dirty diff etc in terms of interacting with the fullstack story

