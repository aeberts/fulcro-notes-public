In this video, I want to flesh out the details of forms a little bit more. So, we've already seen this portion on the prior prior video where we talked about making input fields match our data types in our app states. Now we have big decimal support for our price. We've got integers, for our numeric, integers and such. And so let's talk a little bit more about what you want to do when there are forms. So one of the things you want to do is you want to be able to show validation messages when something's wrong. So I threw in some, some quick little things here, right? say, okay, things here, right? say, okay, characters in the title, then add the hidden class, that's what this classical isn't class UI, floating label, it'll point itself at the thing before it. So. So if there's something in there, hide it, otherwise, let it show. So as long as there's something in there, that's fine. And then this guy's got a similar thing for the install should be zero or bigger. If it goes negative, there's a problem. Okay, that's good. And then the price has a similar thing for it. So validations are our thing you want how you render them is really up to you, you're going to want to design that into your thing. And it's really pretty easy to throw these into the DOM and, and have them render the way you want them to render. It's also pretty easy to, to, you know, move these validations into some sort of, of general purpose function. So you don't have to remember exactly what the conditions are, you could use closure spec, you could do all sorts of things. But as I mentioned in the last video, folker is not interested in trying to be the fit all form generator kind of thing, render your form, how you want to render it, it's not that big a deal. Now, we've got several things that when we're dealing with forms we want to do well, and this thing currently does not do many of them well. So let's talk about what some of those are. So we've got our state management or local states fine. But one of the problems we've got in this in this particular implementation, as I've written it, I enjoy all of this in the in the last video, but we've got this set item price, which is in our model. So if we go look at the closure script version of that, it's changing the price locally, but it's also saying remote true. So it's immediately sending the item price over the network. That's bad idea, right. So if I, if I go in here and look at the Network tab, and start changing this network request, network requests network request, that's probably not what I want, I probably want some point at which this form is considered complete. And I want to send the whole kind of item over the network, I'd probably like to be able to undo any edits I've made. So if I start changing this thing, oh, man, what, though that's the wrong line. What What does that say? I don't have any way to hit undo here. So this is very common set of features that you want in some sort of form, you want to be able to undo, which means you need to remember what was there, you want validation, which means you need some sort of predicate that says whether or not it's valid, and then you also need some sort of rendering for that for that problem. And when it comes to validations, the validations could be really anything, right. If it's a password form, you might need to compare an old pal or the first version of the password, the second version, see, when the count numbers, you might have a time range where the second timer has to come after the first like whole form validation is something you just kind of can code based on the state of the form and the individual fields, but you can't really generalize it very easily, and not have cases that come up that are just wrong. So we'd like to make some of those easier. But in the case of hole form validation, you still need some general way of doing that. So here's what folker does for you that will did sorry, there's one more one more thing that I want to say we need here. When we start a form. We don't want the validations checked. So I don't want the title validation and price validation happening before the users even touched these fields, right. So I also need some indication of whether or not we've started interacting with a form. Because there's no reason to annoy the user with, hey, you made a mistake here when they haven't even touched it. So that's yet another another piece. So a clear time to commit to the server, able to undo things validations don't show unless you've touched or submitted the form. The validations themselves are completely arbitrary predicate based things that can involve the entire form or an individual field. And then we just want to be able to render out. So that's what we're looking for. So let me show you what folco supplies. Oh, one other thing when you send to the server, this is another element that I'll cover in a future video won't have time for it in this one. But when you submit this form, if it's an existing entity on the server, and say there were 100 fields in the form and you only changed one it would be nice if you could just send the thing that changed. So having some idea of whether The thing has changed. Now in the case of

a, the Undo support, you have to remember the original to be able to undo. And so therefore, you can compare and see, okay, this change that didn't change, etc, etc. So we're going to end up with that, that delta support as a trivial side effect of being able to say, Oh, nope, I didn't mean to change that. So the easiest thing we can do for rendering forms is to have you changing the real live thing. So if I find, you know, a thing, I want that to actually still change in my database, the, you know, the, the state of that thing, because that's what I'm used to doing for rendering. That's what I'm used to doing for refresh, that's what I queried for, that's the thing I should be actually changing. And that's the thing that's gonna be most convenient to submit as well. So what we'd like to do is, when a form starts, we'd like to make some sort of pristine copy of what was in the object. And only you know, when that time is you have to do that manipulation, although there's some helpers here that are coming. So we're going to change the things in place in your focus state, and we're going to keep track of all the rest of the stuff somewhere else. Now, where should we keep track of that? We could do that in component local state, but then doing things like subforums, communicating across the stub forums, that would be really, really difficult. So let's say you've got a person with phone numbers and the phone numbers is a sub form, you'd like to be able to submit the whole thing as a diff of that nested sub form, and of all the configuration and copies of pristine etc. and component local state, there's no easy way for components to talk to each other that way. So that's not, that doesn't seem like a great idea. But we already have a great answer for this, we have a normalized database. So if we could just put the configuration around your form. And the configuration, we'll show in just a second, and normalize that into the database, and then somehow associated with the component, we'd be in good shape. So I'm going to reload this UI so that we're back kind of to the stage at least that the server has, we're gonna open up this item. And we're actually not going to use the UI for this portion of the demo, we're actually just going to go to the client and Tinker. And the first thing I'm going to do is I'm going to add some extra data to this options map. Now, if you remember from an earlier video, if you watched them. The only things that are special in this map are query identity initial state, if you're using react, and the browser, you also get the React lifecycle methods component, did mount on Mount, etc, etc. But those aren't anything special. They're just ways of inserting the lambdas. So the lambdas you give her are exactly that form fields as an example of a thing that full grow form state would like to have in this options map. But as you're going to see here in a second, so I'm going to edit the item title in stock and price. So this just lets me declare which parts of the which which attributes on this particular component should be considered form fields that I'm going to have the user interact with, if I'm not going to have the user touch title, then I wouldn't put title here. And of course, then I wouldn't have an input here and just have the title be, you know, read only thing. So that's the basic idea. And all that does, there's nothing magic about this, this literally puts the form fields. Hello, I'm not on the closure script drop in the component options map, so if I say comp component, options, item list item, you'll see it's got the render and the query and informed it's just data. It's just plain data. So if you want to write extended kinds of things that for example, let's say you wanted to say all right, you know what, I'm just gonna anytime there's a form, I'm going to have some extra things that I declare on the component that says, All right prices bigdecimal and stock is an integer and title and here's the order with the fields and I'm just going to call some function, it's going to render the forum for me and do all this madness. You can do that. You can make declarative things work. Again, the the main reason for it doesn't include that is just because there's so many variables to it that it would pretty quickly outpaced the size of fulcrum itself, just just in that one feature. Okay, so point number one, you declare the formfields point number two, if you declare form fields, and it might even warn you over here does not wait, let me let me double check. I think I might have an extra error check here. notes when you go to start to use it. So there's one additional thing you do

the Warm state support. So that's a namespace we're going to pull in its its algorithms form state, the form state support, is going to have configuration data normalized against the component. And since there can be too many relations, like we have here, we're gonna have lots of items. The config is a per item thing. And so the normalization is going to have to be by item. So when we go to do that, the the only way to normalize that well, is to actually add a join into the item that is going to be normalized with and that's what this is for. So Fs form config join is actually just a depth of a join with a namespace to keyword, and then a component that has the query for the different things that form state tracks for you. Right, so So really, all I've done is changed my query there. Now when I go to load these, I have to be careful. The default query transform in full curl on the client. I don't think I've shown that in any of the videos yet. But it's one of the configurable items on the full graph, query transform default. And there's also a global eql transform, that's actually possibly the one that you'd use. The preset for this will strip off anything that begins with or that is in the UI namespace, or is the forum config join, just as a convenience, so when I go to load these things, you know, over the network, watch it make a liar out of me. Right, I don't see the form config join in this query, even though it's technically there. Right. So if I go to item list item, and I add some other property here, like boo, I reload, you'll see boo show up here. And query. If I put UI, boo in front of it. And reload, you'll see it, it's gone again. So there's, there's a bit of logic, it's called the query transform, you can set the defaults to something sane, that lets you do things like you know what, for a particular item, I'd like there to be a checked flag, which is a UI only thing, like maybe I'm going to select four to delete some. And I want to be able to still use this class to load things without having UI checked, confused my back end and inhabits a bow. I don't know what that is. That's, that's wrong. So that's, that's what that's about. Okay, so I have to put this here. And then we're going to stop playing with UI for a moment and actually play with how forum state works. So we're going to pretend like, so I've shown you that you can get the form fields. Alright, there's those two form fields that's got to be there. It's just data. We'll talk about validation here in a minute. But I'm gonna start with comment these out and just show you a sequence. So if I take an empty map, and if you're not familiar with the ads, threading macro, this just basically says, start with this empty map. And then we're going to call it s. And so take s and put it here in this function call. And then whatever that returns will thread to the next thing as s again. So if I do just this one, you'll see that I get a normalized item in my state. So merge component without the exclamation point works on the state map, it can take a Component and Component data, and it returns a new state map. So it supports the same sort of arguments, right? That you saw in a prior video. Oh, does it take named, I thought it took named component data named parameters. That's a path. There we go. So you see the route edge created for that guy. Okay, so that's merge component, that's gonna give me a normalized database that contains item 22. Now, this function in in form, state add form config, and the star suffix is a convention in folcroft. Unfortunately, I forgot to add it to this one and went to beta before doing so I'll probably add an alias for it. But the star means it works against the state map. So if you've got a database,

that's what state map is. So a normalized state, a class and an entity ident. So I went ahead and made an ident up here for item 22, since that's the item I'm playing with. And so I'm going to run that and you'll see I get a much bigger state database, my items still here. But notice now I've got forum state config, and this weird, funky ident. So don't be afraid. idents are a key word in a vector followed by an ID. And the ID can be anything. It could be a date, it could be a UID. It can be a map. And so I'm normalized since I could have multiple forms state config. for multiple items, I'm making sure I get a distinct key here. So I'm creating a map that has the, the identity pieces, I could have nested an identity and the identity, but then that can be confusing just reading it in a really bad way. So I chose a map instead. So you can see, here's the table, here's the ID of the entry in the table. And then here's the actual form configs. So see what this did. What this did was it took, it went and found via this ident, the item and state, it looked up the form fields, because it had the components could ask for the form fields, and it made a copy of them. So it made a pristine copy of the thing. It made a copy of what fields were declared. This is just for convenience, because sometimes when you're doing operations, it doesn't have the component anymore. So it doesn't, it's not able to go look them up every time. It remembers the ident. Again, they won't have the component all the time. So it needs to be able to find it in state. And then there's some sub for support. We're not going to talk about that in this video. Okay, so we add the config. And then we could simulate some same mutation. So let's say we go into the state and we associate at item 22. title. So let's take a look at the state database. Right. So title has changed to s, the original is still original. And I could do things like pristine to entity. And this takes the state map and the entity ident. Right. So that's my undo. Oops, pristine to entity state map entity ident identity. That's still a state

vectors key for associate must be a number. I fall out of something here. Oh, yes. have to put s in there. Okay, there we go. Right. So you see, without this, the state map, I've got s in place that is the original place like somebody started typing over it. And here I've got the original. And then I could say, Oh, you know what, copy, copy that back. That's that's not what we meant. Right? So there's our Undo, we could also go the other direction. Right, and say we've edited it. And you know what, now we're done. So this is like, this is like a commit phase to config. Now you would have to of course, send that off to the server in between and make sure it got there before you perhaps did this pristine step. But giving you the idea that you've got a way to make a copy at the start, right? Some original original, change the thing, and then, you know, either committed or undo it. So this is a great way to just kind of play with the library and see because you know, in closure script and fulcrum in general, you're typically moving from one immutable value to the next immutable value to the next immutable value. So this is, this is roughly roughly equivalent to, you know, put the form on the screen, run some sort of mutation that changes the title, run undo. Right, so this would be like the implementation of an undo mutation like in the action, right section of a mutation. So these are, these are the actual things that you might run against the state map. Now. So let's say we've done that, let's say the user cleared out the field. So item title is now technically invalid. So let's let's talk about validation of these things. Because this, this leads us to several more points. So forum state, lets you define a predicate for validating fields of a particular entity. It can also use specs, but I'm not going to talk about that support. I think for the most part, you'll generally want to use something like this. So you create a predicate, you can hand it the props of an item and which field you want to check in and return a Boolean. That's something you write.

Form state comes with a function called make validator that takes such a predicate, and returns a validator. Now, the reason we want to do this step has to do with the thing we were talking about a moment ago in the UI where I had one. And I don't want my arrows showing up yet. I need to keep track of whether or not the user has interacted with a form field. And I don't want to show these validations if they have not interacted with the form field and interaction is up to you to define repeat that interaction is up to you to define, you might want to show that validation error message on blur instead of the second becomes blank, it's kind of up to you, you might not want to show a password comparison error until both the password and the password copy have been interacted with the idea of Completion is is arbitrary. And it's up to the design of the of the person doing the form. So, to facilitate that, each form field has three possible states. It could be valid, it could be invalid, and it can be unchecked. And then the unchecked state or the the non interacted with state validators will return on checked. So that's that's basically the possible law valid. What do I call those? validation status, I think is what I call them. Right? So let's get rid of these. It's the pristine. And so typically, your validators are used in the UI, right? Where you have props. So I'm going to use this is what full crow does when it renders. So here, let's go through the steps here. So we start with an empty state component comes in, component gets formed, config added, the title gets changed via mutation to blank, and then foco renders. So let's say the mutations done folker renders, what foco rendering does in principle, is it goes out and says, okay, that item on the screen, that form needs to refresh, let's go get the starting thing for that. And then the entire state map. So remember, S is still the state map at this point, get the query for list item, item list, item list item, and turn that into a tree for me. So this D normalizes the state. So you can see here I've got the list of fields, the pristine state still, but but now it's not normalized. If you look back at what we had a second ago, this is normalized, right? We have an ident here, and dv to tree turns it into a denormalized set of props. So this is exactly the map of data, your item list item component would receive from folco. So then somewhere in your UI where you want to show your validation message, you want to ask the item validator about item title. And what this is going to return to us is unchecked. It's basically telling you you've not told me that you're done interacting with that. So I don't know if it's valid or invalid yet, it's just unchecked. Now, that's what this function is for. So Mark complete, indicates and I'm going to take these two out for a second just to show you how that changes things. So let's go back. Here's the normalized database. And then if we call Mark complete on item title, really all that does is add item title to a set in the forum config that says now, titles done, you can validate it. That's it. That's all it does. Very, very, very simple. Now, if we take that to denormalize state, you see it comes in here, it's complete. And now if you ask the item validator, which we constructed back up here, right via this predicate, and this is why you constructed right? This is just a Boolean, true false. And this thing is a function now returns valid, invalid or unchecked. So now if we check it, when it's marked complete, we get Oh, it's invalid. But what if they replaced it with a new title? Now it's valid. So that supports our ability to it to turn on and off our validation messages, simply by creating a sequence of things that that happened properly, in the full CRO mutations, to get us to the appropriate configuration state, that will tell us whether or not the things valid. Now, let's say we've gotten to the point that we've got everything the way we want it. And we're in the UI, and we're going to run a mutation, right? You're going to say comp, transact, etc. And you're gonna have to pass what you want to save here. So again, you're in the UI, we're still using props. So the thing that I want to get

here is the props. This is exactly what the component would get. So form state comes with a

function that can tell you well, item 22 and this is notice this is a dean at this subject. This is a normalized delta is saying, Oh, well 22 item title. The pristine says it was original, and but your current status has gotten your title. As you get this kind of it's got two modes, one that just says, here's what it is now. And then there's one word to delta mode where it says, here's what it was. And here's what it is. Now, the ladder, this one right here is useful if you're doing optimistic concurrency with the server where you're trying to tell the server, I changed it to this, but you should do a compare and swap and make sure that's true and send me an error. Otherwise, they'll tell tell them, somebody else edited it, and revert my change that sort of thing. So you have you have your choice, you know, last last wins, which is kind of what most people write, right? I'm just gonna set it I don't care if somebody else changed it, I overrode it. Done. So now, if you think about this, this is when you get into the sub forums, this normalized Delta makes it very easy to write a concentrated single mutation on the server that can understand these deltas, and this naming convention, so imagine you were putting this in Postgres, and you could use the name of these to find the table, and the name of sorry, the namespace of these to find the table and the name of these define the column. And so this would basically say, you know, update item, set, I said, item dot title, new title, where item ID equal 22, there's your, there's your SQL statement, just generated straight from this. And if there are sub forms, and you had, you know, the normalized stuff coming from the UI to the server, this would be a map of all of the things normalized. So you might have like, person ID, person name, and then phone number ID, you know, phone slash number, etc. So you can just go through the keys of this map and see, okay, on this particular row, I'm doing these sets. And on this particular I'm doing the sets. And there's your right. So So this utility here makes it very easy to send to exactly what's changed from the client to server. So let me show you, let's say I had item in stock 22 item price was

that was the original object. And you see, I still get the same dirty fields. But if I go in here and change item in stock to 10. Right, so this makes it pretty easy to build up, whichever way you want to do it as as just a sequence of mutations against this state database. So that's the general idea of form state. And in the next video, we'll talk about actually putting this more into play

