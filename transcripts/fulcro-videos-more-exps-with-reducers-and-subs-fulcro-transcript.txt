So I've been experimenting a little more trying to think of other ways that we could get similar or interesting results, out of out of kind of derived values or values that we're pulling from alternate ways from the composed, query with composed reified view tree. And so, on that first example, we did in the last video, we were essentially putting the reduced data, peppering it all all over the place. And in state, which, which, you know, give us an interesting result. But I think it's not ideal for a number of reasons, we're denormalizing, this value, really, there is only one value that is this 46 value, and we're peppering it all over state. Well, it's kind of cool that we can use the indexes to figure out how to do that. And it might be useful for certain use cases. It's also you normalization, which you know, fulcrum is trying to give you a better story than that. So folkert already has, if we think about it, the ability to do route based queries. so we can write a query like this, where we query for a particular ident. And so what we could do is create a well known location for reductions at this, this keyword reductions, and put our things there that are that are resolved, or reproduced over, and then just literally query for them. So now you don't have to compose this data into the literal data tree of child child doesn't even have generated data, but it can get to it. So this, this solution ends up looking almost identical to the to the first one. Although the first one had all of this logic to figure out how to pepper it throughout state, and in this, this new one, that collapses down to something much easier, you know, go through, generate the data and just throw it on this top level key. Now, if I look at card two, I pop open Oops, sorry, wrong key, pop open dev tools, pop to this guy and Inspector, bump something sell something, I see now that I have this reductions place. And that's where the data is being being tracked. And the individual children no longer have it, but they can query for it. So that's probably a better solution than Redux reducer. One, even though we're user one has some cooler, you know, kind of playing with the internals kind of bits to it. The rest of this code is, is pretty much the same, the only big difference is the components that want to query for some reduction query for it. Now, as I look at this, the next thought is, well, one of the things we wanted was the ability, or one of the things we might want is the ability to just disconnect one of these things from the tree. And a while back, I made a, you know, floating routes demo that showed how you know, Volker can support this with basically a plug in render, which I've since built and made the default. So there's this multi render card here. So if we pop in on unexpected here, we see that there are two children, but they're not currently on screen. And if we go and look at this

What did I put this in multi routes.

I think I fixed the bug in this Yeah, I had left something laying around that wasn't gonna work with def cards. So I think this currently works it does. So the idea here is you can have a disconnected a completely disconnected floating route that uses hooks notice, there's no query and ident here that can then subscribe to a mount decision and essentially, V hooks use a mount of that child with this initial state. And when this alternate route mounts, it then can render via that factory, this other child and this also has this huge generated ID where it gives you this generated ID passes it to the the new child and then this UGC hook can remove an entity from the database. When when this whole thing on mounts. So the result of this is at the top here the main route. Maps over children arrive pre initialized to children as I showed you in state here I've got two children. I'm not rendering them yet. As they mount notice, the others come in spring into existence with their values. And each has a you know a counter so I can you no bump these counters separately and see their their numbers going up in state and if I unmount the children that will unmount and clean up The others. So that's an interesting way of having a thing that's disconnected from the UI graph. It's not a reducer kind of value, it's just a spring something into existence, throw it out of existence, just as an aside. Now, as I looked at this second example, you know, it occurred to me that one of the errors that people often make is they'll do this, this kind of query, well, they'll just ask for something from root and the wakeful grow reifies, the props in order to render children, this ends up not reifying anything for the child, and then the child ends up not getting that value. And so it's a source of confusion. So this one's perfectly ideal. If your thing already has state, it is composed into the reified view graph. And it just wants to pull some additional thing that you're keeping up to date via this kind of reduction system. But it's not ideal if what you really want is a truly disconnected leaf node that has no query of its own, it has no idea of its own, but you just want to render it somewhere in the in the tree. And perhaps you want to compose some subtree out of that, and continue to have sort of like just free floating subscription. So this is a feature that a lot of people think they want for photo, I see definite uses for it and advantages to it. I think you miss out on some things if you drop the reified view graph for for everything, but I do see use cases for it. So let's talk about how to do that. So this reducer three is using react hooks for pulling in this case, reduce data into arbitrary components. And you can pull that into leaf component, you can pull it in wherever you want. So same code for making the reducers. Right? I'm not, again, this is a whole subsystem, you could design and have a whole bunch of mess around. And I'm more interested in how would you integrate it with fulcrum. So the idea for this one, is we're going to make a reducer, our own kind of effect handler for react, where we're going to use some state where we initialize it to nil, which is going to give us back a pair, the current value and how to set the value. And then we're going to pass that into an effect hook, where we register the desire for this prop on this setter. And during teardown, we register this prop with the register that prop and setter. And then we make this effect hook only change if the prop changes. And of course, then we return the value, which is the current value. So the idea here is by calling this function, you'll cause whoever uses this effect hook to rerender. So this is an automatic render hook, just kind of built in. So if we just throw that into a subscriber map, we've got a map from prop to all of the functions that we can call to set the values like target those values straight to the components that are interested in them. Well, then we've got a way of doing subscriptions to a particular reduction value. So we still here are, you know, hooking in our simple like global top level, let's just assume reductions in at the top level table. But we're doing an additional hook or we're saying for every key in that generated map, call this push value function. And push value is nothing more than where did I put it,

it's nothing more than a walk over the subscribers to a prop calling set value. Were set value is the you know the function this is basically just a set of of those set functions. A mathematical set of the functions that can set the value. So it's pretty straightforward, right? Maybe you have this reducer hook, it goes over makes the new reductions, it puts them in the state atom. So you can still query for them if you want to query for them. But then it also finds the subscribers for that particular value and sends them that particular generated data value. And of course, if there are none, this push value doesn't do anything. So there's no more more directed Kind of, yeah, pull semantics. So I can either pull these things, like I said, via the query that we had going before, right, some top level query, or I could make a plain old function. That's just that new, right? That's what a react hooks component is. Nowadays, it's a plain old function that says use that reduced value, renders it and then we can make a plain old you know, React factory. For it using this is react create element. Right wrapper for a great, just like low level react. So now I have this thing that I can render anywhere and I'm just dropping it in here for fun. And so now in this card, You know, got the same sort of result. But now I've got this leaf node that's watching that value as well. And is updating along with these guys that are, I don't remember if in this demo, I had them, subscribe to it or query for Yeah. So see, now I've got a mix. With def SC, we can say use hooked true. And that that'll turn this into a hooks component that no longer uses component lifecycle that uses hooks instead. And so I'm both getting my query from the tree and a reduction value that I can use. So this is nicer in that it gives you both the advantages of two things are normalized, and a subscription sort of model where now you can get your disconnected leaf in a very trivial way. Right. Now, if you take this a step further, you might ask, well, do I really need? Well not to I really need what other interesting things I had another, as I was doing this, it occurred to me Well, okay, you might want to subscribe to a prop. But you might also just want to subscribe to a query, like what if you want to standing leaf node like this, where what you'd like to do is pull some sub query of the state where you happen to know where to start and what you're interested in and right, you'd like to treat that as a subscription. So So take this just one step further. And in this case, I'm going to back out of the reduction system, right, this is interesting, and you can certainly do it, you can hook this into the transaction system, you can also hook this into the rendering system, which I'm about to show you how to hook into. And I was thinking overnight that the transaction system, where I have currently hooked it in these demos, again, this is just like invented transaction hook at the moment, it's probably not exactly where it should be hooked. At the moment, this is this is actually a pretty noisy spot that I've hooked this to, because it gets called on every element of a mutation. So if I've got, you know, if I'm transacted F, G, H, and it'll be get called once for each of these in the optimistic, then it'll get called once for each of these, as each one like does a network request, and then it'll call each one of these, each time one of these has a network response. And there's actually a different place, we can hook it, which would be like after we've done all of the processing of the transaction nodes, right, then trigger the reducers. Anyway, that's just a side note, it doesn't really matter for what we're talking about here. So let's go to the final one here. So in this case, I want to pull reduce data. But in this case, I want to actually query do a query. So same sort of setup, notice I've killed the reducer stuff. And instead, I've just kept this react hooks kind of mechanism of, I want to be able to add a subscriber on some key, but it's the Prop, I'm actually going to take an entire query, that's going to be my key in this map, and the value is still going to be a setter. So it's same trick for targeted updates, I'm just gonna use the setter. So years query subscription, again, allocates state with a starting value of nil.

It does a use effect. And this time, we're going to use the query for keeping this effect from happening more than once, right, it'll just set up once and tear down once on Mount and unmount. But the query itself is generated by a function dynamically at runtime. And so we've got to be careful that we use the hash of the query instead of the query itself or this whole. And when we do this set v inside of here, this will just like, bang bounce all over the place. But that's the main difference with this one is what we use here. And the fact that when we register the subscriber, we want to give it an initial value that's calculated. And in this particular case, I'm putting this inside of the effect. And I could use a second effect hook to kind of do this. But instead of putting it here, because use query subscription is going to be a function that's called every time this thing renders is you want to keep it as light as possible. And so I could put this initial state calculation out here, but then it would calculate it every time it rendered and I only need it on the first one. And I only want it to update. I want to be able to control updating it on actual changes I care about which I don't think I've coded in this particular example, but it's an optimization that I would like to keep, right if the if the state didn't change. I don't want to recalculate the tree, so nothing complicated here, grab the state map, run DB to tree on the query, get the value, put the initial value in there. And then from that point forward, the set V, can be used by this push value for the register subscribers. Instead of doing this in a transaction hook, I thought it might be interesting to show how you could do this in render. So this is a render function that is just delegating to the real full grow keyframe render to to do the main like from route render. And then because this render is not going to give you the updated values in any of the components, we're doing an additional step of for every query, find the setters, figure out the sub tree they're querying for and send it to them. So this is and then this can just be plugged into, you know, folk or as the optimized render. It's the we mount, we save the app, this is really, because we're in cards here, I don't know, it generates the app. So I have to like kind of grab it and put it in an atom so I can see it. So that like this initial value thing can work. So then render, again, just this do seek and now I've got the ability to create things like derivative functions, use child sales. So this is like a hook function that uses the query subscription based on the child ident, and a child query to pull the stuff for a particular child reduce over it and give me back a result. In fact, I could have been a little more specific, you're given a child ID and I could have explicitly manually made the sub query since I only need child sales sale amount, like that's technically the only thing that I'm using in this particular subscription, I could hand code the query that way, but just for convenience, I coded it that way. And so now use child tails can be used in a leaf node. Again, plain function with a plain react factory, can be used at the top in a real hook capable def SC, where again, we're not querying for, well, we technically have the value in could get to it. But we can also use it as a hook to get for example, Sally sales because that child ID three, or in the leaf, Sam sales, because his ID is two. And so now when we pop up in the subscription card, we see the subscription to Sam sales, we see Sally's subscription there, in that leaf node. And as we sell things, Sam's total updates. So mix and match any of these various solutions, we can certainly move the subscription handling into a more optimal optimal location, maybe it doesn't go and rendering maybe it does go into x hooks, etc. So just some brainstorming around. Some, you know additional things we can you can add, I mean, you've got access to most of these hooks, especially the render hook you've already got access to. And then as soon as I decide where the transaction hooks should be allowed I'll I'll add those to the application and we can have some some interesting add ons.

