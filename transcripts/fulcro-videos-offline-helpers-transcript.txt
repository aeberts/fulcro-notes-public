In this video, I want to show some new, semi experimental namespaces that can assist you with server outages or temporary network outages or other potential uses. These are offline support mechanisms that I've been working on and using in production. primarily what they're used for I have two specific offline pieces. One is a load cache mechanism. And what it can be used for is, once you've loaded a particular thing, in the past, it can be used to store that in a in a local storage, any sort of local storage mechanism, whether it be mobile, or that's pluggable, where you store it. So that if for example, let's say you're writing a mobile app with full grow, and the mobile app starts, and you always need some data from the server. But this is an app where they might have they might be in airplane mode, or whatever you'd like the app still to be able to start, you'd like to be able to load the last, the last set of things you saw. So that's one mechanism that's here. And the other mechanism is, you want to make sure that some particular thing that users done, that's supposed to be full stack, can happen optimistically, immediately, and then have some insurance that will happen on the server. Now that mechanism requires a lot more effort on your pieces of it. But it gives you a way to to make a mutation that can succeed with best possible effort. The user losing power, whatever. So it's two way say, for example, you were taking orders, or you're charging a credit card, right, and the credit card processing went through, and then you went to store that information on your server, but the server wasn't available. This is what I'm going to show you installing them is relatively easy. In the in the main of your of your client side application, you bring in these two namespaces, actually three, you need four, really, you need a store, which is an implementation of a protocol. So in the browser, Eden store is a pre supplied implementation of this protocol, the user's browser local storage. This, this was for the load caching. This is for the mutations that will try and basically forever. And when you're doing mutations that might be saving something, you have to deal with temp IDs. And so temp ID strategies, another protocol, and it comes with two implementations of how to deal with temp IDs, so that your application can move forward. As if things went okay. Even in the presence of div id. So if you've used forum state info, you're aware that temp IDs if you're, if your object has a temp ID on it, forum state considers it dirty. So one strategy, temp IDs Have you IDs in them. So what you could do is you could use this temp ID as REAL ID strategy. And what this does basically is this immediately tells you the REAL ID is going to be the UID inside of the temp ID so that remaps can happen immediately in local state. And then you just have to implement on your server logic that understands it's going to receive a temp ID. And it can actually read the transaction if you want a different mechanism for that. But it's going to receive a temp ID but the client will currently think it's using the real Id already. So the remaps will have to include if if you aren't going to use that new ID on the server, the remaps will have to include going from that, that you UID to the real real server ID. So those are the pieces there. So to install them. You create an instance of an Eden store that knows how to store just what it says it does. The browser Eden store takes a prefix, and then it stores those things in local cache using that prefix. In the entries, of course, you have to be careful about going over the storage limits. But you'll see stuff in here that's that's being stored due to that. So the folkert app itself, these modify the settings on the folk rap. So with load cache overrides the load mechanisms with mechanisms that can do cash loads, and they're all mutations overrides the transaction mechanisms with mechanisms that can do durable mutations.

Now this doesn't change all loads to be cached, and it doesn't change all mutations to be durable. You have to opt in at the call site. So for example, if I'm starting the app and I want to load to do list one Want to be sure that I get a to do list if there's one in cash or if the network's up preferring, of course, the one that's in the network, then I can use load cash as load. So these namespaces have, these two newspapers have their own load and transact mutations that really call the, you know, the normal folk are ones. But add in some additional stuff. So, show you the load guy, I've got the application running, I can load the server, there's the right, there's the list that the server currently knows. And I can click this button to reload the list and you see, you know, some network activity happens when I do that. Reload, I added this little link to just do that, and I get the list. Now, when I hit this reload, this is in the UI over here as loading from the load cache, and if I now go and shut down the server, okay, so no longer are connected. And if I go to the console and clear this and click reload, here, sorry, first, let's delete something. And then click reload. You see, it came back with the value at last saw. Now, this isn't a safe operation, right, I've deleted see. And I did that. As you'll see in the UI here. I required the durable mutation namespace and required transact. And then I changed all of the calls to transact, in this application to durable ones, which means that delete will eventually succeed. But my reload just reloaded it from cache. So this is the kind of issue that you'd have to deal with if you wanted this to be a true offline mode, as opposed to just the items I described at the beginning of the video. So for example, if if you were doing some modification, that should invalidate the cache, you probably want to literally go down to the browser Eden store and say, forget that, or load what's in the Eden store and update it and resave it. So there's some additional work to do to make of complete offline mode. But these are kind of primitives that you can build from. So I'm going to restart the server here. And I'm going to clear the server's repple, just so you can see what what goes on here. So I'm going to start this guy. And you'll see, it's now started, I'm gonna actually completely close that tab, I'm going to reopen the tab, it's going to reload, it's going to show me the list. And now if we watch the server log over here, I'm not touching any any UI controls here. The durable mutation was persisted. So the server is going to receive this deleted item instruction. And now if I were to reload the list, I'd see see disappear. So again, you see from a true offline mode perspective, what the server thought it had, was out of date. So again, these are primitives, these don't get you all the way there. If you're doing reads after writes, and you know, those kinds of things, then you might end up with inaccurate results, doing something that's not item potent, or something that has a particular order to it or something that, you know, in this case, it has an order to it right load requires that you see all the rights before you load it. And some of the rights are queued up in memory. So you can't use these utilities to make something like to do MVC fully offline capable. That's kind of one of the points that I'm trying to show your. But these two primitives are extremely useful for, for doing things like I described at the beginning the video. Now, the dermal mutation mechanism. Let me show you just a little bit more about that in the API section here, because there's a modification you have to make to your mutations. Every time the dermal mutation system tries mutation, it calls the action be optimistic action. And you can detect using this retry function, which is from the durable mutations namespace. Right, you can ask, Is this being run, you know, because it's a retry. So if the action isn't item potent, and in this case, adding something to the list is not item potent? You definitely don't want to do the optimistic action over again. But there's also in this durable mutation namespace, the ability for you to ask,

which attempt it is. Remember the name of the function, I think it's just attempt together it is. So if you had a mutation, and it'll tell you it's just stored in the mutation end Which attempt you're on. So if you've got some something where you'd maybe like to show the user a warning, hey, you're offline. You know, you could say when the Derwin mutation attempt is, you know, greater than 20, you know, whatever, right? So you can change what optimistic action you do here based on is it being retried? And if so, how many attempts have have happened, that sort of thing. So this allows you to morph how your UI responds to retries. Same thing with Ok, actions and error actions, every time this thing fails, you're going to see an error action. And again, you can use these the attempt to figure out how many how many times you've attempted it, you can use this to update the UI, whatever you want. You could even use this to abort. There's a you know, there's a way to I'm sorry, cancel, there's way to cancel the mutation. So if you see an error, it's too many retries, you decide, I just want to give up on that one. You can do that here. So it gives you quite a bit of flexibility. But it does require it's not just a drop in thing that suddenly gives you offline mode. This is the thing that gives you tools to automatically retry mutations, cash and load from cash, when there just happens to be a network problem when those operations are hit. So these primitives, of course, then can be used to start to build some sort of offline mode. So they're the beginnings of offline helpers for Volker

