In this video, we're gonna see how the transaction processing works in full CRO, in more detail. So all of your loads and mutations go through the same basic internal mechanism. And this is one of the biggest differences between foco, two and three is the internal design, all of the old internals were kind of thrown out in the new internals, were built to fix a few of the things that just couldn't be addressed, with the old internals addressed directly or very well. So let me just kind of very quickly give you an idea of how things happen. A transaction, which could be a query or a mutation is submitted to a queue. And while you're holding the thread in JavaScript, you can submit as many of these transactions use queries and mutations as you want. And they all fail end up in the same queue in or in the order of submission. And then as soon as you let go the thread after a short delay, the queue is processed. This this submission queue is processed into an active queue. Now, if you think about what that looks like, it's actually a relatively, or what it needs to look like, it turns out to be a relatively complex sort of things. Let's talk about what a transaction might look like you might do a sequence of mutations. And as you remember, we're gonna look at like a definition of one of these mutations. You can have optimistic actions that happen against local state, you can have remotes, and there's some additional things you can you can add in to the options of the transaction submission queue. To tell it, this particular transaction needs to happen. pessimistically, which means that instead of it running through fGh, optimistically and then doing the remotes, it would run through EFS full interactions locally and remotely, before starting GS, locally and remotely, before then processing ages, remotely and locally. So that right there indicates that each of these mutations, which could also have returned values that need to be tracked, need to be trackable. Separately, they might be sent as a coherent unit, they might all go to the same remote and might actually end up on the remote as this exact transaction. But let's say that g was a UI only mutation that didn't actually do anything remotely, the server would see f and h. And then there's another case where maybe you call the same mutation that has remote effects. Three times in a row, well, the return value of a mutation is a map keyed by the symbol with the result return value, you get the result of the mutation, those actually have to be broken up in order for this return value to make sense and be captured. So this has to be broken into three interactions with the server. And whether or not that that goes on the same network request or not depends on more things. But there's just some some of the variety of of complexity, that the system's handling for you. So these things go into the active queue, they get split up into units of execution, so to speak, I'm going to take some Liberty with exactly what happens here, this is a good way of thinking about it. The things that need to happen. And those go into are those actually stay in the active queue, as long as there's something to be done for each of those units. So a unit of execution has things like which parts of it have been complete, right. So there might be a set here that says, Oh, well, the action parts been complete. But the remotes not yet. Those kinds of things. So So each of the things that needs to happen is tracked in these units of execution. Now as a unit of execution is reached, and it indicates that it has remote interactions. And as you saw in earlier videos, you can have any number of remotes, so you could actually, you know have remote a, remote B and remote c also see this in addition to the default remote. So there's there's any amount of remote interaction that a single mutation could do. So we need an additional cue for keeping track of what's being done network wise when those are done. So for example, we can distribute the results and in a pessimistic mode of operation, allow the next thing to go. So there's a lot going on here. And I don't expect you to get everything out of this video. I just kind of want to give you a basic lowdown. Now it turns out that load if you go and look at the implementation of load, it's actually actually implemented

as a transact with an internal load mutation, which sort of sounds like a is sort of a misnomer, but it uses the same transaction processing system. And then this, this internal load mutation, which you can actually override, to deal with things, however you want, is done, I showed in an earlier video how mutations really are multi methods. And in this case, the dynamism of this particular mutation requires that we write it as a multi method, there's no way for the syntax of duck mutation to to let me For example, change the remote name and the syntax. So all this is doing you can see is is plugging in some stuff into that map for mutation submitting it to the transaction system. So everything that happens in terms of evolution of the system, mutations, loads, local, you know, updates of state, all that stuff happens through the transaction processing system. And, and so that's why it's important to understand what's going on here. And a lot of this is pluggable, there's a lot of places where you can put your own additions or changes to the logic. In fact, the intention is for the entire entire transaction processing system to be pluggable, if you really want to get extreme with it. Although of course, the default implementation of full cross transaction processing is meant to be general purpose enough to serve 99% of people's needs. And in fact, that's, that seems to have worked out pretty well on all the projects we've used it with. And we've used it with some fairly large ones. So we have these units of execution. From here, we can follow a path to doing the optimistic changes. So the action block. And possibly, if there are remotes, set in the, in the particular transaction that you're doing, then network sends, okay, the network sends actually submit to a network queue. So we can walk through this these units of execution. And as we're walking through and saying, Okay, do you have a remote? Do you have remote Do you have a remote, we can stack those up in this network queue. And then there's a step from there where we can recombine or further, combine the units back into a network transaction, which is then of course sent to the remote. And then the remote is going to give us a response. And the responses then processed. The response is processed by the result action section of the mutation would you haven't seen yet. And the result, action has a default. That can be overridden, it can be overridden globally, and it can be overridden on a case by case basis. So this gives you a lot of flexibility. And again, you can get by with programming fulgur without knowing very much at all about how the internals of this work, what the algorithms look like, you know, the fact that there are queues just tend to make things sane, right things happen in the order you asked them to happen. And things get grouped together. So they show up in the server in some unit that makes reasonable sense, given that you're in a distributed system. So that's that's what this system is trying to accomplish. And the plugin points allow you to kind of further refine that, for example, this recombination step, which at the time of this recording isn't fully pluggable yet. But the plan is that this recombining step, which takes the normal units of execution. So take that example we had earlier, where we said f, g, and h and that was broken down into at the units of x execution F comma g comma H as separate nodes. At this point, we figured out that the network q maybe has f and h on it, and then fnh get recombined so that a single transaction is sent to the remote for efficiency and to preserve as much as possible the transactional semantic you implied by saying f should go then g should go then h should go. But the further combination that could happen here is that if you had submitted multiple separate transactions, and there were mutations that were going to that same server as well, they could potentially be piggybacked together onto one single network

interaction to provide more efficiency, right, reduce latency and such. And that could all be done behind the scenes silently, covering multiple For example, let's say, you know, loaded six Things that start up or whatever, those could all end up issuing a single load to the server. And in fact, photo two has that combining folklore three, the extension of this mechanism has weakened that combining a little bit, but only hopefully temporarily. Okay, so the main thing we want to talk about in this particular video, most of these internals you shouldn't normally have to care about the optimistic pessimistic stuff is more of a historical fold grow to necessity. The folklore three design mostly eliminate Well, it really does completely eliminate the need for it. But it's there for easy easy porting of f2 apps. And if you happen to prefer it, so I'm not going to talk about it, because I don't really think it's, it's the ideal way of doing these things. The networking layer, we provide an HTTP remote for you, that will work pretty well for most people. The rest of this, like built in stuff, you really don't need to know too much about it, the thing you mainly need to know about is this part, what happens with my remote results, because this is where things can go wrong. In full stack applications, you submit something, it's got optimistic actions, well, you know, the code is all here in RAM, if something goes wrong, it's the CPU crashed, the motherboard cracked, there's not much you can do about it. But if you're talking to the server, and the network's down, or the database is was interrupted, or whatever, you're interested in knowing what happened as a result of your mutation. So that's the main thing we're going to concentrate on, I just wanted to give you a quick overview of what this transactional system looks like. And the fact that pretty much anything that goes full stack is implemented via this, you know, fairly involved, but but for good reason. system, this mechanism. All of this, by the way, if you want to go read the source, study the algorithms, throw in debug statements and see how it's all working is in the TX processing namespace and full core algorithms. And it's roughly 650 lines of of closure code. So if you're, if you're just dying of curiosity, they're ready to go look, the book has a little bit of information on this. But mainly, it covers this important part that we're going to talk about here. So I've got a remote, as I said in earlier videos, let me go ahead and delete this because we get the idea. When you say remote true, then on the server, these mutations are allowed to have returned values. And I even said, yeah, if you're doing a mutation, and it really doesn't need to say anything back to the the client, you probably just want to return an empty map and make sure that that you don't confuse transit with some non serializable garbage. Now, the other thing that you might want to do is you might actually just want to return some value that the mutation itself on the client could use directly without merge. So in an earlier video, we talked about how you can do mutation joins, you can save like returning on the remote side over here, right, you can say I'm going to return some data type, and then you'll get auto merge of that. But that's the happy path. And that happy path might not be what you want, maybe you're doing a some other server side thing. And what you really want is some sort of success, kind of indication. So you know, I'm just going to for fun, put result 42 and make make holder just so we can have something there. And I'm going to go over here and restart the server. Which should actually, I'm gonna stop the server, I'm going to, oh, I can't do that. If I'm not the user namespace. I'm gonna stop the server to get rid of my state. And I'm actually gonna use a keyboard shortcut to tell it to unload and reload everything. And then I'm going to start user.

Okay, so if I load this, I should see, Bob, and he's 22. Okay, everything's just like reinitialized. Okay, so I just showed you that I'm changing this mutation rate to return result 42. I can go over here and open up inspect, look at the transactions tab, or the Network tab, hit make older see the full stack. And I can see in here that the response included result 42. And if I go look at the database. If I search here, for 42, you'll see that it's not anywhere on there. So we didn't tell that the mutation was returning anything so the client just silently ignores the return value. So that's the default behavior of the client side mutation. If there's a return value, and you haven't said anything about the return value, the return values just ignored. Now what you can do is you can define a result action.

I'm going to kind of show you some of the stuff that's in the end here. Oh, sorry, that's the wrong mutation.

And we need to find that guy, and I make over actually see a bunch of keys come back, and I'm gonna open that up to see this. So you can read in the book, what what about most of these, the, the dispatch key actually is, um, is a entry. That is a map, going from keywords like action to a lambda, that is action, keyword result action to a lambda that is this result action section, a keyword for remote, that is this remote. So that's a way of looking up other sections from the result action itself. The result is actually what came over the network. At the low level, like it's the core hardcore result, we've already seen state and app used, right? That's your application, that's your state atom. These are the options that were sent to the original transaction. This is the ident of the component that ran the transaction. And this is the component class that ran the transaction. So you've got some additional information about like where the transaction came from. Okay, so we're interested in the result. So I'm going to log out the result. Let's go back over here and hit make holder. And you see the result has a bunch of stuff in it. And this is a low level network result, it has the transaction that was sent. So we sent a make older mutation for person one, the outgoing request, here's the low level, outgoing request, have content type j, transit, JSON, the encoded transit, cruft the URL it was going to and the HTTP method, right, so it's really low level information. You know, specific headers, most of this stuff isn't all that useful. But we see the body is what the the server returned. And there's a result. And notice, the result map from the server is always keyed by the things that were in the transaction. So there was a mutation in the transaction, the symbol name of the mutation is a key in this result. And whatever it returned is, is this value this map, then we get some other things like status code, whatever the HTTP remote support actually wants to throw in this map and throw in this map. So actually, if you customize the remote, you can throw whatever you want in here. But at a bare minimum, for folks to understand it, it's got to have a body and a transaction. And if you haven't overwritten some things status code, because it has to figure out does it consider this response and error response or an okay response, and we'll talk about that here in a second. Technically, if you're doing result, action, you don't need you don't really care. Because once you do result action, you're you're kind of done, your processing of this is his over focus, not going to do any additional things. So let's thread that through the result key, which is part of the end. And then that result has a body as we saw, and then the body has the symbol of this mutation, and then the value of that is the actual result. Oops, this needs to be a get. So now if I call MC older, I see this, I get the actual result. So if you wanted to do something with this, I mean, you could say keys state as and then you could say, you know, let my value be get make older, because I get you I get in me colder result. And then we could say something like, you know, swap bang on state soce. Boo with V. Go back to forgeron SPECT, clear these things out, look at the top level keys hit make older and I see bu s 42. So I can kind of write a result action that does anything I want to do here, I can pull the app, and I can run a new transaction. I can use the app or I can even use the component that's in here. Right? The components not always in there. If someone transacted against app component will be there. So app is the safe thing to use. Then I can call some other, you know, some other mutation. So I can pretty much do anything. wanting this result action. And the deal is that behavior always showing you with like returning values and changing the, and having that auto merge and such. That's the default result actions behavior. And the default result action also can distribute results around based on things like the status code. So you can use result action directly, but it's a little bit to parse through.

If we go look at the default result, action, which is Invoker. mutations, this is the actual code that all mutations use, by default, if you don't define result action. So it updates errors on the UI component. This is a handler that that basically does that. It triggers global error action, so that you can define a function that gets called if there's like a network error, that that just gets called anytime a networker happens. Dispatch actions, which we're going to talk about here in a second and integrate mutation return value. So this is the one we saw on an earlier video where we could say, this thing is going to return something. And here's what the query is going to be. This is the code that actually looks it up. And, and basically puts it in a results type IDs, it does, there's lots of little steps in here. But that's, that's what's been running to make this work. So if you override result, action, you lose all of that. However, mostly what you're interested in, is either knowing whether or not the thing was okay, or whether or not it was an error.

And then, you know, you might want to tell the user. So now, if I run makeup, make older, it's going to do all the normal things, but it's going to tell me, okay, when it gets that, that good network request, or network response, and let's see, I shut down the server. And I try to run make older, I'll get that the network error here, and then I'll see my alert pop up, because the error action side happened. And the end has the same sorts of stuff in it. So you can, you know, continue to do whatever you want in here. But this lets you kind of split it between hard errors that you can't really do anything about and results from the server that that are the happy path. So this gives you pretty good flexibility in terms of of how to deal with the post processing of a network result, without having to use, you know, an async await sort of specific pattern. For the most, for the most part, you're gonna have happy pads are gonna have a sequence of mutations that that happened. And those results are just all going to happen in sequence, because of the transaction processing system itself. So there's no necessarily any need for this than this than this. And it's nice to also be able to kind of handle your chaining, if you do have the, you know, the rare occurrence of chaining and full grow, where perhaps you you know, submit some mutation, get back a result look at and say, oh, that means I need to do this next mutation, you can just put the transact here in these in these actions. Okay, the one other topic that I wanted to mention here, while we're talking about transaction processing, is how we determine whether or not the thing is considered an error. And that's actually configurable by default role there, and it's a really simple function. So the default detection is it looks at the status code of the result. And if it's not 200, it's an error. And that might be entirely too strict. I mean, the way we've written the server always returns a status 200 when an exception is not thrown. So in this in the default case, with the default remotes and the default middleware that you would use, this is a reasonable thing to say. But you could also look in the body itself, you'd have to define your remote err. And then in the client, you can just override that. So if you look at the doc string, or folk rap, you can define should be right, right here somewhere, there's the default remote action you can override. And then there's one here for remote error. If you specify this key, this is a function that looks at the network result and returns a Boolean. So you can look at the network result. And for example, if you've used incubators, pessimistic mutations, you could indicate from the server, an error in this in this value with just a special key, right, you could say something like the pessimistic mutations namespace errors. And if you put anything in here, it indicated this mutation had an error. So you could define a function that says if a specific key appears in the return value of the mutation of mutation in a body, then that thing's an error. So there's all sorts of flexibility there. So I'm going to take this back to just a default map. And that's the end of this basic topic.

