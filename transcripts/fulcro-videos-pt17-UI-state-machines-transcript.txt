So now we're up to UI state machines, you might want to review the YouTube videos where we established the session and login code. Not necessarily required, but it would help for you to understand what all is here. So when we first coded this, we, we established this login screen, and you can log in, and it comes in here. And once you're logged in, we have sessions on the server. So if we reload the page, it figures out that we're still logged in. And it actually prevents showing this, you know, this middle part until it knows we're logged in. So there's several pieces going on here. And this is the perfect job for UI state machines. So let me review a little bit of the code as we had it. So even if you don't want to go back and watch that video, this, this might get you there. So when our application starts, we mount the app, we start our routing, which has to do with just the pushy, you know, keeping track of this URL kind of thing. And then we load the current user from the server. And the server uses cookies to figure out if the browser that's trying to load this is associated with a person enough, so it returns the valid user. And then we call this finish login mutation, which checks to see if the current user is valid. And if they're not valid, then it sends them to the login page. And then no matter what it goes ahead and sets this route ready, flag to true. And that route ready flag is used to show this middle, middle part. And of course, this main router is the thing that can route us between the login form, the home and the settings page. So technically, the router can get us any of these pages. But we're making it so that unless they're logged in, they don't see the menu. So there's some stuff we're explicitly tracking here. So for example, we're going and grabbing the current user, and and seeing if they're valid to figure out logged in. That's probably okay. Right, that's, that's a piece of state that that we have, it's very clear what that state is. And so, you know, this is declarative UI, we might as well use these directly to render things. So one of the core lessons that I want to show you, besides just showing you the UI, state machine support and full grow, I want to indicate that you're already in a pure rendering situation, where the state that's stored in your normalized app database might be sufficient for showing what you need to show. So the UI state machines are actually tuned their finite state machines, but they're tuned to the needs of Velcro. So because folker is a functional system, with immutable data, and the normalized state database, a lot of times you just don't need the UI state machine for things like this, because you have a very clear place to go and just ask, okay, is there a valid user, all right, therefore, I'm gonna do that. So in in a system that were modeled purely with finite state machines, this state of being logged in, would be one of many, many, many states in this, like ever exploding finite state machine diagram. And you'd be tempted to use something like state charts, where state charts is a much more scalable way of doing systems that have large numbers of of behaviors, right? It's kind of a scalable system of state machines. What I found, however, was that because you have this declarative functional system, you don't really need the full power of state charts, I'm sure some applications could benefit from it. But in my experience, the reason I went with writing UI state machines is finite state machines is one, I didn't see an immediate need for state charts in my own work. And to the amount of work to implement the finite state machines, the way I wanted them was much, much less overhead. So you know, someday we might have a contribution library that does full state charts. But for the time being, I think you'll find that these work really well for a whole lot of your cases. And so we're going to go through converting this this session based code into a state machine, because there are some attributes here that that would be nice to have. But I do want to note that I'm not going to model states like, logged in, necessarily, because I have a very clear piece of information already in state that represents that fact.

There's no reason for me to duplicate that in a state machine that's larger than it needs to be. So let's look at what we actually have. We enter the app. And when we enter the app, we need to figure out if there's a current session, so there's sort of a validating session state right I'm when I when I start this load, that's kind of what I'm doing. I'm checking to see you If the state in question is good, and then I'm going to move to a Alright, I've finished checking that. And this, this ready flag really has to do with that. Right? This ready flag is this separate piece of state that I invented, just to track that I'm done with that step. Right. So this is probably going to go away. Right? That's, that's probably something I could track just with a state I'm done checking to see if their sessions good. I also have, if we look at the login component itself, right, so this stuff's kind of spread around and login form. I have a couple of flags here. Am I in an error state? Is the thing busy. And if you go and look at how that's implemented, it's a lot of keeping track of things. And so this is exactly the sort of thing that could be modeled with different states, right? Is is was the login and error. I'm in an error state, right? Am I currently checking their credentials? Okay, I'm in a, I'm in kind of a checking credential state. So So there's some of this stuff that's going to be able to disappear if I were to wrap this in a state machine. But all this other stuff works just just the way it is. And instead of using mutations here, what I'm going to end up using our state machine events. So that's kind of the transform that I'm looking for. The other thing I'd like to get out of this is there may be a case for, say, for example, having more than one kind of login form. And I'm not sure. Ah, yes, actually, for the login form of my statement, if I think about it, when I go to process, a login event, I'm going to need this information passed to me. So I'm going to need a way of passing that sort of data. And there might be cases where I need to explicitly set state on on a given component. Now, here's the cool thing about what we can do with state machines in full grow that you can't really do another systems. And that's that we have normalized state. So any given component in my system has a well known location in the state database. And so what I can do is I can alias component state locations. And, and create a system whereby I don't tie my state machine definitions to the actual component UI, which will let me eventually be able to reuse the state machines. In fact, we do this and some of the larger apps that I work on commercially, will have a single state machine safer handling, Master detail, crud interactions, right forms, where either you're creating something or you're editing an existing one, you're showing a list of them, you're hitting new, it's the same stuff over and over again. But there's different UI components involved, but it's the same state machine, the same state machine structure can handle the idea of was this a new 1am I in the creating state? Is this one that's dirty, you know, am I on the list route, or the Edit route, etc. And so you can create kind of nice blobs of logic that can be carried along and associated with these. So those are the kinds of goals let's start, let's start being abstract on the Start porting this login stuff. So I'm going to have some states around this, this getting started. When I'm showing the login route, I'm going to have some states around, you know, starting, you know, the login process. Whether or not I'm in an error state or busy. And then if I go and actually look at the session implementation, I can see that this login thing, right, if there's an error, I have to remember to set that busy flag to false, right, there's a little bit of bit twiddly stuff here that that will go away. So let's start writing this. So the UI state machines, as you might guess, have their own namespace. And I usually alias that UI, SM just the first, you know, kind of letter of each word of the acronym, UI user interface datasheet. Okay, and there's a macro in here called def state machine. All this macro does is give your your state machine a name.

It's really a map, and it registers it with a global registry of state machines. that's necessary because the state machines themselves do need to refer to lambdas. They need to refer to code so the state machine definition can't be stored in your app state. But the state machine instance can. So as a quick note, if you notice this table right here folklore UI state machines. ASM ID, this is this is an instance of a running state machine for this main router. So just real quick, I could open up this this router, and you can see it says it's currently routed, I can go to different screens, well, we can see, open this up maybe a little more, we can look at the local storage of this state machine and see that, that it's keeping track of where it's at. It has some idea of a bunch of other stuff that we'll talk about as we go. This is a state machine because you can do deferred routing. And there are all sorts of timeouts and things. So I could hit something, but you could be loading things the loading fails. And maybe I want to abort the route, that sort of thing. So So def router in dynamic routers, and full grow actually uses one of these UI state machines to keep track of where it's at, and a state machine diagram. Alright, so we're going to fix our session stuff up. Alright, so the first thing we need to do everything is UI, SM aliased, in this map, and that allows us to later if we want, like make our own extensions, or whatever, and just namespace some deer on space. And, you know, we use this map. So one of the things we're going to find here is the states and there always is an initial state. And then it's got some sub stuff. So let's, let's spell out our various states. So I'm going to have a state and I'm going to namespace the states with the state namespace just to keep track of what's the state and what's not, I initially is hard coded as the place where, you know, this is your entry point to your state machine. So I'm going to have a state of maybe checking session. And that one is going to be used for my initial entry. I think, what to think about this because we wanted, can we kind of wanted our starting up and our actual checking credential can both of those work for while rendering and route? So if I were to say, ready, I'm ready sort of a separate kind of concept, isn't it? It's, it's I finished checking the session. And now I want to show the router. Yeah, that's a little different than I'm on the login screen, and I'm checking whether or not I'm logged in. So I, I do need a separate state for that. So I think we're gonna have a sort of an initial checking session, and then I'm gonna have

a check in credentials. State, and then I'm going to have a state for

Mrs failed or is this error? Is this probably some sort of server failed state, right? I need a separate state for what, what do I do, maybe I'm thinking through this as I go. So initial state is going to take me to this checking session state, checking session state's gonna do whatever it needs to do to do that session check. And then, if it succeeds, I might end up in a state. Again, but we said, that's not necessarily something we need to track as a state, because we'll have the current user that says whether or not it's valid. So So that's sort of a duplication of state. So I have to be careful. And make up my mind, I don't want to I don't want to denormalize my nice normalized database, right. So if I've got a current user down here, that has a valid flag, then I don't necessarily want to duplicate that state by creating a new state in the state machine that stands for the same thing. So maybe I just want an idle state. I have to decide that here in just a second. That that might be sufficient. So my session machine can be checking session. Checking credentials. That's a little confusing. There, there could have actually been a real failure. And I could just be kind of done and waiting for the next command to come in. Okay, and I'm going to actually wrap these all down line. So this data structure doesn't get too terribly wide. Okay, so in my initial state, what you get is one way of of dealing with this is in a given state, you can either specify a handler or a sub map of the various events you expect to receive and what to do with respect to those. In initial, there's just a started event basically. And so typically, what you do in the initial state is just do some kind of initialization sorts of things, and then transition to whatever state makes sense. Now, in a handler, you're in an immutable environment, you're not actually side effecting. And this E and V, this is the UI state machine environment. The UI, SM namespace has a number of functions for manipulating the environment and giving you a new environment. So what this handler is supposed to do is return a new environment. If you don't specify the handler, then of course, it's a no op. And if you return nil, it assumes you didn't want to do anything, it doesn't actually screw the environment. But if you return a map from here, it should be derived from an invention be something where you've called some UI SM functions on it. So that typically, the way you write these is you thread in through UI SM functions. So one of the functions you can use is called activate. And that's just to move you to a new state. Right, so you can see, I'm going to come in here, and I'm going to go to the checking session. And then in the checking session, there are a couple of different events I expect could happen. And I'm going to just namespace these, again, by convention with event just so I can kind of keep the keywords straight. And so when I'm checking the session, I'm probably going to get events like, okay, and error. And in this case on meaning network error here, like the server actually said that you're, you're screwed. There's actually a target state

keyword I can use for that.

That makes it kind of easy to trace through. But I could also just, you know, I could do the same thing that I did up above, and say my handler is a function of in

some kind of just connecting the dots with the events. And so then in my idle state, I might expect an event log in. That's probably the only event I expect from in the idle state. And then in the checking credentials, gonna have kind of the same thing as I had. There, I'm making those two different states because they're kind of two different paths through the state diagram of how I want the application itself to behave. So I'm just kind of trying to track that separate.

That separate thing, I think I'm gonna refactor this checking existing session.

I pre code a login state machine. When did I do that?

Okay, and then delete that. Clearly, I thought about doing this a while back and forgot I did it. Okay.

So I look at, oh, I was trying to refactor this.

And then here for the server failed, I'm probably going to have the same sort of support and the server failed state, you can try to log in. That seems like a reasonable event to accept there. Alright, so if we go and look at the client, the first thing we're gonna want to do is this load, right? So we're gonna want to take that load Out of the main code and moving into here. So in my initial state, I'm going to have a load that takes an end. And so this looks very much like the load you would use outside. But it doesn't want to be tied to a specific class. And so here is where we introduce the actor models.

This is just for my own kind of informational purposes. Ui state machines currently doesn't actually do anything with this, this field, or this this entry, I'm just putting it here to kind of give myself a little bit of reference. So load can take the key or ident. So that's the same as what we had before. But then it can take a component, class or actor name. Now, in this case, this component class is down below me. So I could just move it up and use that. But I can also use is just I can say, actor, user. And now the session machine isn't tied to this particular UI component, I can later tell it that this UI component is currently standing in is that particular actor. And then I don't want post mutations, I'm not actually going to call post mutations here what I want, if you look at UI s and load, it says we can specify UI SM, okay, event or error event, instead.

So you can see I can join this with okay.

Alright, so if that load succeeds, I get the okay event, if the load fails, I get the error event. And so now I've taken this logic that is tied up on my start, and it goes through this mutation here. And, and I've, I've sort of gotten it out of there. I still need to put something here.

Let's gonna start up the state machine and make it work. But I'm not to that just yet. I'm just trying to kind of duplicate the logic for the moment.

Alright, so I'm going to start that I'm going to go to the check, interesting session. If I get an okay event. Well, now I'm ready. I know that it's finished loading.

And I'm in the idle state. And the idle state, of course, accepts login. And, yeah, I think that's reasonable. Okay, so we get an okay, we go to idle. If we press login, we're going to handle our login.

So

I can just make a simple function for that. Since it's the same in both cases, where I get my environment and return some sort of environment.

Okay, so how's this looking?

We need this finish login logic to pick that up. And over here. Right, so there's something we missed, we're not just wanting to go to the state idle, we're actually wanting to, to handle this, this kind of this stuff. So if if login just finished? Well, this is sort of checking existing session.

Right? So if we got an okay event, this is sort of the logic that we want to do, but we can encode it right here.

Now this routing route to is a global mutation, because where we're at in the application is a global piece of information, so I don't really need to deal with in there. And then in terms of getting the current user valid. Now this doesn't really make sense in a reusable sense, because I don't know where that thing, lips, right? I know where it lives in this particular application. But if I were trying to make, say, a library out of the session machine, I couldn't rely on. You know where this, this user actor is going to live in application state. And that's why we have actors. So this is the purpose of the UI SM aliases. So in here, I can say

logged in is the user actors. User valid attribute? Right. So that does that does tie me to the attribute being named something very specifically, but it doesn't tie me to, again, this UI component, and this UI components. identity, it has one, or in this case, it doesn't actually, I'm going to change that. Because with UI state machines, I'd rather just have the item at this point, because I can get to it easily.

Oh, when I messed up my indentation again. Okay, so now, because I've declared that logged in is going to be this attribute on that actor. Now I can use UI SM aliased value on end

and just asked for logged in. So this kind of abstracts away how that particular thing is stored. And in fact, you can do derive state machines. Again, this is just a map. So you can pull this out of this definition, overwrite it with like an association and just change that to be whatever field you want, if you wanted to reuse this, and the field wasn't named that. So we're not logged in route to login. And then this route ready flag I no longer need because the route ready, I'm going to basically handle that by seeing if I'm in this checking initial, you know, checking existing session state. And if I'm in that state, that's that's going to mean I'm not ready. So I no longer need that at all. All right, so I'm going to be checking this, this is going to start that's going to throw me into the checking session checking session. When it gets it's okay event, it's going to check to see if I'm logged in. If I get an error, I'm going to activate the server failed state. And now remember, what I'm going to redo in my UI here is this ready flag is going away.

So I don't have extra state to manipulate. You also notice that down here I've got this show login busy show login error, all that bit, twiddly stuff can go away, because now I've got that representative states and the state machine, which means that the login mutation, which is normally meant mainly just managing those flags, I don't need to manage the flags, I don't need to manage the flags, I don't need to manage the flags. And I do need this returning with with target kind of stuff. But we'll get to that in a second. Oh, actually, my current user is going to cause me a problem. If I normalize it that way, we'll get to that in a minute. I'm not going to need that action. So you can see, I really don't need any local stuff except for this basic route to and detecting whether figuring out whether or not I'm logged in. When when logging completes, everything else kind of goes away. And I am going to do a remote mutation of login. But the local stuff is kind of disappearing. So let's code that into our login handler. So handle login. Let's just take this up here. So handle login. Hold on handle login is starting the login process. And then once we're done, the user that we've got an app state will be kind of whether or not we are logged in.

may want to give instead of normalizing this that way,

I just want to do that will normalize this, but will normalize it into a well known location.

Okay, and right now this is complaining because actions can be empty.

Alright, so all login really needs to do when it's trying to be handled is really hit a remote. So UI SM comes with trigger remote mutation, where you given an input and act actor that's currently on screen. So we're going to assume that for handling login, there must be a login form on the screen the mutation so we want to invoke the remote login in this namespace app model session login. And then the additional mutation parameters, so login options and parameters. Alright, so this has some UI, sm namespaced things for targeting things. So like, for example, target a specific actor. And I can specify should be able to specify returning Yeah, returning Do you have to be careful to look at what namespace these keys are in.

Now, the in this case, I do need to know the class of the actor I'm interested in.

And then we were targeting session current user, we should probably continue to do that. So that's going to be Thank you, we can just do plain old target. primers patch mutation map also include additional state machine options.

Right? Here it is. So in this case, I want to an explicit target, I don't want to base it on any sort of alias. And so I'm going to use session current user.

And then I'm going to whoops, I'm going to thread that this mutation won't trigger until I'm done handling this particular event. And this thing, and I think in all of these cases, oh, the remote mutation, I'm going to want to okay event, same as before and an error event.

And then I think

I'm going to go to the checking credential stick.

Alright, so you can see we've kind of compressed all of this logic, wrapped this guy down so we can actually see the, the parameters. We've compressed this logic for all of this like general handling of the session into a nice compact form where we can kind of follow along with how it's supposed to work.

Now, there are a few things we need to set up to. To get this working. Oh, we also need log out. So if I'm idle, there is actually another event I could get That's a log out of it. And I guess we have a logout mutation here somewhere that routes the login screen and clears clears some stuff and it is a remote mutation. So we'll see now vlj credentials. Really the only place logout should probably happen.

Okay, so log out, see how we handle everything with login? Oh, there's this route to on the okay.

I think this is identical to this so much just

could just pull these up.

Oh, and now that I'm looking at that.

Okay, yeah, so initial, you can have a handler or events, most things are going to have events. And then if we have any sort of duplication, this is just normal immutable data structure stuff. So we can factor it apart. And, you know, make make functions that can be reused, right handle log in as used in two places, session revolt result events used in two places. And I'm just using these to get some additional states because my UI kind of needs to rely on which of these states I'm in to be able to, to render correctly. Okay, so let's talk about starting this thing up. So I'm not sure I've got it all right. But this is some some. Alright, we were working on logout. Sorry, we don't have it. All right, because we haven't finished logout. So login, we got our Okay, event does our route error rate goes to failed. So okay, goes to route. So logins done, we can get rid of that. And log out routes to log in. And this is this is kind of a full stack thing. And I no longer need log out to be declared here. We're gonna fix that in a minute.

Okay, so this is the basic logic we're trying to duplicate here. So I'm going to thread through and Alright, so the first thing I need to do is this kind of global routing thing no matter what, so I'm just going to do that because that's a global side effecting thing.

And then this is UI SM apply. So apply action on an end is sort of like swap against state. So apply action takes a function of state, some sort of mutation helper, and, you know, pass a state to it. So I've got swapped state. So basically everything from here on

we'll work on change there. Then the other thing I need to do

after mutation and the params. So log out on this guy just had remote true, it was just like, I've got no parameters, and I just send log out. So that's really all I have to do. So that should be equivalent to the mutation I had before. Of course, this is not going to become. So trigger takes a state machine ID. And so in here, I'm going to use App model session. So as the namespace

This is just an ID, I'm going to use for the instance of the state machine I'm running, you can run more than 100 takes the idea of a state machine, and event and then an optional event data. So the event that I want here is about logout. And change route here. I think I'm okay with I don't think that that's going to hurt anything.

Okay, so I still have session over here as a namespace. And so now in the password field, this is now going to be UI SM trigger.

Is that what I call it? Yeah. So I'm gonna, I'm gonna give this guy the idea of sessions, I'm not sure if that's the best name for the state machine, but trigger that, on that, and I want an event. Log In this case, I need these parameters. So I didn't mess something up. So over here on Event Log in handling, I need to pass these to the remote mutation. And same thing here, this is going to be a login URL, this is just the exact same.

There's login. And then we're gonna need to fix up the UI. So it uses the state machine status. Okay, so I'll let me go fix that problem that I said we have. So on login, we get parameters. So this end comes with

event data under the UI SM key. So when I get this, or this is not logging,

I get this environment, I've got this event data. And in this particular case, part of the reason why these have these namespaces on them, is anything that's not one of these well known namespaced keywords, will will be included as the remote mutations, parameters. So I can, I can just carry those along in the same map. And these kind of extension, keywords that are local to targeting and returning and UI SM event handling all get stripped out. But anything that I pass in this map that isn't known to UI SM or its sub facilities will end up being passed to the remote mutation. Alright, so that that ties in those pieces. Okay, so this is just a definition, it's literally a map that describes the structure of the state machine. And when we're running it, we actually need an instance in memory. And you can have as many instances of a given definition as you want all in their own new private current state with their own private data. And so that's what these IDs are about. So routers use their fully qualified class name as their ID. And in our case, we've used this colon colon session in the session namespaces the ID. Now to get one running, you have to actually call begin on it. Alright, so we don't need that anymore. Okay, so begin takes UI or app component, the machine definition, you want to use the instance ID you want to use, and then actors that you want to the real UI components that you want to use as the actors in the machine, we're gonna pass the app, we're going to pass the session machines definition. The ID we want to use for this guy, and then the actors. So now you have to go look at the at the definition of the machine. And remember, okay, we've got two actors, user and login form. So the actor, user is going to be that session, current user class, and the login form is going to be our login form from this namespace. Now, if these have stable identities, in other words, they only exist in one place in app state, you can just use the class, which is why I wanted this guy to have a single, stable ident. If you don't have a single stable ident, then you have to, you have to actually use UI SM with actor class and an ident. That that says where that that thing's going to currently live. And so that's why I didn't want it to be based on user ID, that would be a little bit finagle, you'd have to remap the actor during login. And so I didn't want to have to do that. So I gave current user a stable ID, because it's just a one well known thing. Okay, so let's see how far we are. I mean, this isn't gonna work completely yet. Oh, and we don't need finished log in anymore. Since he, we've cleaned up quite a bit of, of code here, we're not going to need the ready. Well, I don't want to leave the test mark, because we've not done the replacement yet. And then this current user, that can normalize now, and that's not gonna hurt anything, right? Let's just load it up and see what happens in state, I could care less about what's happening on the UI. Alright, so we start we should see ASM ID now has two machines in it. Here's our sessions machine. And our session machine is in the initial state. So something didn't happen the way we we'd hoped. Looks like it didn't actually trigger the remote. But it did get started it went to initial there no active timers, it figured out that the login form is there, and that the user is there. And then we gave no initial state for or we did session, current user. Oh, we didn't. But I think current user has initial state.

I just want to make sure something's there in state for for that at load.

Okay, so now I've got session current user, which normalized into the session namespace current user. Which says it's currently nobody and false. Okay. So that's all good. Okay.

All right. Our initial state initial state, I think that's probably the problem.

Checking existing session, if we look at our network, it tried loading this guy, this guy did load. It got FUBAR true and then it stopped. Okay, so why did it stop? So went here? it loaded? Got to know. Did he get an O USM.

So be careful about those namespaces they'll get you Alright, so Reload. Look at the state machine. We're in checking existing session still. And it's useful registering a board ID, it's useful to turn on debug logging here because it will tell you what the state machines doing. So was loading this doing merge post mutation to your state machine event? trigger event, okay. On sessions within there was just no event data. So it did hit event, okay. This guy, and we're in which data we on? Checking existing session, session result events event? Okay. handler did a route Oh, but we didn't activate our next state.

We go into the idle state.

Okay, so we ended up in state idle. Our session has our current user in it, who's, who's All good? And let's see, no, I don't think we I don't think do we model logout button yet? Oh, that's in the Yeah, that's shouldn't be in here. Where did we put the logout button? It's in like, Oh, it's in the session. current user. Oh, we did. Alright, so let's trigger log out. That takes us to state idle. The session did not change. Oh, but we did it up here. So that sort of messed with us a little bit. Alright. So we just did that. Right. So I changed how this worked. So session, this isn't where we put it anymore. This is going to be associate in at we in the session namespace? Yeah. session question.

All right. And I'm sort of stuck now because I don't have any, any UI working. Because I'm not re refix the IDs, but an argument to idle current user, and the current user

is invalid. Okay. So that's kind of what I expect. Okay, so now we can fix up the UI with these various flags. So what does it mean, for this application to be ready? Now, when you place actors in the in the system, it does queue refreshes, well, depends on what rendering with use with it an optimized render, as long as it can figure out the dependent data, stuff, as long as it's direct data dependencies, you'll get a refresh. So so what we're gonna do here, is we're going to make an ident based query here, and we're gonna say I want UI, SM ASM hyphen ID, because that's the name of this table that these state machines go in. And then I'm going to use that sessions.

Machine name. So this is saying I basically want to query the database for the status of that state machine. So I can just pull it in. And as long as I've pulled it in, actually, do I want to do that one or the table? Oh, you know what? It doesn't matter. I think it doesn't matter.

We can just pull the old table in.

Right? So that that gives route a data dependency on, you know, state machines changing in general. And actually, since I've stuck this in route, maybe I do want to query for just just that one. And then I'm using this now. I'm going to refresh my memory on how get active state works. Yeah, it pulls current state. So it doesn't matter how, how I query for it as long as I make a dependency. So I don't want root refreshing the app, unless the state of the state machine actually changes. I don't want the whole table, I want just that particular state machine state. And then I can use this and this will give me back one of those, you know, is it state whatever? Right. So as I, as I render here, I see I'm in state idle. Okay, so when am I ready? I'm ready. As far as this state machine goes, as soon as I'm not in the initial, or the checking existing session states. Right. So those are the ones that I don't want to find. So I'm ready. Right, it's nine, get rid of these guys.

So I'm back to my declarative UI. And I've got my login form. And in terms of logged in, I need to make sure my current user query is going to work right. Yep, that should be right. And that's why that was working before I didn't really change how that worked. As you see, now this is become quite declarative in terms of not having to keep this extra piece of state around to figure out if I want to show the UI yet. Try the logging mutation. Alright, so it wasn't happy about triggering event, login, user email, user password, did we actually get a network attempt? We did not. Okay, so screwed something up with respect to that. Okay, so if I'm in the idle state, which I know that's where I was, and I click on login, and then I go to handle login, I can see the active class, remote mutation, failure dispatching. session, current user is not Oh, target. Target has to be a vector. So just this this arrow right here, as well as looking at anytime you see not ic keable, it means you were supposed to pass something like a vector or a list or something, some sort of sequence. And you didn't. And, obviously, session current user isn't one. So that that reminded me that targets are always a path, and pads or vectors. Right. So I didn't get any updates on this UI forum. But you notice I'm now logged in. So I've got, you know, the ability to route now. And the system log out thinking back to the login form. And so I would like some some feedback, and, and such. And I need to refresh the UI with respect to these menus, because these menus shouldn't be showing if I'm not logged in. That was an another. Oh, but wait, if I change the DB correctly, at model, current session user valid false, that should have

hidden the menu.

Can I diagnose that separately? I'll go ahead and throw a login for it. But the login form over here in session, yeah, let's I thought it was a refresh issue, because it's considering it. Is it considering it derived data session current user?

Yeah, that's just a missed refreshes. All that was we'll figure out that in a second. So our login form is here. And so now we no longer need error, we're busy. We've already determined that that's, that's no longer stuff we have to track it's part of the state. And now we can derive them from the state machine. But we have the same problem as for the same same thing going on here is we had n root. We need to make sure we query for

the state machine in question. I'm going to go ahead and just pull the table in

outright busy isn't defined

in our initial state No, our needs these two, and that should clean it up. Okay, so same sort of exercise.

All right, so when are we busy? We're busy. This case, when we are checking credentials,

and we're in an error state, when we are in the state server failed, or the valid the user is not valid.

Oh, is that actually an error state? So we missed a piece here. Right? The there's the case of we got an okay response. But the credentials were bad. And therefore, we want to show them invalid credentials. And then there's also the case of the server just barfed. And that's an actual error. And so we might need to expand out our state machine definition just to encompass those possible results. Because idle, right, we could have gotten to idle from this checking existing session. In which case, the login form might not be on the screen. And if we go to the login form, we don't want to telling us our credentials are invalid. Ah, there's another thing we could do is we could change this, this, this state itself to be a better representation of what went wrong on the server. Because if we go to trigger this thing, and it fails, that would be something we could actually store. Or we could just actually store a different piece of information. So if the server actually failed, there was a network error. So that's, that's one thing. But in login, if we go to handle the login, and we got an OK event, then we could actually set an additional flag here to indicate that the credentials were invalid, right? So the server responded, okay. But we can look at the state and see that oh, well, we responded, okay, but there seems to be an issue.

So here, we can just add to our state machine, another alias. And when I just call it bad credentials, is the actor user UI slash

credentials. So then over here on Oh, wait, I want that to be on the login form.

Right. So I could add

etc. So I'll clean this codal up a little bit before I check it in for the video but you get the basic idea of, of how to work with the UI state machines and where they can can help you take logic that's kind of spread out and has a bunch of little fiddly pieces and and concentrated into this concept of, of a finite state machine that can control the individual kind of like where am I tracking of a particular you know, collaboration among components.

