So now that we've gotten through the basics of how react works, and it looks like everything is all rosy, and we can just render frame to frame to frame and have the browser look just like we want, we get to the first fly in the ointment, which you reach very quickly inputs. And we're going to talk about why that's a fly in the ointment in this video, along with some of the things you end up having to do about it. So I've got a new project set up essentially identical to the one in the last video, so you can go review there. And I wrapped up JavaScript requestAnimationFrame, and a little Aria function to so I can type it quickly. I've still got the mount point, I've renamed this mount point, looking at in my index file here, when I load my index HTML, I've got a div with an app ID, I'm loading my main JavaScript, I'm also pulling in semantic UI, CSS, just to make it easy to make something look reasonably good in my in my demo here, and then I've also still got my render function where I'm just calling plain react Dom render on an element at my fixed mount known mount point. And I'm going to play with simulating kind of the way Volker works. And for that matter, a lot of the other libraries that wrap react, how they have to work and what they have to do, just to give you an idea of how this how this whole thing puts together, so the very simplified view here. So I'm going to make an atom that has a closure script map in it, that has my first name in it. And I'm going to do a diff once on that. So hot code reload doesn't cause this to get reset every time hot code reload happened. So def once is basically just a depth, but it checks to see if the things already depth and if it is, it doesn't do it. So that's nice. I'm going to make a function on calling UI form that just has. And remember, we saw in the last video, these are just folk rose, macro macros slash functions that emit the most efficient form of create element they can. And there's this nice little shorthand for adding in classes to the thing. So I'm going to put a UI container class, which causes semantic UI to make wide things not look so wide. I'm going to wrap a little form here and put a header on it, put a field and then a field label. And here you see I'm doing something a little different. Instead of using the raw and not the raw, the full curl function for input, I'm just using a full CRO create element, which just is the raw react create element to make my input. I'm doing that because fulcrums input in the DOM namespace is special. And it's special for reason you're about to understand. So let's take a look at what happens here. So I've coded a few other things, very simple things, I made a UI route that now takes props, where I'm going to call this form and pass it, its props. So the UI form takes props, and it expects to get a first name. So the first thing you'll notice is I'm not having this form, reach into this top level app state because I want to be able to kind of move forms around so on and so forth. reconstructing so I don't want to tie my UI shape to my database data shape, necessarily. I mean, you can but it's a nightmare to maintain such an app. It's why folker has normalized databases for that sort of thing. It's It's insane to manually maintain the shape of that and morphin every time you decide to refactor part of your UI. Okay, so if we get the started up, if we go here and go to the bills, start to build. And then we can go to localhost dev server, we can load this HTML, which of course, meant to sort of do a side by side thing here, seeing here and see if I can get away with it. Alright, so we've got our build going, we've got our little form, we can still go down here and say, okay, render our oops, I don't have a repple going, haha. So we're going to create a remote repple we're going to hook it up to localhost 9000, just like we did before, and that's just a well known port that hooks us to our compiler. I'm going to run that. And then we're going to tell the shadow clgs system that we'd like a repple for our app, it's going to say, okay, you're in clgs, you're running there. And now I can render. And it tells us No. And that's probably because we haven't loaded this with Shadow DOM yet. There we go. Liked it that time. It didn't render. To open our console. Make sure we don't have steal stuff that was in the cache, always a good idea to have your dev tools open.

With cache disabled. When you're, when your dev tools are open that we could steal files from the last time you were developing something different. Okay, so we've got that rendering. But of course, now if I change this, and I save it, I get the hot code reload, which is updated my code, but my UI is not going to change until I go down here and render it again. Well, that's kind of annoying, what I'd like to have is a render loop. So we can make a really, really simple and that's why I have requestAnimationFrame. setting here and on our f function, we can say when I call start requesting animation frame that calls this function, which has the name next frame star, render the UI route, and then request another animation frame, and run next frame. So it sort of looks like a recursive call. But it's actually like we drop off the bottom was function, then 16 milliseconds later. So because this, this guy runs at roughly a 60 frame per second timing rate. And so that'll cause my application just to rerender, basically, 60 times a second. So go down here, I'm gonna see start, you notice the UI immediately updated. But now if I go and tinker with my form it on hot code reload, it immediately updates so great. And I'm not sure what's happening my CPU because it was doing this is mental CPU meter, it was doing that before. Oh, the screen capture, the screen captures eating most of the CPU. So when you see that going there, that's not actually the browser eating up much CPU because the 60 frames a second, right, one of the powers of react as it can look to see, oh, nothing's changed, I don't have to do anything. So it does very little work on these, these frames. This is not by the way, how full grow does animation frames. But this is just, again, really simple emulation of how you get a react application that can react to data. So got my raw, plain gene input here, the value is coming from the props first name, notice that the closure script map and I'm D structuring it. And my render loop here is using this atom to supply that. So that means if I go down here and change first name to Bob, in the state, you see the input change. Alright, great. So now I have a global way to have some sort of external mutation of my application state and have that affect the UI, that doesn't necessarily have to be tied to the locale of that operator. So for example, I could have, you know, a reset button or something in a different component that knows I want to clear a form and it can go through and clear the state, and the form would just update. So that is the kind of thing that you want. Now, of course, you also want to grab the on input or on change events here. And actually, let me show you something else. First, let me comment out those those forms. So I'm not changing. First name at all. If you go over here to the form, and I try to type, maybe you can hear me typing, nothing happens. How does react to that? And what is an input in a browser? So that these are the questions that I really want you to think about when you're thinking about how react works. And what's something like folk or any other library that wraps react has to deal with, with respect to this particular concern. And that's that this input is generated by the browser, in this case, Chrome. And it supports all sorts of things. It supports figuring out how to render your font, it keeps track of event handlers. And it's got its own mutable state. So when you set a value on an input, you're actually putting a value into a mutable cell. And normally, when you type, the browser is updating that mutable thing for you. Right, you can ask for the value at any given time, and it's just there. You don't have to put it there, the users putting it there. You also have support for things like internationalization, where there's like input methods on the operating system, and etc, etc. So there's a lot of low level C or c++ or some lower level language probably, that the browser was written in. And it really owns that that input and that input is a beautiful thing. So the fact that when I try to type into this input, and react is trying to make it look like I get to render exactly what's there are exactly what's in my state. And that's all that will ever render there. That's actually a bit of an illusion. So to show you that I'm going to, I'm going to reload the page to stop my render loop because my render loop would interfere with the example that I'm trying to show you I'm going to render things once

Right, read only feel that's exactly what I want. Okay, so now I've only rendered once I don't have my render route running. And you can see, I'm gonna go up here and try to type, right. I can even highlight things and hit backspace like it doesn't change. But my thing is not rendering and I'm running and I'm not asking react to render anything. So what the heck's going on? Right? How is that? How's that thing that feel that's owned by the browser and is actually a mutable thing, not updating when I bang on it? And the answer is, of course, the elements. Look at the input. could have done this much quicker just by saying it's back. And then go look at the event listeners, it turns out that react has glommed on to a bunch of these things. In fact, it gloms onto all of them, right? And this input one, these these handlers here, if I delete them from input, well, now I can type now. So the the answer to the question is, react, puts its own event handlers on everything captures the events, and then prevents the change from happening. So that's how it gives you the illusion that you're in control of the value of the field, the place this illusion breaks down, I'm gonna reload this. So I haven't screwed over react state, that I should leave that open, just so I don't get weird caching. Where the illusion breaks down, is when you start modifying these form fields. So let me start my render loop again, look at my form going. And I'll put in my on change handler here. And now you can see what I'm doing is I'm looking at the target value of the event. Now this is a low level JavaScript object. So this is just a little wrapper function that says, you know, get the target value, kind of silly. But it keeps it from showing up as a as a warning like these do, right, because it doesn't know, the ID doesn't know all of the possible things you can call in JavaScript. So it's just saying, I don't know is that really something you can call. So that's the only reason I use that here. And then I'm just going to swap on this state atom and say, a so so new value onto the first name key, and make it the string that came out of that, that event. Alright, so now, I should be able to start putting new values into this input. Alright, great. Now the problem comes in when I try to go to the middle here, and I'm going to press the letter H. Notice where my cursor went to, it jumped to the end. This is a rather rather annoying feature, so to speak, of react for developers of libraries that try to do what things like full crud does. And that's because the input is a mutable thing. And because the change to the state happened in an asynchronous event, that didn't show up until the next animation frame, so let's, let's think about that, right, so so maybe write up a sequence of events here. So one, the event happens to them event handler, updates the atom three, some time later. You ask for a render, and pass the new props. And for react, sees you've changed value and tells input its new value. Alright, well, that's kind of what you expected, right? That's sort of the sequence of events. The problem is, some time has passed. And whenever an input in a browser, which the browser owns, when it sees you setting a new value, it thinks, oh, you're setting a brand new whole entire value for the user to see it doesn't do some micro comparison to see that you've just changed the middle of it. It assumes the values are entirely brand new. And that was due to some other action that happened in the world that your your user understands, say, for example, you know, a server push, maybe you're doing collaborative editing, whatever. And it jumps the focus to the end of that thing that just appeared. And so this is quite annoying. People are trying to go and fix the middle of their thing and their cursor keeps jumping, they can backspace without the cursor jumping to the end. So how does react fix this? How does react make this better? And the answer is they use component local state. That's the standard answer for how you fix

this particular unfortunate problem. That really is This, this might like mismatch between the mutable world of the browser input. And what we're trying to pretend is, I'm in control of exactly what the browser renders. Like those two things just in this particular case, they don't pan out. So let's let's talk about reacts, trick for doing this. So I'm going to do this via hooks. Because folkers component system actually adds in a bunch of extra things to the two components, I'm just going to use raw low level react hooks here. So react hooks let you define a component, like a true react component that can interact with the React API's as a plain function, but that function is going to receive JavaScript props. So I'm not going to get my lovely closure script thing there. But I would like to have it. So I'm gonna make a lead. And I'm going to paste that back in. And I'm going to say, you know what, I'm going to put on my, my props, let's call it some dotdash. My props on the J s props. Alright, so I'm using field access, interrupt, I'm going to put my my closure script data structure in inside of this sub element. So I can pass them into D structuring them, okay, that'll make my life a little nicer. And I need now this UI root in order to render the UI form, this can't be UI form anymore. This needs to be the actual component. So that's my, my UI class, so to speak. And then I need a factory, which can react UI form, takes the J s, props. And we're going to call it DOM, create element. So we already seen that just right, that's just react create element. And this guy takes the thing that you want to render, in this case, we want to render form, and then the GS perhaps you know what, let's make that nicer. Let's take the, let's go ahead and just let this be the interfacing layer. So we'll take closure script properties. And what we'll do is we'll we'll make a JavaScript object and go ahead and put our my props in. Okay, again, we're using a low level JavaScript API. So we have to sort of play with the interrupt to get things to play nice. Okay, so now UI route gets closure script, props, UI form, gets closure, script props, and then this guy is our factory that manufactures an element of type form with these props. Okay, so that should think still work. What did I forget here got in for target type of change. We'll just say that for now, that'll get rid of the warning.

Okay, so this should still mess up, but should still be, you know, working with the end. Okay, now, what we can do is I've pulled in this hooks namespace because the hooks API has this lovely thing called. Or it has this way of using component local state. So the current name and set name gets hooks slash use state. First Name, let the first name from the property, the initial value of the component local state. And I'm literally just using the React hooks API here, low level JavaScript, this function in hooks, calls use state and all it does is make it so that the return value of that which comes back as a JavaScript array turns into a closure script array. So I can D structure it nicely. So it's a very thinly so if you want to see how hooks work, go read the docs, but I'm about to show you. Okay, so what this returns is the current value of that state, which we've initialized the first name, and a function that lets you update it. So now instead of this, just the swap will say set name to the new value. And here's the trick. When you tell react, that thing has changed via component, local state, and it sees that thing you know being used, we're going to use current name right here.

It knows what's happening, it can track what's happening. And so then when a value shows up, that's the same that it's already put in there via component local state, it does nothing. So it assumes that you're in the situation of, there's a rendering loop going on. And you've already set component local state value to that. And I can fix that for yours. let's reload here. So I know I'm in a known good state. Let's start our render loop. And now I should be able to put my name in here, go back and put stuff in the middle and everything's working wonderfully. We think, here's your next problem. What if you want to update the name now to Bob? Well, I just evaluated that. I can go and look at app state. And I can see app state as an atom that has Bob in it, but my UI did not update heavily. So the fix which fixes the form behavior, now breaks the other behavior I want. And that's that I want to be able to globally change my application state and have my rendering be a real representation of that. So this is kind of a painful problem. Either you go to the mutable world where you have to, like ask this form for you know, pass it a callback and have that callback, tell you what the new value is, and do a bunch of like conditional logic, figuring out how the app state should update. yada, yada, yada, right? I could put an if statement in here that says, Oh, well, if you know, on component, right, I don't have lifecycle methods here. But I can use effects in hooks, to do a little, you know, glamour, playing, where I can try to figure out alright, does this value match the value that's already in current name, if not, then it probably changed. And then, but there's a whole lot of it's really hard, it's hard to get this right. If you really want this like global thing, controlling an input, by definition, you have to use component local state. But the logic around writing something that works in all of these cases, is it's Trust me, it's it's a nightmare, it took days of development work based on somebody else's development work based on somebody else's work, to get something that worked well with Velcro. infocomm actually has now has a synchronous transaction mechanism that works like component local state, but doesn't have to use it. And and that gives you this the same effect without having to use component local state. But it was, again, a lot of work to get that working. So I hope you kind of appreciate now, when you say, Dom input, and you get to use these nice little properties, and you get to actually change some global atom, this input is actually and regular mode, a wrapped input, which is a wrap form element around an input, which, on the fly, generates an instance of a new component with various lifecycle methods in order to wrap your component in such a way that it does all the comparisons and state management, etc, so that your input works, right. And this is the same sort of thing that you need. And in fact, this is a public function, because when you use the React ecosystem, right, you go grab some custom thing that acts like an input, like react a number format. Right, this guy this guy has, is a very useful one that I use in some projects, and let you do you know, a whole bunch of settings on on forums to get really nice, you know, formatted numbers, well, this guy acts the same way and expects you to be using component local state. And so you can actually use this react wrapper that I've built enfagrow dom to make these behave properly when using state. So that's the trouble with inputs. Let's go ahead and see, hopefully, he says, having not tested this particular method of doing things, let's reload this, having tested it in this like weird little simple render loop that we're playing with here. So let's start our render loop. Notice we don't have like you just get rid of this component, local state mess. Like and put back our first name. Lovely, hot code reload, our UI should be able to put our things in here and we should now

Be able to edit in the middle without problems. And our state, of course, should be updated. And if we change this to Bob, it immediately changes. So there's a decent amount of magic and the moral of the story going on behind Dom input. And this is also the kind of magic that you need to know about if you're going to use the React ecosystem, to supply any sort of inputs. So for example, I use semantic UI react, because I use semantic UI in a lot of my projects. And the semantic UI, UI react controls, again, their form, form based controls, do the same thing. They expect you to use component local state, because that is the official way from react, to deal with form elements. But it's also a very painful mutable time tying your state to a component where it's hard to get to sort of way to do it that requires you to then couple things tightly and you know, all the different reasons why you might look at a system like Volker that has a normalized database where you can think about your data model separately from your rendering model. And the render model can just be a pure expression of your state. So this is another reason why, you know, I say folk row is one of the it's one of the only, it's in fact, the only library I know that does react rendering. That's, that's quite so literal on the the state is what gets rendered, right, you can use component local state, right? And you can, you can, in fact, there are places where I do use component local state, and that breaks that model. But for the most part, your entire application is meant to be this expression of a snapshot of an immutable data structure that represents what you want to render, in the state atom. And these are just the details of how it should look

