0:01  
In this video, we're going to be talking about getting your full core app working with a server. So we're going to start first with modifying our depths. So we've got our application running, basically, you know, at the end of the last video, it's doing what was there. And I'm going to go through, adding some things and changing things to get us ready for full stack. So the first thing I need to do is add a few things. So if you remember, when we're running shadow clgs, it starts a development server, I've told it to start on port 8000. And it will serve things for us there so we can do our development. And when I start to run a server myself, in order to serve the HTML, and then API requests, I want to serve the same Resources folder. So I wanna make sure that resources is one of my paths. And typically, those resources also need to be deployed with your application. So having this beyond the class path, when you use something like Deathstar, something to generate an Uber jar is a good idea. And then we need a few things to provide the server side of things. So we're going to use ring, I'm just going to grab the latest version of ring core will use HTTP kit for the web server implementation, we're going to use path home to provide the query processing mechanics for the back end. This basically lets you adapt any kind of database technology or just straight maps or whatever you have on your server to a query parsing engine. And then think oh, and then we're going to add these extra pads in dev mode. To add a dev namespace, we have a place where we can start and stop our web server, you know, just some helper functions that don't necessarily need to be in production, they wouldn't actually be built into the resulting, you know, final thing that we'd maybe deploy to AWS or whatever. So we're gonna, we're going to add those. So by adding these extra paths, resources that have these dependencies, the depths tab over here, I can I can do my refresh. And make sure that that everything well make sure dev is checked. First of all, or this or this dev path one and upon there. And then I'm gonna make a top level directory called dev with username, namespace user, I think we already had resources public index, that's the same index file that you saw before. Nothing different there. I am going to add semantic UI semantic CSS. So we did that in the last video. Sorry, I think we already know, we already were already rendering that. I did add that to the HTML just so we'd have a little prettier UI experience while we're working more for aesthetics than anything else. And to demonstrate how you use classes easily with the DOM. So let's just jump right into how to build the server. So you'll see that the server code is really pretty tight, it's less than 35 lines of code. And actually, the server itself, the middleware is lines 27 to 34. That's, that's really all you need for the server processing. But then you need something to parse the queries. And so that's where this, this path home parser comes in. And so I'm going to leave this like setup to you reading the documentation of path home, this is a decent start to setting up a path home parser. And it's going to give us all the functionality we need for these demos. But it's it's quite a detailed involved, feature rich library, that makes our lives much easier when processing AQL. You know, the even query language that Falco uses for its queries. Okay, so most of these things are ring things wrapped, not modified wrapped content type wrap resources, the thing that that goes looking on the classpath for this folder, and then will serve anything out of it. So resources happens to be on the classpath. That's what the blue means. And that's over here in depths, what pads and extra pads mean, it means add these pads to my class path. That's that's what depths is about. It's about building a class path for the Java JVM. So that gets me my basic service. And of course, since this is ring, you thread it top down, but it runs bottom up. So requests are going to come in, they're going to hit hit these things, slowly move through adding features. And then if something decides to satisfy the request, like wrap resource, it can it can do the response right there and short circuit the rest of the chain. Wrap API is a function to find in full chros API middleware namespace. And also, there's a convenience not found handler there. That's just really trivially a trivial 404 invalid request kind of thing for convenience. But you can use your own you know additions to the chain. The rap API does need you to

use the the these fulcrum, middleware, transit params and response pieces that the do the transit on the wire encoding and decoding for today. To the client, using the extensible transit protocol. So essentially eating on the wire transit itself encodes eaten as a D duped, JSON. So it's actually meant to be, you know, super fast in terms of CPU processing, etc. So that's all you have to set up for the server. Again, this code into checked into GitHub, so you can take a look at that, after you've watched the video while you're watching the video. Okay, so now we've got our server setup there, we need to add a build configuration up here for closure, so I'm going to add a local closure repple this time, so this is going to ask me various questions here. And really, I don't need to change anything in rebels. Fine, we'll call it clj. Make sure the module says the module, you know, sometimes this doesn't get selected, if you got some, typically it does. So probably not a problem, shouldn't need anything else. You can apply that, okay, it hit go. And assuming you've got the right closure depth selected here, assuming the dev is selected, that's really important. Otherwise, your user namespace won't be on the classpath. And you won't be able to get to this stuff, then we'll be able to go talk about what's over here. Okay, so it started, I'm going to tell it to load this namespace. And I'm going to show you my key map here real quick.

There we go. So I'm just gonna go to their clear that, and then open those. So I've got a keyboard structure, corporate, I set mine to Ctrl C Ctrl. l, that means load the file, I'm on into the rebel, these default to something, but you should probably have at least that one and the one that tells it to switch the repple to the current namespace, I use Ctrl C Ctrl. N for that. So that's essentially what I'm doing here is I'm, I'm, well, I don't have to do the Ctrl C Ctrl. N because the repple starts in the user namespace. So it's already going to be here. But Ctrl C Ctrl. l, well, you can see it loads the namespace there. And then I've actually gone in, if you do that, you know, find action in the IE command, shift a and add repple command, you can actually add, you know, some new command to to run in the repple that you can then tie to a keyboard shortcut. And I've already got several added. So instead, I'm going to go to Edit repple commands, and you're going to see I've got one called restart user namespace. And so I just label it that I tell it to execute the function restart, and then execute that in the user namespace. So it's as simple as that. And then back in the settings, I've been hitting the keyboard shortcut for this command, comma, I'm going to the key map. And I can actually look for these rebel commands. You can see I've got this one for restart user namespace tied to Ctrl, C Ctrl, g for like, go make the thing go. So you'll see, see me occasionally restarting things. And basically, I'm just hitting that keyboard shortcut, you'll see restart appear down here, along with the, you know, I'm reloading code, etc. So let's talk about how that works. So the HTTP kit server gives you a run server command, you give it the middleware, which we were just looking at just that stack of ring middleware functions. And at least the port you want to run on. So I'm going to choose 3000, the log a message, and then I'm going to place in this atom, whatever that returns because this returns a function that can stop the server. So when you listen on an HTTP port, or TCP port in general, and a process that's a, that's a operating system level resource, you have to be careful not to leave that thing allocated. So when you go to reload code in the JVM, you can reload the code. But if you lose access to that operating system resource, you'll have to completely quit your repple and restart it to let go of that operating resource operating system resource. So what we want to do is set up a sequence here, this is like the your watch tours here is component reloaded. One of his talks about that, essentially that you want to make sure that anything that's stateful in your server is cleanly shut down and started up. Now we're not going to use component. These days, I tend to use Mt. But either way, you're having something that can manage your stateful resources is a great idea. All we've got an HTTP server, so it's pretty easy just to manage an atom. So that's what we're gonna do. We're gonna throw in an atom. And really all we're gonna store there is the stop function. And then for restart, let's look at stop stops. Gonna check to make sure it's started. And if it is started, it's going to call, right it's reading the function out of the atom and then calling it to make sure it stopped. And then we've also added another thing to depths that I forgot to mention. And that's this tools namespace library. This library has the code, you need to unload namespaces when you refresh them, which is sometimes necessary for for clean, full, like refresh of the code in your repple. And so that's, that's why that DEP is there. And we've required it here. Two steps here, you need to make sure you do one is this one's pretty important set your refreshers to just the directories you want. Reload to check. Typically, you do not want this checking resources, which it will by default, because it's on the classpath. And you typically don't want it checking, you know, other things that that it might, you know, it might find on the class path for, for potential refreshed. So this is important because the closure script compiler ation phase can put out files that look like files that it might want to use. And so if you have the refresh, stirs unset, it might find things and refresh them and bring them in that just confuse things like crazy. So make sure you set these, or you'll you'll have a really bad time.

So now all we have to do is after we've stopped everything and made sure we've let go the OS resources, we can call refresh. And then we tell it after it unloads and loads all the namespaces go and run this function, which happens to be here. But the reason you give it a symbol, a fully qualified coded symbol is that as it during this refresh, it will actually unload the user namespace and recreate a VAR. And so if we had handed start here as the value of a bar, who would be the old start, it wouldn't be the new start. And so if we had, for example, change the port or whatever, it would get the old start. And the old start might be tied to old state, etc, etc. So that's why it takes a symbol. So this is very boilerplate. If you've started with the fulcrum template, all this stuff's kind of already set out for you. But since we're kind of coding this from hand and seeing kind of the bare minimum, this is this is what you'd typically set up as a bare minimum. So that's in the user namespace. And like I said, I set up a keyboard shortcut. And so anytime you see down here, as I'm going through the demo, that happened, I just had a keyboard shortcut to do that. So I can be in, you know, in some file over here messing with things and say, Oh, I want to try that. Oh, no, I modified that. Let's restart. So there is no automatic hot code reload on the server, you have to trigger it once you're ready with the changes. Okay, so we've got our server. Now, what do we have to do to make the client talk to the server? Well, it's really quite simple. We go over into our client, we find where we defined the app, we find the full graph function, and we add a map of remotes. So remotes is the option that used to be called networking. I may I add an alias for that just so porting is lazier. But that I don't tend to like aliases. So anyway, you say remotes, and then you name your motor keyword, you can have as many remotes as you want. And there's a built in remote implementation for talking to http. And there's an add on library for WebSockets, full curl hyphen, WebSockets, in the falkor, logic, GitHub, group, organization, whichever. So this guy defaults to contacting the server that the web page was loaded from, at the slash API endpoint. And if you look back at our server definition, we've told rappi API to listen to the slash API endpoint. So remember, what we're sending from the client is a full query, it tells the server everything it needs, there really only needs to be one contact endpoint, this is rest this is send a query to the server query gets answered by the server via parser. So that's all there is to make the client be capable of doing full stack operations. So pretty straightforward. And this, of course, has all sorts of options you can add in, you can add an extra middleware, you can extend the transit encodings. So if you have, say, you maybe have some particular data structure you want to encode geocoded data into or something and you want to carry that over transit. You can add transit handlers on both sides and actually have that be a supported data type on the wire transits really nice in that it already knows how to encode big decimal, it already knows how to encode dates, etc. And so what I recommend most people doing if you're going to use, say, monetary units, let the big decimal come across. Now unfortunately, JavaScript or closure script doesn't directly support big decimal, it brings them in as this tagged representation. But it's not hard at all to grab like a JavaScript library, like big j s. that implements big decimals in JavaScript and simply wraps them Some, you know, make yourself a little math library that makes those truly isomorphic on the closure closure script side, syntactically, so for example, one of my projects, we have a math namespace where it's got imported aliases, M, and then it's got like M greater than n m plus and, etc. Where you combine, you can mix and match things and it gives back big decimals. And then you can keep in state the big decimal the whole time through. And so your state on the client is always big decimals, your state on the server is always big decimals, your state on the wire is big decimals. And then all you have to do is just adapt your UI inputs to make sure that they understand that, okay, it's, it's a string, when it's talking to the DOM, when I get the string back, it goes back into big decimal, that sort of thing. So I kind of I kind of highly recommend Don't, don't make your types different amongst these, these two sides, you've got the same language on both sides. Yes, there are some differences, big decimals, one of them make it work in terms of dates and times. There's a new library that's in alpha called tick from just that looks to be we're already using it in a couple of projects, kind of standardizes the,

the way of using time, you know, full stack works enclosure works, enclosure script works the same way wraps, you know, the Java time, things get you down to instance, which is usually what databases want to persist. I just highly recommend, get it all in one thing. Don't be trying to convert these things on the fly, like you're doing JavaScript don't do that. There's much nicer ways of doing it. Okay, so we've got it set up. Now let's start talking about a few more things. This is there's a lot of little concepts in this particular video, if if all you wanted to know is how to make it, hook up, we're done. The rest of this video is really talking through some of the kind of best practices and other things and actually seeing it work like seeing some some API calls, do some loads, etc. Okay, so let's we got our repple running, we're on port 3000. It's time to play with Volker inspect. So let's clear this out, we can see that there was data we already normalized with this initial state stuff. So let's go through here and just say, you know what, our person list is just empty, there are no people in our person list. And we're just going to stop ignoring, or start ignoring our initial state for a person because they have no initial state. And cars because they have no initial state on the first render, I don't know who the people are. And I don't know what cars they owe, and I gotta ask the server for that. And then I think we do have a make golar mutation declared here, but I think it's currently deleted it. So I think it doesn't seem to be there. And I don't think I declared any place I must have dropped it, but that's fine. So let's just take that out, because that was her, let's leave it animal will remake and make it a full stack thing. Okay, so I'm going to start splitting things apart. into Oh, I did, I did put make make folder over here, I started to data model. Okay, now you'll notice my model files here, car and person or clj. c files, you can do this in a number of ways. And I'm sort of just kind of going to play through the options you have here. You could make completely, you can you could jam everything into one namespace. That's one way of doing things. I don't tend to like very large namespaces for a couple of reasons. One, anytime you change them, they, they, they themselves take a long time to compile because they're large. And the larger they get, the more things tend to depend on them. And so when you change it, you get this like tree of things, that has to be recompiled. Because the compiler can't easily tell what did and didn't get affected. And so you get kind of large ish, incremental builds. So in terms of scalability, I recommend small, concise namespaces that's part of the reason why Falco has been broken apart from version two to three into, you know, a fairly large number of, of namespaces, where each one has, you know, a specific purpose. So, that's kind of a thing, I've come to the conclusion on working in closure for years. I just like smaller namespaces. Now, what you could do is we're going to start talking about the data model where we have a full stack data model. And so that's really kind of the sub topic that I'm talking about here. So I've got people and I've got cars. And those things might need closure specs, I might want to spec them. They might need particular ways of access to them so I can get from the server to the client. That's what these resolvers are. We'll talk about those in just a moment. And I might want to co locate at least a namespace name, the closure script version and the closure version and kind of the same logical named place. And the reason for that, if you remember over here, make older This is a namespace thing. Even though it's a piece of data, your mutations aren't all top level simple names, that would be horrific, right? As scalability wouldn't be great. This is really something like, Well, in this case, it might be app model. Make older, or app model person make older, right, that's the actual mutation symbol that I'd want to send in order to invoke something in that namespace. And so what I could do is I could create closure script namespace called person. And I could have a person clj, right, I could have two different namespaces and put the server side stuff in one file and the client side stuff in a different file. The problem then is a clj. c file, if I remember correctly, a CLG. c file can't also be there, you can't have all three. So if you really want

want there to be both kinds of languages, with the same name, you either have to do them as purely separate files, or one clj. c file. And one clj. c file is convenient. Because there are some things that you'll wanted both. So for example, specs, I might want the specs for ID name, age, and the actual full model of the person to be specs that I can access on the closure script side and the closure side. And have those for instrumenting testing functions, enforcing contracts, etc, whatever, I might need them for those I'd like to share. However, maybe my database on the server and my resolvers on the server, well, those are just closure code. And so making a CL JC file, you know, you do these conditional statements that indicate Okay, this is just for the closure side. And so you know, it looks a little a little messy. And, you know, when you get down to the mutation, you end up doing something like, okay, on the CL JC side, it looks like that thing. And in the CL JS side, it's this other def mutation that has the same name. And now you can argue that, Oh, well, now I'm mixing, you know, client code with server code. And that's true. That's absolutely true. And it's a good argument for making them separate namespaces and potentially choosing another namespace for just the pure model. Right. So there are bunch of ways you can do this. I'm going to for convenience, and and compactness in this talk, probably keep them all in the single file. But I just wanted you to know that some of this is going to be like a best practice. And some of this there are trade offs. Right. So if I were doing this as a best practice, I might just put the specs in, you know, a namespace of their own that was just for the specs, that's all it went in, there was the specs, and then choose a similar namespace, maybe in a slightly different package for dealing with the operations and the resolution of those of those things. So right, I might make an app specs, and then make a namespace called person that's CL JC and then in here,

do that.

Let's do that. And so then that gets me into something where I can convert this to closure, which is mostly what that particular file was already. Right, I can raise these up and get rid of this extra craft. That's probably more than best practice way of doing this particular thing. So I did end up mixing and matching my client and server code in the same file. Even though from a namespace perspective. I might want to put a closure script file called person in the same directory with my specific

implementation for the client. Okay, so let's talk namespacing for a second. So I've gone over here and I've made this spec, I'm going to do the same, same, same thing for clj. c file for car. And I'm going to do the same sort of require, and that's all that's gonna go in here. And then maybe over in car, I don't think I had any specs. But now we can convert this to a clj, file, splice. splice, splice that. Okay. Now I'm creating these namespaces primarily for specs and to give a distinct name to anything that I do spec. So let's talk about this for a second. So if I if I look at that colon colon field, I think we mentioned this in an earlier one. And as a closure programmer, you should know this, like the back of your hand, colon colon puts the current namespaces namespace name and as the namespace of the key word, something that a lot of people are doing, including me and documentation for clarity, and I've seen it in de Tomic docs, etc, is the thing you've seen already in many of these videos, where we'll name and attribute something that's just sort of like entity and an attribute. The problem that you're probably going to run into or possibly going to run into and I sort of consider this like a potential looming cancer for for closure, is if you make a simple keyword like this, the the design of specs is such that this def registers this keyword into a global registry. And that global registry has the semantics, and the documentation of spec says this, you just have to read carefully. It has the semantic of RDF, it has the semantics of this is a global name, that other people could easily collide with Make sure you use something that you own. Right, so this goes back to the old Java standard of you name things with a namespace you own, you know, comm.fo corelogic, I own that domain name, any name and here is when I create and control it's a federated namespace, the Federation is I own that one, you own some other one, somebody else owns another one. And we don't want to stomp on each other. If I start injecting person ID into this global registry, well, then I might load some library that does the same thing, unbeknownst to me, and but maybe they say, Oh, well, this is a positive event. Or this is a UID. Or this is a right. And now I'm in trouble. Because now some library has infected me with a spec I didn't expect. And now start stuff start to act and behave Li maybe mic generative test crash, and I'm scratching my head about it. So you really want to generate globally unique names as much as possible. And I'm still, you know, in this particular application, because I've chosen app specs, you know, app is my top level. I don't know that. Right? I'm being lazy here. And I'm admitting it. But I am making a point of if you're going to use specs, to try to get some sort of data enforcement, and I highly recommend you do. And there's a lot of great libraries coming out, I use ghost wheel pretty heavily for some occasional convenience around this, and some other production time, conveniences, and development, time conveniences. These are useful to give you back some of the things that you've lost by dropping a type system without giving you the constraints of a type system. So I do highly recommend them, I highly recommend that you learn how to use them. But if you aren't going to use them, be careful that you name them. Well. Okay, so get off my soapbox about that. And get back to coding. So let's talk about resolvers. That may serve right I've set up this path path home parser. And I'm using Connect which is a the main sub library, if you will, of path home that lets you register resolvers. And resolvers here you can see is just an array and and this array contains sub arrays. So it's just like an array of arrays of arrays of arrays of however deep you want to go that eventually gets you to resolvers and so instead of using a multi method where you kind of get you have to require the namespace and make sure you've you know, etc, etc. This makes it very explicit. And this also makes it possible for you to define multiple partials in the same server side. They can answer different kinds of of questions.

So this is kind of the preferred way of billing These, you certainly can write a macro that auto registers ease. I've certainly done that in some projects. So I just want to show you the, there's one way of doing it here. Okay? Are there more than one way of doing it? So how does this work? pythons actually pretty straightforward. And it's it's got some really great yet simple ideas. So let's go look at the person resolver. I've created a table in here that looks a bit more like what I'd see in a database like de Tomic or even SQL, right, you've got some table. And in this case, I'm indexed by ID sort of like I do on the client side. But instead of these being identities are just like, you know, foreign key references. Cars. Well, it's going to be car with ID two cars, it's going to be car with ID one. And these are just sets. This is sort of how de Tomic does it. So if I go look at my car's model, you see, I've got a table over here that says, Oh, well, car one is his Honda Accord cartouches, a Ford F 150. Okay. Now, we get to some interesting things here. If we go over to the query tab of Volker inspect, we press this little gray button here. Well, it should turn should turn green, maybe I didn't reload it after I. There we go. Once it turns green, it's actually loaded the indexes, according to what these resolvers have spelled out for it. And so let me show you what that means. When I define a resolver. For car resolver, I can see that I expect this input, a app model car slash ID, and I can output the Id make and model of that car. And then the code to do that. So in this case, this could be an SQL query, this could be an A Tomic query, this could be whatever this just needs to fulfill this promise, given the incoming parameter, which will be there because I said that this inputs required. So pathom will figure out how to get you the input, if it can, it'll pass it to you as a parameter. And then you have to satisfy the contract of outputting. That stuff. Once you've defined that resolver, then you can go over here and say, Well, I want a join on App dot model. dot car slash ID one, and I want app dot model. Make. And I got an odd found one big enough out. Oh, because I moved. I moved everything. It didn't reload the code. Load stuff over here. query on the indexes. Oh, okay. So now I've got, I think after I've talked about all these keywords, I think just for clarity, and quickness. Here, what I've done is is I've named I've moved. This is like off the cuff kind of thing I did here creating these demo. And now my namespaces don't match what I've defined on the resolvers upfront. So I think we're going to do is just say, Let's not talk about specs for the moment. Let's just simplify the namespaces. Let's do the simple thing for demo purposes. So we don't waste a lot of time on points that have already been made.

I'll talk about all these pieces in just a second. Directly actually pretty easy.

Okay, restarting the server, reloading the code over here going to the query tab loading my indexes, and now I should see car Why am I not getting?

Definitely should be seeing that. And so the way the duck resolver works is you tell it what the inputs are. I'm going to stop this restarted just in case I've screwed up my house. Code reload, you can specify what input you expect. And this goes back to over here in the UI. When we defined wrong UI, client, we defined car remember, we had this ident notation of well, the table name is going to match the ID name. And the reason for that is if you do a query, a join, whose join key is an ident. Car ID one, and who subquery is like what you want out of that car. That's what you're seeing we do over on the right path home can automatically establish that if you're joining on an ident, it knows you want to start with car ID set to one. So it already knows a car ID. That means it can go looking for resolvers, like this guy that says it can take a car ID and then the declaration of what it outputs it can use to figure out if this particular resolver can resolve the thing that you're asking for.

And in this particular case, we're getting some sort of error. Okay, lesson number one, talk on the right port. So I was talking to shadow clgs. Here, I need to be on 3000, which is where I started my real server. And I didn't give it a default page. So I'm actually going to have to say index dot HTML. Now I'm loading from the correct server. That helps, okay, so you can't ask queries have a server that doesn't know what you need. So that explains why the This was turning yellow the first time I'm not sure why it turned green ever. But now I should see, Ah, there we go. So I can ask for a car ID one. And then I can ask for car make their I can ask for car model, I can run that. And I get back on the record. I can ask for car to f150 Ford. Okay, so there's your first resolver. Now, as promised, not demonstrated until now. But as promised, this little bit of code here with an SQL query de Tomic query MongoDB query, whatever database you're using, just needs to know how to get from a car ID to these other facts, and it can resolve that layer. Now, the next cool piece is over here on the person side. So the person side, I've got the same sort of thing for the person resolver, I say the input is person ID. And from that I can get person name, I should also say I can get person's age. If you don't declare this here, it doesn't mean you can't return it, it means that it won't show up in the autocomplete over here in the tool. So this PC output is very much about what's Yeah, it's about a combination of it's mostly about autocomplete. But notice here for the cars, I'm not saying what other things are in a car, because this resolver doesn't resolve that. All it does is resolve the joints. And so the code of this is saying if you give me a person ID, I can give you the name, I can give you the age, I can give you their car IDs. But that's it. And I actually it's allowed to resolve more than that. But if you look at the implementation here, I'm taking all of the people which is this database, I'm getting the one they asked for. And then I'm updating the cars field, which is a set. And, and taking that set of IDs in and returning a vector of things that look like a map of car ID. So I'm basically building a map that matches what I'm asking for. So now we're here I can ask for person ID to person slash name. And then I can ask for a join on person. Cars, and then it should already know that I can ask for car make. And then of course, person named Sally. So Sally has a Honda Sally has car one. And car one. Sure enough is Honda. Okay, so that's how we can join things together and have pathom build the graph for us. There are a number of other features in path I'm not going to cover them in this video. Let's go ahead and get a full stack mutation going here just for for giggles now for for that to work, our database actually has to be modifiable. So let's move our database table over into an atom. So this is a root level resolver let me go ahead and finish fixing this to be a writable database. Restart the server rerun a query still looks the same. Version resolver. So if you say that no input is needed, like this one said person ID is required here we said no input is required but we can output A join of all people to the person IDs. So this creates a root level query, or a keyword based query, I guess would be maybe a better way of seeing it. So I can ask for all people. because nothing's required to get get there. And so path node knows how to start that. And so it knows that person ID is a thing I can ask for there. And you see person ID one and two. And the other resolver says, Well, if you have a person ID, then person name is obtainable. And I'm not getting a resolution there. I'll have to fix that. Did I do that right? Oh, people, oh, I need to join. That's why it's not working. There we go. That's why that completion wasn't working either. There we go. So join all people to the subquery. And then, of course, I can do a join on person cars to the car make. And we can see that Sally owns Ana, and Bob has a Ford. Okay,

so this is kind of your your, in graph qL, this would be called a route resolver. In eql, this is just a global resolver. Basically, you can ask for this anywhere. because it requires no context. So if I want to go down here and say oh, and then I want all people again, and this time I want person, just person name, you can do that. And it'll be it'll be returned and nested inside of here. So that's, that's another advantage that path home or that's an advantage path home has over graph QL. Because of this schema lists, it's perfectly fine to mix and match global resolvers wherever you happen to need them. And so there's no need to have, you know, a root at the root. This also lets you do things, this is a really nice feature. Let's say you needed to know if your clients time was the same as your servers time, right, you could say the output is the fact server time. And so then you're going to return server time as Java util. Date, which is an instant, transit can handle that. We're going to add that to the resolvers that are supported. Restart the server. And then anywhere in here, when I call it server time, oh, not found? Why is it not found. output is server time I output server time with a date, I put current system time into the list of resolvers.

Interestingly, Completion is telling him to me now but I have mismatched this Oh, let's, let's actually make things match. There we go. Now I'm getting the server time is an instant. And I can mix that anywhere I want. So if I had, you know, back to our joint or at all people, and I had person, say, age, this time, I could just make server time in there and get the server time at that layer. So these global resolvers are particularly handy, since Velcro gives you normalization, being able to grab things at any place in your query tree is quite handy just doesn't matter. It doesn't matter if they're, they're nested somewhere in the query. Because you're normal, you're normalizing them at the end of the day. Okay, so now that we've got, let's leave that resolver there, it's not hurting anything. Now we've got a way of resolving these things. And we've we've kind of tested out the query engine and see that it seems to be working right, we should be able to populate our client when it starts. So over here, we're gonna say on a nit c now and it's getting called every time the client remounts. So we probably don't want to do it there. So instead, we can go into here. So client did mount is just a callback function that gets called once and only once on the real mount of the application. And so early in earlier videos, we saw merge component. And there's another function in the data fetch namespace, which I just required. And this data fetch namespace has load and it takes very similar parameters to merge component, except it wants to build a query for you. And so here we're going to ask for all people because we know that that's And all the people are persons. So essentially, I'm making a query that it's a join on all people, that isn't the name of my resolver. Right? All people with. So that's essentially what those two arguments combined together to do. If you make this No, then you get just a prop query. And if you make this an ident, then you get that earlier, person ID to join query. So any of these things could be done. So let's, let's just start with this one, let's say if we load person two on start, so I can reload, I can go and look at my database, and you should see person ID, I've got person two. Now, of course, person two didn't get joined into the rest of the graph anywhere, so nothing showed up on my screen. But if I load all people here, knowing that their persons, the server is going to return me too many, so that will result in normalizing it to anything over here. So now I should see two people, all the people in the database, and I should see a top level key called all people that has my two identities in it. Now, that's not where I wanted that edge, right? That ended up in in the route because I queried it from the route with load. But the edge I really want to build in my graph is the person list, people edge. But I know that one set component ID person list, person list people, so I can target. So this is just like the merge component, replace component, ID, person list, person, list, people, that's where I want that edge to go instead of in the route. Now when I reload, I get my people. Okay, so there's your first exposure to a full stack load. And you can see, it's just almost identical to merge component, you're just telling it, you know how to find the data, and then merge component, you're actually handing it the data. And path on resolvers. If you look at the Falco inspect Network tab, you can see that it queried for a join on all people and then specifically what the component and sub components asked for. Right now, if I go and do some refactoring my code and decide, you know what I don't want to show how old they are, I'm going to take age out of the query, I'm going to take age out of the UI, I'm going to reload, you'll see that the Network tab here, then send a query that doesn't have agent and of course, still normalizes it still puts it in the database in the right place. But reduces your overall network reload. So that's,

that's always been one of our big intentions is to get that kind of data flow in normalization, working consistently across all possible ways we, we deal with this data. Alright, last thing, we said we were going to do the mutation. So let's go into person CL, j, s, and let's finish recoding. This. So here before, if you remember, we had person keys, ID, we're going to pass in person ID. And then we're going to update in person ID, ID, person age, and we're going to increment, right, that's the make older mutation. Back in the client, now we need to get app model.

Now make older no longer needs quoting. Or uncoating. Remember, this function, if we call it directly, you know, I'm not in a closure script trouble. Let's start the closure script trouble. And

if I actually run that function, as it will here, it just returns itself as data. And so then that's what's going to be submitted to transact transact is going to push it through the processing system, and actually run it. So at the moment, if we look at our transactions, and we say make older, we see it's making this person older. But on the network, nothing's happening. Because that's not a full stack mutation yet. Now we do have on the server side, that's client side, this is server side, we do have a mutation I've already started to put in here and in here, same thing, it's going to want the same parameter. But in here, the code is just a little different. So the code here is going to be a swap on the people database. And it's going to be in, it's going to be very similar Actually, it's gonna be an update in at ID Person age, Inc. So it's very similar because the database is, is very similar. And I'm going to return an empty map here, be very careful about mutation return values, because folkwear does actually support return values from mutations. And so you don't want to return some arbitrary thing here that that might not be serializable. So for example, how can I throw here that transit wouldn't like?

It's gotta be something.

That one that implements an interface cloneable serializable? Yeah, that should, that should screw it up. Go to the right, rebel, say go. Okay, so my implementation is right, I'm trying to show that the return value of this full stack, I'm mixing and matching things, let's just hold off on that for a second. This would update my my database over here. And you can see if I come up here in the repple, and look at this current database, I can see how people are on the server, all I have to do to make this full stack is go to the client side version of this, create a section that uses oops, the same name as I named it, when I created the remote server remote, if I had called this Bible, then I would call this Bible Excuse me. But by convention, we just call the the main remote remote. I don't need the end, usually here, I can return true, I can return the end, I can return a number of other things to modify the outgoing network request. But the true just says send the same thing to the server as the client process locally and it's transaction processing system. So So literally send that data structure across the wire. Let's restart my server to get that implementation of the server side mutation. let's reload the client because we've we've modified the clients database to be different from the server. Let's look at the transactions tab. Clear this Network tab is clear that let's hit make older, we see locally. It called the make older mutation. And before it was 22. And after it was 23. And if we look at the Network tab, we see that same exact mutation as data was sent over the wire triggered over here. And we didn't log anything. So we didn't see anything there. But we can go and see if we output this guy that Bob's age has changed to 23. And if we reload the page, Bob's age is still 23. As we would expect the database changed. So we can pop this guy up to something like that reload, we've now got a full stack mutation. So you can see that once we get the server setup, things start to fall together pretty well. And it's pretty simple to implement things, especially since it has the same abstract representation on both the client and server in terms of it, it's just data. So let me go back to this particular point I was trying to make. If I do that, you see an error happened over here. And you see probably an error in the console here internal server error. This is the kind of thing you want to kind of watch out for. So basically, if you read this carefully, transit write simple, oops, copy, paste and drag and drop, I never never understood that. It doesn't know how to encode bitset bits, that isn't something that transit has built on, you could actually tell it how to encode bitset, but it doesn't currently know how. So if you accidentally return some some garbage from some function call because you weren't thinking about what it returned, you can cause these mutations to crash. So be careful. You know, what you put here, an empty map is fine, a keyword is a reasonable thing to do. Both those things are in codable. And, interestingly, if you wanted to do something like have the path own parser, let them have returned value with a constructed sub tree happen. You can return something like that from a mutation and then if the client sends the mutation with a mutation joined query, the parser can follow from this mutation on to find a response that's different from whatever query you might have had to query for the thing to begin with. More advanced topic, but interesting to note. I think that's enough. This video is getting rather long. So we'll stop it here and continue with with a new one shortly.

