#+TITLE: Eql Pathom Overview

Understanding EQL and Pathom are the other most important skills you will need to understand when starting out with Fulcro.

* Warning!

This is a "Work in Progress" document that may be incomplete, contain errors, and be generally wrong or bad. Please use at your own risk until this warning is removed!

* Notes

- Focused on EQL (don't go into depth on fulcro and pathom)
- Use a quiz-style? (present idea and quiz for other examples)
- Static to get the base done and them make interactive
- Create example that uses 3 levels of nesting (maybe person, friends and groups?)
- Look at existing GraphQL tutorials for reference
- Look at learndatalogtoday.org for reference
- Consider a separate Pathom tutorial that takes EQL examples and expands on them.

* What is EQL and Pathom?

EQL is a way to query and mutate hierarchical data. It works particularly well with graph-like data (i.e. data organized in trees or connected graphs) but it can be used with many different types of data sources (datomic, SQL databases, REST APIs, GraphQL endpoints, etc).

EQL has been compared to GraphQL and there are many similarities between the two technologies. EQL, however, is more clojure-centric and because it uses Extensible Data Notation (EDN) as it's data format it's a better fit for clojure applications.

Like GraphQL, EQL is just a specification for how to describe and query data and it needs an actual implementation to do work. Pathom is a Clojure implementation of EQL (just like Apollo is an implementation of GraphQL).

It is important to note that the following examples are provided to help you understand EQL syntax but you will need an implementation (like Pathom and data source) to explore EQL in the real world. Whether you will be able to perform the queries below in your real-world implementation depends on the features provided by your data source and the "resolvers" that have been setup (more on resolvers in the EQL in the real world section).

Also, please note that the following is geared towards beginners and at times may gloss over some of the thornier details. For the full specification and additional details please see the Resources and References section at the end of the document.

* Why Use EQL vs REST?

<TBC>
- EQL exists to allow different clients (e.g. web, mobile, set-top box) to request the data they need without requiring developers to create and maintain a large number of "special purpose" REST endpoints for each different client.
- EQL allows clients to define the "shape" of the data they need on the client side without the burden of having to "munge" the data on the client once they receive it from the API endpoint.
- EQL is a a good choice if you are writing a new application and do not have to support legacy clients written for existing REST APIs.
- EQL implementation like Pathom allow clients to interactively query datasources making it easier for developers to discover and mould the data they need during development.

* Getting Started with EQL

Before diving into the details and featured of EQL, let's explore some basic EQL queries so we can get a feel for the syntax. If you are familiar with Clojure, EQL will probably look quite familiar as it uses many common Clojure data structures namely, keywords (:keyword), vectors "[]", and maps "{}".

To explore EQL queries we'll need some data. While EQL and Pathom can connect to multiple, different data sources at the same time, to keep things simple we'll use the following basic data structure as our initial data source:

#+begin_src clojure

[{:list/id  1
  :list/name "Personal"
  :list/items [{:todo/id 1
                :todo/label "Buy Milk"
                :todo/status :notstarted}
               {:todo/id 2
                :todo/label "Cook Dinner"
                :todo/status :notstarted}
               {:todo/id 3
                :todo/label "Mail Letter"
                :todo/status :notstarted}]}
 {:list/id  2
  :list/name "Work"
  :list/items [{:todo/id 4
                :todo/label "Write TPS Report"
                :todo/status :notstarted}
               {:todo/id 5
                :todo/label "Send Emails"
                :todo/status :notstarted}
               {:todo/id 6
                :todo/label "Have Meeting"
                :todo/status :notstarted}]}]

#+end_src

One way to think about EQL queries is to imagine them as a "description of the shape of the data" that you want. Said in another way, you tell EQL what data you want and EQL tries to fill in the values. The simplest description of data is to ask for properties. Properties can be thought of as a "label" for data (or if you're familiar with dataomic it's like an "attribute"). Properties are expressed as Clojure keywords (e.g. ":todo/label"). To ask for specific properties we put them in a transaction which is represented by a Clojure vector "[]"

For example, to make a query on our example code that asks for the :list/id and :list/name we write:

#+begin_src clojure

[:list/id :list/name]

#+end_src

and we would receive:

#+begin_src clojure

{:list/id 1 :list/name "Personal"
 :list/id 2 :list/name "Work"}

#+end_src

Notice that we use vectors to issue a query and we receive a Clojure map "{}" as the result. In this result map, the properties appear as the map keys and the query results appear as the map values. To be more explicit, ":list/id" is a property (a keyword) and "1" is the query result (a value).

It's similar to using `select-keys` to specify which fields to extract from a map. You can think of properties as "individual pieces of data" or as the "leaves" at the end of a tree of data.

** Background on Joins

Now that we can query for individual pieces of data, how do we ask for nested data or data that is represented by a reference. To do this in EQL we use a "join" which is represented by Clojure maps "{}". If you are already familiar with the concept of database joins from SQL or graph databases you can skip ahead to the "Joins in EQL" section.

The idea of a "join" is common in relational and graph databases and it refers to linking one record's unique key in another records data. For example:

Email Table
| UserPrimaryKey | UserEmail    |
|----------------+--------------|
|           1001 | joe@foo.com  |
|           1002 | bill@baz.com |

UserName Table
| UserPrimaryKey | FirstName | LastName |
|----------------+-----------+----------|
|           1001 | Joe       | Walsh    |
|           1002 | Bill      | Jones    |

In this simple example, if you had the "UserEmail" you could get the "FirstName" and "LastName" by doing a join on the "UserPrimaryKey" column. To be more explicit, if you had "joe@foo.com" you could do a join from the "Email" table to the "Username" table to look up the first name "Joe" and the last name "Walsh" of this user with email "joe@foo.com". This is possible because the rows in the different tables are identified by the same "UserPrimaryKey" (in this case "1001").

Joins in "Entity / Attribute / Value" and graph databases work in a similar way:

Let's say we convert our example data from the Getting Started section above into a "pseudo" graph database format separating the concepts of "Lists" and "Items" into their their own structures we might come up with something like this:

#+BEGIN_SRC clojure

{:LIST  { 1 {:list/id 1
             :list/name "Personal"
             :list/items [[:ITEM 1] [:ITEM 2] [:ITEM 3]]}
          2 {:list/id  2
             :list/name "Work"
             :list/items [[:ITEM 4] [:ITEM 5] [:ITEM 6]]}}
 :ITEM {  1 {:item/id 1
             :item/label "Buy Milk"
             :item/status :notstarted}
          2 {:item/id 2
             :item/label "Cook Dinner"
             :item/status :notstarted}
          3 {:item/id 3
             :item/label "Mail Letter"
             :item/status :notstarted}
          4 {:item/id 4
             :item/label "Write TPS Report"
             :item/status :notstarted}
          5 {:item/id 5
             :item/label "Send Emails"
             :item/status :notstarted}
          6 {:item/id 6
             :item/label "Have Meeting"
             :item/status :notstarted}}

#+END_SRC

In this case we can access the individual items in list 1 by doing a "join" from the LIST table on the ITEM table using the ITEM IDs. To be more explicit, we can see that the LIST with ID 1 refers to ITEM 1, ITEM 2 and ITEM 3 and we can get those items buy doing a join from the LIST table on the ITEM table.

One of the cool things about EQL is that regardless of your datastore's underlying implementation (SQL, Datomic, REST API, etc.) you will be able to access any of your data using EQL queries.

** Joins in EQL

In addition to asking for properties (i.e. the data at the "leaves" of the tree like ":user/email"), we can also easily query for nested data from our example data using the Clojure map "{}" syntax. As mentioned above, this is called a "join" and indicates that we want to query for related or "nested" data.

For example, let's say that we want to query for the individual todo items from our original data structure in the "Getting Started" section. To get this data, we would use the "{}" syntax to issue a join on :list/items like so:

;; FIXME - verify if this query is valid!!

#+begin_src clojure

[:list/id :list/name {:list/items [:todo/label]}]

#+end_src

... and we would receive:

#+begin_src clojure

[{:list/id 1 :list/name "Personal" :list/items {:todo/label "Buy Milk" :todo/label "Cook Dinner" :todo/label "Mail Letter"}}
{:list/id 2 :list/name "Work" :list/items {:todo/label "Write TPS Report" :todo/label "Send Emails" :todo/label "Have Meeting"}}]

#+end_src

Notice a couple of things about the example above:

- We used a clojure map "{}" around {:list/items ...} to query for the nested data. The map goes *before* the name of the item that you want to join on.
- We only asked for the :todo/label in the query. That's why the result include the properties of :todo/id and :todo/status
- The syntax for an EQL join ia a map. The map's key is the item you want to "join on" and the map's value is a vector of the properties you want in your result.
- Joins always take a single entry as the "key" in the map - the key is the property to join on. The value part of the join are the properties that you want in the response.
- The value part of a join is called a "sub-query". I.e. in the join {:list/items [:todo/label :todo/status]} - "[:todo/label :todo/status]" is the sub-query.

** Nested Joins

If you have nested data then you can use nested joins to access that data. For example if we extended our initial sample data to include "notes" for each todo we might have something like the following:

#+begin_src clojure

[{:list/id  1
  :list/name "Personal"
  :list/items [{:todo/id 1
                :todo/label "Buy Milk"
                :todo/status :notstarted
                :todo/notes [{:note/id 1
                              :note/content "Maybe chocolate milk?"}
                             {:note/id 2
                              :note/content "Yes, definitely chocolate milk"}]
                }
               {:todo/id 2
                :todo/label "Cook Dinner"
                :todo/status :notstarted
                :todo/notes [{:note/id 3
                              :note/content "Dinner ideas: Pesto Pasta"}]
                }
               {:todo/id 3
                :todo/label "Mail Letter"
                :todo/status :notstarted}]}
 {:list/id  2
  :list/name "Work"
  :list/items [{:todo/id 4
                :todo/label "Write TPS Report"
                :todo/status :notstarted
                :todo/notes [{:note/id 4
                              :note/content "Don't forget the cover sheet!"}]}
               {:todo/id 5
                :todo/label "Send Emails"
                :todo/status :notstarted}
               {:todo/id 6
                :todo/label "Have Meeting"
                :todo/status :notstarted}]}]

#+end_src

We could access this note data using a nested query:

#+begin_src clojure

[:list/name {:list/items [:todo/label {:todo/notes [:note/content]}]}]

#+end_src

The result of the query would be:

#+begin_src clojure

[
 {:list/name "Personal"
  :list/items [{:todo/label "Buy Milk"
                :todo/notes [{:note/content "Maybe chocolate milk?"}
                             {:note/content "Yes, definitely chocolate milk"}]}
               {:todo/label "Cook Dinner"
                :todo/notes [{:note/content "Dinner ideas: Pesto Pasta"}]}
               {:todo/label "Mail Letter"
                :todo/notes {} }]}
 {:list/name "Work"
  :list/items [{:todo/label "Write TPS Report"
                :todo/notes [{:note/content "Don't forget the cover sheet!"}]}
               {:todo/label "Send Emails"
                :todo/notes {} }
               {:todo/label "Have Meeting"
                :todo/notes {} }]}
]

#+end_src

As you can see, anything that is represented by nested data (or a reference, depending on your underlying database implementation) can be accessed using nested queries.

* Idents

- Use idents when you want to restrain queries to a particular sub-set of data.
- Examples from above
- Example using [[:customer/id 123]]

* Mutations

Use mutations when you want to change data.

* Other Features

- EQL also provides recursive queries, union queries, parameters, and query metadata.
- Describe what these are and add references to official docs

* EQL in the Real World

As mentioned at the beginning of this tutorial, EQL is just a specification and, as such, it needs an implementation to be able to use it in a project. Pathom is the implementation of EQL used in Fulcro and while this is not a Pathom tutorial, it's useful to discuss at a high level, how Pathom implements the EQL specification.

Pathom Setup
- What pieces are needed for pathom to work? ()
- What is a resolver?
-

* EQL Pathom and Fulcro

Since this is a Fulcro tutorial let's switch to an example where we can explore how EQL/Pathom works in the context of Fulcro.

We'll use the Fulcro-RAD-Demo together with the Fulcro Inspector Chrome extension.

** Project Setup and Configuration

<Jakub - ideally we would have a Fulcro app running in the page that would allow the user to install the fulcro inspector and issue queries from the EQL tab of the inspector but installing and running Fulcro-RAD-Demo is a good workaround>

- Git clone repo : https://github.com/fulcrologic/fulcro-rad-demo
- Install Fulcro Inspector : https://chrome.google.com/webstore/detail/fulcro-inspect/meeijplnfjcihnhkpanepcaffklobaal
- Install clojure cli (brew install clojure)
- Install npm or yarn (brew install yarn)
- Start front-end (shadow-cljs)
- Start backend (clojure)

** Queries from the Fulcro Inspector EQL Tab

- Connect tab using button
- Start writing queries and see completion popup appear.
- Issue a global query for

* Resources and References

The official EQL docs: https://edn-query-language.org/eql/1.0.0/what-is-eql.html
